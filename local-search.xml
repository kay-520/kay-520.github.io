<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021 迈步向前</title>
    <link href="/2021/01/04/47%202021%20%E8%BF%88%E6%AD%A5%E5%90%91%E5%89%8D/"/>
    <url>/2021/01/04/47%202021%20%E8%BF%88%E6%AD%A5%E5%90%91%E5%89%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>从工作到现在（三年半），一直都没有写过关于自己的一篇博文，想了想，还是有必要给2020年画上一个完美的句号。</strong></p><h2 id="2020-展望回首"><a href="#2020-展望回首" class="headerlink" title="2020 展望回首"></a><em>2020 展望回首</em></h2><p><strong>2020而言，发生了太多的事情，也留下了很多遗憾。可能自己还没反应过来，这一年就在指缝间溜走了。</strong></p><p><strong>一月份，对于我最大的印象就是出差、疫情，那时候还在杨凌出差中，恶劣的办公条件，现在想起来都瑟瑟发抖。一直到21号，我踏上了了回家的列车。迎面而来的就是关于新冠状病毒的消息，我记得也是大年三十及之后才真正的引起全国人民的注意，一下子全国进入了警戒响应状态。也是自己毕生有所认知以来，第一次经历这样的事情，心中难免有所担心。对于2020年过年，这可能是一家人团团圆圆在一起最长的一段时间，虽然有吵闹、很没意思，但总归一家人是在一起的。</strong></p><p><strong>紧跟而来的就是二月份收假在家办公的消息，因为老家没有空调，没有暖气，寒冷的办公环境，翘起代码着实让我四肢无法屈伸。在家办公的这段时间，可能是未来几十年最难忘的一段时间。还好的是，武汉熬了过去，中国也熬了过去。二月二十号踏实了回西的旅程，然后继续在家办公15天，才得以复工。</strong></p><p><strong>三月份可能是我最遗憾的一个月，爷爷去世。三月二七号，早上起来接到父亲的电话，说我爷爷走了。随后就是奶奶的电话，奶奶电话中无助的样子，是我这一辈子第一次见到。在回家的列车上，我刻意克制自己胡思乱想，但眼泪还是忍不住往下流。过年的时候还好好的呢，一家人团团圆圆的在一起吃饭，这才过了一个月啊，意难平。希望时光对我家人好点，我不能再失去任何一个亲人。</strong></p><p><strong>四月份，一个新的开始，工作、学习、健身都慢慢的回上了正轨，要么学习要么健身，总有一个要在路上。相对于去年，今年真的懒散了许多，学习的效率降低许多，花的时间也少了许多。四月份，腾讯云做活动，买了一台4g1核的服务器，在上面搭建了自己的博客以及数据库中间件环境。然后在五月份的时候给域名备案成功，现在可以通过域名访问了。</strong><a href="http://karma520.com/" target="_blank" rel="noopener">博客地址</a></p><p><strong>五一五天假期去一趟成都旅游，着实想去成都的街头走一走，哈哈哈哈哈。</strong><br><img src="https://img-blog.csdnimg.cn/20210104172037966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>以上没有勾选，因为一些原因没有去，成都我们还会再见的。</strong><br><img src="https://img-blog.csdnimg.cn/20210104171440600.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><img src="https://img-blog.csdnimg.cn/20210104171520577.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>六月一如既往的工作、学习、健身，端午期间和朋友去三亚玩了三天，时间真的很赶，但该去的地方都去了，回来的时候脖子晒伤了，脸、腿，着实塞黑了一层，黑黝黝的，后悔当时朋友让买防晒霜没买，有点大意了。</strong><br><img src="https://img-blog.csdnimg.cn/20210104172059762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><img src="https://img-blog.csdnimg.cn/20210104172324961.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><img src="https://img-blog.csdnimg.cn/2021010417212297.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>七月，做了一件上学以后、工作以来，一直没有去做的事情，那就是考驾照，因为吧！本人可能对车真的没啥兴趣，二来就是开车太累了，我喜欢坐车，哈哈哈。科一刚过，练了两天车，然后就去唐山出差了。在唐山的这一个月，设计技术方面的东西很少，大多数是环境部署，以及环境部署完成之后，与客户需求的系统对比，然后与系统相对于的团队沟通，完成客户所需要的系统，以及去客户现场给驻场人员培训西安这边的系统。总之，也学到了一些东西，锻炼了语言能力，对公司系统产品上有了更深的认知和理解。</strong><br><img src="https://img-blog.csdnimg.cn/20210104172414146.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><img src="https://img-blog.csdnimg.cn/20210104172500880.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>八月周末抽时间去了趟北京，时间着实有点赶，而且太阳也特别的晒。吃了北京烤鸭，去了天安门、前门、北海公园、798艺术区。希望有缘再见，北京！接着的就是回西安，去了乐华，坐了过山车，生活总得来点刺激与激情。</strong><br><img src="https://img-blog.csdnimg.cn/20210104172514829.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>九月，回到西安练了两天车，就把这玩意扔到了一边。然后就是每周五和朋友晚上酒馆夜夜笙歌，那段时间可能是最迷茫的一段时间，找不到方向，不想学习，陶醉于纸醉金迷的生活。后半个月，帮着我朋友和他对象复合，去了趟山西太原，再见平遥古城。</strong><br><img src="https://img-blog.csdnimg.cn/20210104172745595.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><img src="https://img-blog.csdnimg.cn/20210104172708638.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="图片"><br><strong>十月份，找回自己，重新出发。学习reactJs，慢慢的又开始了学习，写博客。生活很枯燥，所以你需要给自己找一样寄托的东西，为了那个方向而努力。很高兴再见你！</strong></p><p><strong>十一月、十二月份，并没有发生太多的事情，生活一如既往，两点一线。但也在这两个月，我想好了，明年得去上海了，西安没有什么我值得留恋的了，该离开了。</strong></p><p><strong>说了那么多，基本上都是在说自己的生活，2020年给自己的定的目标，完成度50%。没有达到自己的要求，这一年真的懒散了许多，花费在学习技能的时间太少，相对于19年而言。学习和休息时间分配的不平衡，大多数时间都花费在娱乐上了，不太用心。但今年出去旅游了几次，还是很高兴的。世界这么大，得出去走走！不，疫情期间你还是在国内走走就行了，21年，还要去更多的地方，哈哈哈哈。</strong></p><p><strong>工作上一切都还好，有时候很忙，有时间很闲，忙的时候加班到晚上11点都很正常，但大多数都在年前和年后这段时间。这一年吧，我自己能感觉到的是，通过一次次的项目，自己独立解决问题的能力提高了，思维方式也改变了一些，更重要的是以前遇到老项目二次开发很排斥，现在吧，心态摆正了，正面的去面对它了，性子慢慢磨没了。年底的时候，参与了第一个python项目（odoo，ERP系统），从刚开始项目组的人对这个框架的一无所知，到现在有了一定的理解和认知，也提升了自己自学的能力。总之吧，我始终相信多会一样技能，多一个机会。</strong></p><p><strong>这就是我的2020年，普普通通一枚程序员的一年。</strong></p><h2 id="2021-迈步向前"><a href="#2021-迈步向前" class="headerlink" title="2021 迈步向前"></a><em>2021 迈步向前</em></h2><p>2021 希望你再坚定一点 勇敢一点 别害怕失败 有想法就付出实际行动 是时候给2021年立上flag了</p><ol><li>去上海之前 拿下驾照</li><li>旅游至少两次（暂定云南吧）</li><li>健身（工作第二，身体第一）</li><li>上海工作（做好准备，四月去上海，祝我面试成功）</li><li>多读书 多学习 多写优质博客</li><li>多去做自己不愿意做的事情</li></ol><p><strong>看似简单，也不易完成。加油2021，迈步向前，未来可期，前程似锦，祝你也祝我。</strong></p>]]></content>
    
    
    <categories>
      
      <category>2021-01</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）构建应用</title>
    <link href="/2020/12/07/46%20docker%EF%BC%88docker-compose%EF%BC%89%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/"/>
    <url>/2020/12/07/46%20docker%EF%BC%88docker-compose%EF%BC%89%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">mall-admin:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mall/mall-admin:1.0-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mall-admin</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/app/mall-admin/logs:/var/logs</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">'TZ="Asia/Shanghai"'</span>    <span class="hljs-attr">external_links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql:db</span> <span class="hljs-comment">#可以用db这个域名访问mysql服务</span>  <span class="hljs-attr">mall-search:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mall/mall-search:1.0-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mall-search</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8081</span><span class="hljs-string">:8081</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/app/mall-search/logs:/var/logs</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">'TZ="Asia/Shanghai"'</span>    <span class="hljs-attr">external_links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch:es</span> <span class="hljs-comment">#可以用es这个域名访问elasticsearch服务</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql:db</span> <span class="hljs-comment">#可以用db这个域名访问mysql服务</span>  <span class="hljs-attr">mall-portal:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mall/mall-portal:1.0-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mall-portal</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8085</span><span class="hljs-string">:8085</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/app/mall-portal/logs:/var/logs</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">'TZ="Asia/Shanghai"'</span>    <span class="hljs-attr">external_links:</span> <span class="hljs-comment">#链接外部服务</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis:redis</span> <span class="hljs-comment">#可以用redis这个域名访问redis服务</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">mongo:mongo</span> <span class="hljs-comment">#可以用mongo这个域名访问mongo服务</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql:db</span> <span class="hljs-comment">#可以用db这个域名访问mysql服务</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">rabbitmq:rabbit</span> <span class="hljs-comment">#可以用rabbit这个域名访问rabbitmq服务</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）安装mongodb</title>
    <link href="/2020/12/07/45%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85mongodb/"/>
    <url>/2020/12/07/45%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85mongodb/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker命令安装"><a href="#1-Docker命令安装" class="headerlink" title="1.Docker命令安装"></a>1.Docker命令安装</h2><ul><li>下载mongo:4.2.5的docker镜像：</li></ul><pre><code class="hljs bash">docker pull mongo:4.2.5</code></pre><ul><li>使用如下命令启动MySQL服务：</li></ul><pre><code class="hljs bash">docker run -p 27017:27017 --name mongo \-v /mydata/mongo/db:/data/db \-d mongo:4.2.5</code></pre><h2 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2.Docker Compose安装"></a>2.Docker Compose安装</h2><p>编写mongo-compose.yml配置文件，如下</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">mongo:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mongo:4.2.5</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mongo</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mongo/db:/data/db</span> <span class="hljs-comment">#数据文件挂载</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">27017</span><span class="hljs-string">:27017</span></code></pre><p>然后在当前目录执行命令：</p><pre><code class="hljs shell">docker-compose -f mongo-compose.yml up -d</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）安装ELK</title>
    <link href="/2020/12/07/44%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85ELK/"/>
    <url>/2020/12/07/44%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85ELK/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker命令安装"><a href="#1-Docker命令安装" class="headerlink" title="1.Docker命令安装"></a>1.Docker命令安装</h2><h3 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h3><ul><li>下载Elasticsearch<code>7.6.2</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull elasticsearch:7.6.2</code></pre><ul><li>修改虚拟内存区域大小，否则会因为过小而无法启动:</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 改变设置</span>sysctl -w vm.max_map_count=262144<span class="hljs-comment"># 使之立即生效</span>sysctl -p</code></pre><ul><li>使用如下命令启动Elasticsearch服务：</li></ul><pre><code class="hljs bash">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch \-e <span class="hljs-string">"discovery.type=single-node"</span> \-e <span class="hljs-string">"cluster.name=elasticsearch"</span> \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-d elasticsearch:7.6.2</code></pre><ul><li>启动时会发现<code>/usr/share/elasticsearch/data</code>目录没有访问权限，只需要修改<code>/mydata/elasticsearch/data</code>目录的权限，再重新启动即可；</li></ul><pre><code class="hljs bash">chmod 777 /mydata/elasticsearch/data/</code></pre><ul><li>安装中文分词器IKAnalyzer，并重新启动：</li></ul><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<span class="hljs-comment">#此命令需要在容器中运行</span>elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zipdocker restart elasticsearch</code></pre><ul><li>开启防火墙：</li></ul><pre><code class="hljs bash">firewall-cmd --zone=public --add-port=9200/tcp --permanentfirewall-cmd --reload</code></pre><ul><li>访问会返回版本信息：<a href="http://192.168.3.101:9200/" target="_blank" rel="noopener">http://192.168.3.101:9200</a></li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_08.png" srcset="/img/loading.gif" alt="img"></p><h3 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h3><ul><li>下载Logstash<code>7.6.2</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull logstash:7.6.2</code></pre><ul><li>修改Logstash的配置文件<code>logstash.conf</code>中<code>output</code>节点下的Elasticsearch连接地址为<code>es:9200</code>。</li></ul><pre><code class="hljs routeros">input &#123;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4560    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"debug"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4561    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"error"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4562    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"business"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4563    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"record"</span>  &#125;&#125;filter&#123;  <span class="hljs-keyword">if</span> [type] == <span class="hljs-string">"record"</span> &#123;    mutate &#123;      remove_field =&gt; <span class="hljs-string">"port"</span>      remove_field =&gt; <span class="hljs-string">"host"</span>      remove_field =&gt; <span class="hljs-string">"@version"</span>    &#125;    json &#123;      source =&gt; <span class="hljs-string">"message"</span>      remove_field =&gt; [<span class="hljs-string">"message"</span>]    &#125;  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; <span class="hljs-string">"es:9200"</span>    index =&gt; <span class="hljs-string">"mall-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;"</span>  &#125;&#125;</code></pre><ul><li>创建<code>/mydata/logstash</code>目录，并将Logstash的配置文件<code>logstash.conf</code>拷贝到该目录；</li></ul><pre><code class="hljs bash">mkdir /mydata/logstash</code></pre><ul><li>使用如下命令启动Logstash服务；</li></ul><pre><code class="hljs bash">docker run --name logstash -p 4560:4560 -p 4561:4561 -p 4562:4562 -p 4563:4563 \--link elasticsearch:es \-v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf \-d logstash:7.6.2</code></pre><ul><li>进入容器内部，安装<code>json_lines</code>插件。</li></ul><pre><code class="hljs bash">logstash-plugin install logstash-codec-json_lines</code></pre><h3 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h3><ul><li>下载Kibana<code>7.6.2</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull kibana:7.6.2</code></pre><ul><li>使用如下命令启动Kibana服务：</li></ul><pre><code class="hljs bash">docker run --name kibana -p 5601:5601 \--link elasticsearch:es \-e <span class="hljs-string">"elasticsearch.hosts=http://es:9200"</span> \-d kibana:7.6.2</code></pre><ul><li>开启防火墙：</li></ul><pre><code class="hljs bash">firewall-cmd --zone=public --add-port=5601/tcp --permanentfirewall-cmd --reload</code></pre><ul><li>访问地址进行测试：<a href="http://192.168.3.101:5601/" target="_blank" rel="noopener">http://192.168.3.101:5601</a></li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_09.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2.Docker Compose安装"></a>2.Docker Compose安装</h2><ul><li>Es需要设置系统内核参数，否则会因为内存不足无法启动；</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 改变设置</span>sysctl -w vm.max_map_count=262144<span class="hljs-comment"># 使之立即生效</span>sysctl -p</code></pre><ul><li>需要创建<code>/mydata/elasticsearch/data</code>目录并设置权限，否则会因为无权限访问而启动失败。</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建目录</span>mkdir /mydata/elasticsearch/data/mkdir /mydata/elasticsearch/plugins<span class="hljs-meta">#</span><span class="bash"> 创建并改变该目录权限</span>chmod 777 /mydata/elasticsearch/datachmod 777 /mydata/elasticsearch/plugins</code></pre><ul><li>修改Logstash的配置文件<code>logstash.conf</code>中<code>output</code>节点下的Elasticsearch连接地址为<code>es:9200</code>。</li></ul><pre><code class="hljs routeros">input &#123;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4560    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"debug"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4561    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"error"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4562    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"business"</span>  &#125;  tcp &#123;    mode =&gt; <span class="hljs-string">"server"</span>    host =&gt; <span class="hljs-string">"0.0.0.0"</span>   <span class="hljs-built_in"> port </span>=&gt; 4563    codec =&gt; json_lines   <span class="hljs-built_in"> type </span>=&gt; <span class="hljs-string">"record"</span>  &#125;&#125;filter&#123;  <span class="hljs-keyword">if</span> [type] == <span class="hljs-string">"record"</span> &#123;    mutate &#123;      remove_field =&gt; <span class="hljs-string">"port"</span>      remove_field =&gt; <span class="hljs-string">"host"</span>      remove_field =&gt; <span class="hljs-string">"@version"</span>    &#125;    json &#123;      source =&gt; <span class="hljs-string">"message"</span>      remove_field =&gt; [<span class="hljs-string">"message"</span>]    &#125;  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; <span class="hljs-string">"es:9200"</span>    index =&gt; <span class="hljs-string">"mall-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;"</span>  &#125;&#125;</code></pre><ul><li>创建<code>/mydata/logstash</code>目录，并将Logstash的配置文件<code>logstash.conf</code>拷贝到该目录。</li></ul><pre><code class="hljs bash">mkdir /mydata/logstash</code></pre><ul><li>创建elk-compose.yml文件</li></ul><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">elasticsearch:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:7.6.2</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">elasticsearch</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"cluster.name=elasticsearch"</span> <span class="hljs-comment">#设置集群名称为elasticsearch</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"discovery.type=single-node"</span> <span class="hljs-comment">#以单一节点模式启动</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span> <span class="hljs-comment">#设置使用jvm内存大小</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins</span> <span class="hljs-comment">#插件文件挂载</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/elasticsearch/data:/usr/share/elasticsearch/data</span> <span class="hljs-comment">#数据文件挂载</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9200</span><span class="hljs-string">:9200</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9300</span><span class="hljs-string">:9300</span>  <span class="hljs-attr">logstash:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">logstash:7.6.2</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">logstash</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf</span> <span class="hljs-comment">#挂载logstash的配置文件</span>    <span class="hljs-attr">depends_on:</span> <span class="hljs-comment">#一键部署时，添加该配置</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch</span> <span class="hljs-comment">#logstash在elasticsearch启动之后再启动</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch:es</span> <span class="hljs-comment">#可以用es这个域名访问elasticsearch服务</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4560</span><span class="hljs-string">:4560</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4561</span><span class="hljs-string">:4561</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4562</span><span class="hljs-string">:4562</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4563</span><span class="hljs-string">:4563</span>  <span class="hljs-attr">kibana:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.6.2</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kibana</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5601</span><span class="hljs-string">:5601</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch:es</span> <span class="hljs-comment">#可以用es这个域名访问elasticsearch服务</span>    <span class="hljs-attr">depends_on:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch</span> <span class="hljs-comment">#kibana在elasticsearch启动之后再启动</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"elasticsearch.hosts=http://es:9200"</span> <span class="hljs-comment">#设置访问elasticsearch的地址</span></code></pre><ul><li>执行命令</li></ul><pre><code class="hljs bash">docker-compose -f elk-compose.yml up -d</code></pre><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>需要安装中文分词器IKAnalyzer，并重新启动。</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<span class="hljs-comment">#此命令需要在容器中运行</span>elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.0/elasticsearch-analysis-ik-6.4.0.zipdocker restart elasticsearch</code></pre><h3 id="logstash安装"><a href="#logstash安装" class="headerlink" title="logstash安装"></a>logstash安装</h3><blockquote><p>需要安装<code>json_lines</code>插件，并重新启动。</p></blockquote><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it logstash /bin/bashlogstash-plugin install logstash-codec-json_linesdocker restart logstash</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）安装rabbitMQ</title>
    <link href="/2020/12/07/43%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85rabbitMQ/"/>
    <url>/2020/12/07/43%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85rabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker命令安装"><a href="#1-Docker命令安装" class="headerlink" title="1.Docker命令安装"></a>1.Docker命令安装</h2><ul><li>下载rabbitmq<code>3.7.15</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull rabbitmq:3.7.15</code></pre><ul><li>使用如下命令启动RabbitMQ服务：</li></ul><pre><code class="hljs bash">docker run -p 5672:5672 -p 15672:15672 --name rabbitmq \-d rabbitmq:3.7.15</code></pre><h2 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2.Docker Compose安装"></a>2.Docker Compose安装</h2><p>编写rabbitmq-compose.yml配置文件，如下</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">rabbitmq:3.7.15-management</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">rabbitmq</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5672</span><span class="hljs-string">:5672</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">15672</span><span class="hljs-string">:15672</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/rabbitmq/log:/var/log/rabbitmq</span> <span class="hljs-comment">#数据文件挂载</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/rabbitmq/data:/var/lib/rabbitmq</span> <span class="hljs-comment">#日志文件挂载</span></code></pre><p>然后在当前目录执行命令：</p><pre><code class="hljs shell">docker-compose -f rabbitmq-compose.yml up -d</code></pre><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><ul><li>进入容器并开启管理功能：</li></ul><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it rabbitmq /bin/bashrabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management</code></pre><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_02.png" srcset="/img/loading.gif" alt="img"></p><ul><li>开启防火墙：</li></ul><pre><code class="hljs bash">firewall-cmd --zone=public --add-port=15672/tcp --permanentfirewall-cmd --reload</code></pre><ul><li>访问地址查看是否安装成功：<a href="http://192.168.3.101:15672/" target="_blank" rel="noopener">http://192.168.3.101:15672</a></li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_03.png" srcset="/img/loading.gif" alt="img"></p><ul><li>输入账号密码并登录：guest guest</li><li>创建帐号并设置其角色为管理员：mall mall</li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_04.png" srcset="/img/loading.gif" alt="img"></p><ul><li>创建一个新的虚拟host为：/mall</li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_05.png" srcset="/img/loading.gif" alt="img"></p><ul><li>点击mall用户进入用户配置页面</li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_06.png" srcset="/img/loading.gif" alt="img"></p><ul><li>给mall用户配置该虚拟host的权限</li></ul><p><img src="http://www.macrozheng.com/images/mall_linux_deploy_07.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）安装redis</title>
    <link href="/2020/12/07/42%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85redis/"/>
    <url>/2020/12/07/42%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker命令安装"><a href="#1-Docker命令安装" class="headerlink" title="1.Docker命令安装"></a>1.Docker命令安装</h2><ul><li>下载Redis<code>5.0</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull redis:5</code></pre><ul><li>使用如下命令启动Redis服务：</li></ul><pre><code class="hljs bash">docker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-d redis:5 redis-server --appendonly yes</code></pre><ul><li>进入Redis容器使用<code>redis-cli</code>命令进行连接：</li></ul><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis redis-cli</code></pre><h2 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2.Docker Compose安装"></a>2.Docker Compose安装</h2><p>编写redis-compose.yml配置文件，如下</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:5</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">--appendonly</span> <span class="hljs-literal">yes</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">6739</span><span class="hljs-string">:6739</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/redis/data:/data</span> <span class="hljs-comment">#数据文件挂载</span></code></pre><p>然后在当前目录执行命令：</p><pre><code class="hljs shell">docker-compose -f redis-compose.yml up -d</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker（docker-compose）安装mysql</title>
    <link href="/2020/12/07/41%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85mysql/"/>
    <url>/2020/12/07/41%20docker%EF%BC%88docker-compose%EF%BC%89%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker命令安装"><a href="#1-Docker命令安装" class="headerlink" title="1.Docker命令安装"></a>1.Docker命令安装</h2><ul><li>下载MySQL<code>5.7</code>的docker镜像：</li></ul><pre><code class="hljs bash">docker pull mysql:5.7</code></pre><ul><li>使用如下命令启动MySQL服务：</li></ul><pre><code class="hljs bash">docker run -p 3306:3306 --name mysql \-v /mydata/mysql/<span class="hljs-built_in">log</span>:/var/<span class="hljs-built_in">log</span>/mysql \-v /mydata/mysql/data:/var/lib/mysql \-v /mydata/mysql/conf:/etc/mysql \-e MYSQL_ROOT_PASSWORD=root  \-d mysql:5.7</code></pre><ul><li>参数说明<ul><li>-p 3306:3306：将容器的3306端口映射到主机的3306端口</li><li>-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂在到主机</li><li>-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机</li><li>-v /mydata/mysql/data:/var/lib/mysql/：将数据文件夹挂载到主机</li><li>-e MYSQL_ROOT_PASSWORD=root：初始化root用户的密码</li></ul></li></ul><h2 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2.Docker Compose安装"></a>2.Docker Compose安装</h2><p>编写mysql-compose.yml配置文件，如下</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">mysql:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">mysqld</span> <span class="hljs-string">--character-set-server=utf8mb4</span> <span class="hljs-string">--collation-server=utf8mb4_unicode_ci</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/log:/var/log/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/data:/var/lib/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/conf:/etc/mysql</span></code></pre><p>然后在当前目录执行命令：</p><pre><code class="hljs shell">docker-compose -f mysql-compose.yml up -d</code></pre><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><ul><li>进入运行MySQL的docker容器：</li></ul><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql /bin/bash</code></pre><ul><li>使用MySQL命令打开客户端：</li></ul><pre><code class="hljs bash">mysql -uroot -proot --default-character-set=utf8</code></pre><ul><li>创建mall数据库：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> mall <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8</code></pre><ul><li>安装上传下载插件，并将<code>xxx.sql</code>上传到Linux服务器上：</li></ul><pre><code class="hljs bash">yum -y install lrzsz</code></pre><ul><li>将<code>xxx.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</li></ul><pre><code class="hljs bash">docker cp /mydata/xxxx.sql mysql:/</code></pre><ul><li>将sql文件导入到数据库：</li></ul><pre><code class="hljs bash">use mall;<span class="hljs-built_in">source</span> /xxx.sql;</code></pre><ul><li>创建一个<code>reader:123456</code>帐号并修改权限，使得任何ip都能访问：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">'reader'</span> @<span class="hljs-string">'%'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'123456'</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Maven插件构建Docker镜像</title>
    <link href="/2020/12/05/40%20%E4%BD%BF%E7%94%A8Maven%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F/"/>
    <url>/2020/12/05/40%20%E4%BD%BF%E7%94%A8Maven%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍如何使用Maven插件将SpringBoot应用打包为Docker镜像，并上传到私有镜像仓库Docker Registry的过程。</p></blockquote><h3 id="Docker-Registry-2-0搭建"><a href="#Docker-Registry-2-0搭建" class="headerlink" title="Docker Registry 2.0搭建"></a>Docker Registry 2.0搭建</h3><pre><code class="hljs shell">docker run -d -p 5000:5000 --restart=always --name registry2 registry:2</code></pre><p>如果遇到镜像下载不下来的情况，需要修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值，然后重启docker服务：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"registry-mirrors"</span>: [<span class="hljs-string">"https://registry.docker-cn.com"</span>]&#125;</code></pre><h3 id="Docker开启远程API"><a href="#Docker开启远程API" class="headerlink" title="Docker开启远程API"></a>Docker开启远程API</h3><h4 id="用vim编辑器修改docker-service文件"><a href="#用vim编辑器修改docker-service文件" class="headerlink" title="用vim编辑器修改docker.service文件"></a>用vim编辑器修改docker.service文件</h4><pre><code class="hljs crystal">vi /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">systemd</span>/<span class="hljs-title">system</span>/<span class="hljs-title">docker</span>.<span class="hljs-title">service</span></span></code></pre><p>需要修改的部分：</p><pre><code class="hljs shell">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</code></pre><p>修改后的部分：</p><pre><code class="hljs shell">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</code></pre><h4 id="让Docker支持http上传镜像"><a href="#让Docker支持http上传镜像" class="headerlink" title="让Docker支持http上传镜像"></a>让Docker支持http上传镜像</h4><pre><code class="hljs shell">echo '&#123; "insecure-registries":["192.168.3.101:5000"] &#125;' &gt; /etc/docker/daemon.json</code></pre><h4 id="修改配置后需要使用如下命令使配置生效"><a href="#修改配置后需要使用如下命令使配置生效" class="headerlink" title="修改配置后需要使用如下命令使配置生效"></a>修改配置后需要使用如下命令使配置生效</h4><pre><code class="hljs shell">systemctl daemon-reload</code></pre><h4 id="重新启动Docker服务"><a href="#重新启动Docker服务" class="headerlink" title="重新启动Docker服务"></a>重新启动Docker服务</h4><pre><code class="hljs shell">systemctl stop dockersystemctl start docker</code></pre><h4 id="开启防火墙的Docker构建端口"><a href="#开启防火墙的Docker构建端口" class="headerlink" title="开启防火墙的Docker构建端口"></a>开启防火墙的Docker构建端口</h4><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=2375/tcp --permanentfirewall-cmd --reload</code></pre><h2 id="使用Maven构建Docker镜像"><a href="#使用Maven构建Docker镜像" class="headerlink" title="使用Maven构建Docker镜像"></a>使用Maven构建Docker镜像</h2><h3 id="在pom-xml文件中添加docker-maven-plugin的依赖"><a href="#在pom-xml文件中添加docker-maven-plugin的依赖" class="headerlink" title="在pom.xml文件中添加docker-maven-plugin的依赖"></a>在pom.xml文件中添加docker-maven-plugin的依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>wangmh/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://xxx.xxx.xxx.xxx:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">baseImage</span>&gt;</span>java:8<span class="hljs-tag">&lt;/<span class="hljs-name">baseImage</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entryPoint</span>&gt;</span>["java", "-jar","/$&#123;project.build.finalName&#125;.jar"]                <span class="hljs-tag">&lt;/<span class="hljs-name">entryPoint</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><p>相关配置说明：</p><ul><li>executions.execution.phase:此处配置了在maven打包应用时构建docker镜像；</li><li>imageName：用于指定镜像名称，mall-tiny是仓库名称，<code>${project.artifactId}</code>为镜像名称，<code>${project.version}</code>为仓库名称；</li><li>dockerHost：打包后上传到的docker服务器地址；</li><li>baseImage：该应用所依赖的基础镜像，此处为java；</li><li>entryPoint：docker容器启动时执行的命令；</li><li>resources.resource.targetPath：将打包后的资源文件复制到该目录；</li><li>resources.resource.directory：需要复制的文件所在目录，maven打包的应用jar包保存在target目录下面；</li><li>resources.resource.include：需要复制的文件，打包好的应用jar包。</li></ul><h3 id="maven命令构建并启动"><a href="#maven命令构建并启动" class="headerlink" title="maven命令构建并启动"></a>maven命令构建并启动</h3><pre><code class="hljs shell">mvn packagedocker run -d -p 8080:8080 --name test $&#123;容器名&#125;:$&#123;版本号&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-12</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Liunx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17 React脚手架之NextJs</title>
    <link href="/2020/11/12/39%20React%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BNextJs/"/>
    <url>/2020/11/12/39%20React%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BNextJs/</url>
    
    <content type="html"><![CDATA[<h4 id="1-Next-js简介"><a href="#1-Next-js简介" class="headerlink" title="1.Next.js简介"></a>1.Next.js简介</h4><blockquote><p>Next.js 是一个轻量级的 React 服务端渲染应用框架。</p></blockquote><p>它的优点：</p><ul><li>完善的React项目架构，搭建轻松。比如：Webpack配置，服务器启动，路由配置，缓存能力，这些在它内部已经完善的为我们搭建完成了。</li><li>自带数据同步策略，解决服务端渲染最大难点。把服务端渲染好的数据，拿到客户端重用，这个在没有框架的时候，是非常复杂和困难的。有了Next.js，它为我们提供了非常好的解决方法，让我们轻松的就可以实现这些步骤。</li><li>丰富的插件帮开发人员增加各种功能。每个项目的需求都是不一样的，包罗万象。无所不有，它为我们提供了插件机制，让我们可以在使用的时候按需使用。你也可以自己写一个插件，让别人来使用。</li><li>灵活的配置，让开发变的更简单。它提供很多灵活的配置项，可以根据项目要求的不同快速灵活的进行配置。</li></ul><h4 id="2-快速创建Next-js"><a href="#2-快速创建Next-js" class="headerlink" title="2.快速创建Next.js"></a>2.快速创建Next.js</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">全局安装</span>npm install -g create-next-app<span class="hljs-meta">#</span><span class="bash">npx创建项目</span>npx install create-next-app demo13cd demo13<span class="hljs-meta">#</span><span class="bash">本地运行</span>yarn dev</code></pre><h4 id="3-项目结构介绍"><a href="#3-项目结构介绍" class="headerlink" title="3.项目结构介绍"></a>3.项目结构介绍</h4><ul><li>components文件夹:这里是专门放置自己写的组件的，这里的组件不包括页面，指公用的或者有专门用途的组件。</li><li>node_modules文件夹：Next项目的所有依赖包都在这里，一般我们不会修改和编辑这里的内容。</li><li>pages文件夹：这里是放置页面的，这里边的内容会自动生成路由，并在服务器端渲染，渲染好后进行数据同步。</li><li>static文件夹： 这个是静态文件夹，比如项目需要的图片、图标和静态资源都可以放到这里。</li><li>.gitignore文件： 这个主要是控制git提交和上传文件的，简称就是忽略提交。</li><li>package.json文件：定义了项目所需要的文件和项目的配置信息（名称、版本和许可证），最主要的是使用<code>npm install</code> 就可以下载项目所需要的所有包。</li></ul><h4 id="4-Page和Component使用"><a href="#4-Page和Component使用" class="headerlink" title="4.Page和Component使用"></a>4.Page和Component使用</h4><p>在pages文件下，创建Test.js。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span> Test page<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>  Test;</code></pre><p>写完以上的代码，<code>Next</code>框架就自动作好了路由，这个也算是Next的一个重要优点，给我们节省了大量的时间。</p><p>现在要作一个更深的页面，比如把有关博客的界面都放在这样的路径下<code>http://localhost:3000/blog/nextBlog</code>,其实只要在<code>pages</code>文件夹下再建立一个新的文件夹<code>blog</code>，然后进入<code>blog</code>文件夹，新建一个<code>nextBlog.js</code>文件，就可以实现了。</p><p>编写组件也特别方便，比如要建立一个comm组件，直接在<code>components</code>目录下建立一个文件comm,然后写入下面代码:</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (&#123;children&#125;)=&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></code></pre><p>组件写完后需要先引入，比如我们在Index页面里进行引入：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> comm <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/comm'</span></code></pre><p>使用就非常简单了，直接写入标签就可以。</p><pre><code class="hljs js">&lt;comm&gt;按钮&lt;<span class="hljs-regexp">/comm&gt;</span></code></pre><h4 id="5-路由基础及跳转"><a href="#5-路由基础及跳转" class="headerlink" title="5.路由基础及跳转"></a>5.路由基础及跳转</h4><h5 id="5-1-标签是导航"><a href="#5-1-标签是导航" class="headerlink" title="5.1 标签是导航"></a>5.1 标签是导航<Link></h5><p>首先先删除index.js中的代码，引入以下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span></code></pre><p>然后新建两个页面<code>testA.js</code>和<code>testB.js</code></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;(    &lt;&gt;        &lt;div&gt;TestA page .  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;Link href="/</span><span class="hljs-string">"&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><span class="hljs-string">    &lt;/&gt;</span><span class="hljs-string">)</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;(    &lt;&gt;        &lt;div&gt;TestB page .  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;Link href="/</span><span class="hljs-string">"&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><span class="hljs-string">    &lt;/&gt;</span><span class="hljs-string">)</span></code></pre><p>然后编写index文件</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (  &lt;&gt;    &lt;div&gt;我是首页&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;div&gt;&lt;Link href="/</span>testA<span class="hljs-string">"&gt;&lt;a&gt;去testA页面&lt;/a&gt;&lt;/Link&gt;&lt;/div&gt;</span><span class="hljs-string">    &lt;div&gt;&lt;Link href="</span>/testB<span class="hljs-string">"&gt;&lt;a&gt;去testB页面&lt;/a&gt;&lt;/Link&gt;&lt;/div&gt;</span><span class="hljs-string"></span><span class="hljs-string">  &lt;/&gt;</span><span class="hljs-string">)</span><span class="hljs-string"></span><span class="hljs-string">export default Home</span></code></pre><p><strong>注意</strong>：<Link>不支持兄弟并列标签。</p><h5 id="5-2-Router模块跳转"><a href="#5-2-Router模块跳转" class="headerlink" title="5.2 Router模块跳转"></a>5.2 Router模块跳转</h5><p>在index.js中，添加以下：</p><pre><code class="hljs js">&lt;div&gt;   &lt;button onClick=&#123;()=&gt;&#123;Router.push(<span class="hljs-string">'/testA'</span>)&#125;&#125;&gt;去testA页面&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp"> &lt;/</span>div&gt;</code></pre><h4 id="6-路由跳转传值和接收参数"><a href="#6-路由跳转传值和接收参数" class="headerlink" title="6.路由跳转传值和接收参数"></a>6.路由跳转传值和接收参数</h4><h5 id="6-1-query传递参数及接收"><a href="#6-1-query传递参数及接收" class="headerlink" title="6.1 query传递参数及接收"></a>6.1 query传递参数及接收</h5><pre><code class="hljs js">&lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/testA?name=karma"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Link跳转去testA页面<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/或</span><span class="hljs-regexp">&lt;div&gt;&lt;Link href=&#123;&#123;pathname: '/</span>testA<span class="hljs-string">', query: &#123;name: '</span>karma<span class="hljs-string">'&#125;&#125;&#125;&gt;&lt;a&gt;Link跳转去testA页面&lt;/a&gt;&lt;/Link&gt;&lt;/div&gt;</span></code></pre><p>然后在testA.js文件中接收该参数：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span><span class="hljs-keyword">import</span> &#123;withRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"next/router"</span>;<span class="hljs-keyword">const</span> testA = <span class="hljs-function">(<span class="hljs-params">&#123;router&#125;</span>) =&gt;</span> (    &lt;&gt;        &lt;div&gt;testA page . &#123;router.query.name&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;Link href="/</span><span class="hljs-string">"&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><span class="hljs-string">    &lt;/&gt;</span><span class="hljs-string">)</span><span class="hljs-string">//withRouter是Next.js框架的高级组件，用来处理路由用的</span><span class="hljs-string">export default withRouter(testA)</span></code></pre><h5 id="6-2-Router编程式传递参数"><a href="#6-2-Router编程式传递参数" class="headerlink" title="6.2 Router编程式传递参数"></a>6.2 Router编程式传递参数</h5><pre><code class="hljs js">&lt;button onClick=&#123;()=&gt;&#123;Router.push(<span class="hljs-string">'/testA?name=karma'</span>)&#125;&#125;&gt;去testA页面&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">#或者</span><span class="hljs-regexp">&lt;button onClick=&#123;()=&gt;&#123;Router.push(&#123;</span><span class="hljs-regexp">      pathname:'/</span>testA<span class="hljs-string">',</span><span class="hljs-string">      query:&#123;</span><span class="hljs-string">        name:'</span>karma<span class="hljs-string">'</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;)&#125;&gt;去testA页面&lt;/button&gt;</span></code></pre><h4 id="7-路由-六个钩子事件"><a href="#7-路由-六个钩子事件" class="headerlink" title="7.路由-六个钩子事件"></a>7.路由-六个钩子事件</h4><h5 id="routerChangeStart路由发生变化"><a href="#routerChangeStart路由发生变化" class="headerlink" title="routerChangeStart路由发生变化"></a><code>routerChangeStart</code>路由发生变化</h5><pre><code class="hljs js"> Router.events.on(<span class="hljs-string">'routeChangeStart'</span>,(...args)=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1.routeChangeStart-&gt;路由开始变化,参数为:'</span>,...args)&#125;)</code></pre><h5 id="routerChangeComplete路由结束变化时"><a href="#routerChangeComplete路由结束变化时" class="headerlink" title="routerChangeComplete路由结束变化时"></a><code>routerChangeComplete</code>路由结束变化时</h5><pre><code class="hljs js">Router.events.on(<span class="hljs-string">'routeChangeComplete'</span>,(...args)=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'routeChangeComplete-&gt;路由结束变化,参数为:'</span>,...args)&#125;)</code></pre><h5 id="beforeHistoryChange浏览器history触发前"><a href="#beforeHistoryChange浏览器history触发前" class="headerlink" title="beforeHistoryChange浏览器history触发前"></a><code>beforeHistoryChange</code>浏览器history触发前</h5><pre><code class="hljs js">Router.events.on(<span class="hljs-string">'beforeHistoryChange'</span>,(...args)=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'3,beforeHistoryChange-&gt;在改变浏览器 history之前触发,参数为:'</span>,...args)&#125;)</code></pre><h5 id="routeChangeError路由跳转发生错误时"><a href="#routeChangeError路由跳转发生错误时" class="headerlink" title="routeChangeError路由跳转发生错误时"></a><code>routeChangeError</code>路由跳转发生错误时</h5><pre><code class="hljs js">Router.events.on(<span class="hljs-string">'routeChangeError'</span>,(...args)=&gt;&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'4,routeChangeError-&gt;跳转发生错误,参数为:'</span>,...args) &#125;)</code></pre><p>需要注意的是404找不到路由页面不算错误。</p><h5 id="转变成hash路由模式"><a href="#转变成hash路由模式" class="headerlink" title="转变成hash路由模式"></a>转变成hash路由模式</h5><p>还有两种事件，都是针对hash的，所以现在要转变成hash模式。hash模式下的两个事件<code>hashChangeStart</code>和`hashChangeComplete。</p><pre><code class="hljs js">Router.events.on(<span class="hljs-string">'hashChangeStart'</span>,(...args)=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'5,hashChangeStart-&gt;hash跳转开始时执行,参数为:'</span>,...args)&#125;)Router.events.on(<span class="hljs-string">'hashChangeComplete'</span>,(...args)=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'6,hashChangeComplete-&gt;hash跳转完成时,参数为:'</span>,...args)&#125;)</code></pre><p>在下面的jsx语法部分，再增加一个链接,使用hash来进行跳转，代码如下：</p><pre><code class="hljs js">&lt;div&gt;    &lt;Link href=<span class="hljs-string">"#test"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;<span class="hljs-regexp">/Link&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;</code></pre><h4 id="8-在getInitialProps中使用Axios获取远端数据"><a href="#8-在getInitialProps中使用Axios获取远端数据" class="headerlink" title="8.在getInitialProps中使用Axios获取远端数据"></a>8.在getInitialProps中使用Axios获取远端数据</h4><p>在<code>Next.js</code>框架中提供了<code>getInitialProps</code>静态方法用来获取远端数据，这个是框架的约定，所以你也只能在这个方法里获取远端数据。</p><p>安装Axios：</p><pre><code class="hljs shell">yarn add axios</code></pre><p>在testA.js中引入Axios</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span></code></pre><p>然后使用getInitialProps获取远程数据并渲染页面</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span><span class="hljs-keyword">import</span> &#123;withRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"next/router"</span>;<span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<span class="hljs-keyword">const</span> testA = <span class="hljs-function">(<span class="hljs-params">&#123;router, list&#125;</span>) =&gt;</span> (    &lt;&gt;        &lt;div&gt;testA page . &#123;router.query.name&#125; &#123;list&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;Link href="/</span><span class="hljs-string">"&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><span class="hljs-string">    &lt;/&gt;</span><span class="hljs-string">)</span><span class="hljs-string">testA.getInitialProps = async () =&gt; &#123;</span><span class="hljs-string">    const promise = new Promise((resolve =&gt; &#123;</span><span class="hljs-string">        Axios('https://www.easy-mock.com/mock/5f96cc6134c55d14fda96ea1/example/query').then((res) =&gt; &#123;</span><span class="hljs-string">            console.log('远程数据结果：', res)</span><span class="hljs-string">            resolve(res.data.data)</span><span class="hljs-string">        &#125;)</span><span class="hljs-string"></span><span class="hljs-string">    &#125;))</span><span class="hljs-string">    return await promise</span><span class="hljs-string">&#125;</span><span class="hljs-string">//withRouter是Next.js框架的高级组件，用来处理路由用的</span><span class="hljs-string">export default withRouter(testA)</span></code></pre><h4 id="9-使用style-JSX编写页面的css样式"><a href="#9-使用style-JSX编写页面的css样式" class="headerlink" title="9.使用style JSX编写页面的css样式"></a>9.使用style JSX编写页面的css样式</h4><p>在pages文件下，创建testC.js.</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testC</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;testC&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;style jsx&gt;</span><span class="hljs-regexp">          &#123;`</span><span class="hljs-regexp">              div&#123;color:blue;&#125;</span><span class="hljs-regexp">          `&#125;</span><span class="hljs-regexp">  &lt;/</span>style&gt;        &lt;<span class="hljs-regexp">/&gt;</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default testC</span></code></pre><p>通过自定义类名加载css</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testC</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;testC&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">       &lt;div className="karma"&gt;karma&lt;/</span>div&gt;        &lt;style jsx&gt;              &#123;<span class="hljs-string">`</span><span class="hljs-string">                  div&#123;color:blue;&#125;,</span><span class="hljs-string">.karma&#123;color:red&#125;</span><span class="hljs-string">              `</span>&#125;  &lt;<span class="hljs-regexp">/style&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> testC</code></pre><p>动态显示样式</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testC</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> [color, setColor] = useState(<span class="hljs-string">'blue'</span>)    <span class="hljs-keyword">const</span> changeColor = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        setColor(color === <span class="hljs-string">'blue'</span> ? <span class="hljs-string">'red'</span> : <span class="hljs-string">'blue'</span>)    &#125;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;testC&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;</span><span class="hljs-regexp">                &lt;button onClick=&#123;changeColor&#125;&gt;改变颜色&lt;/</span>button&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div className="karma"&gt;karma&lt;/</span>div&gt;            &#123;<span class="hljs-comment">/*Style JSX语法*/</span>&#125;            &lt;style jsx&gt;                &#123;<span class="hljs-string">`</span><span class="hljs-string">                    div&#123;color:<span class="hljs-subst">$&#123;color&#125;</span>;&#125;,</span><span class="hljs-string">                `</span>&#125;            &lt;<span class="hljs-regexp">/style&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> testC</code></pre><h4 id="10-Lazy-Loading-实现模块懒加载"><a href="#10-Lazy-Loading-实现模块懒加载" class="headerlink" title="10.Lazy Loading 实现模块懒加载"></a>10.Lazy Loading 实现模块懒加载</h4><h5 id="懒加载模块"><a href="#懒加载模块" class="headerlink" title="懒加载模块"></a>懒加载模块</h5><p>安装moment</p><pre><code class="hljs shell">yarn add moment</code></pre><p>然后在<code>pages</code>文件夹下，新建立一个<code>time.js</code>文件，并使用刚才的<code>moment</code>库来格式化时间，代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Time</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [nowTime,setTime] = useState(<span class="hljs-built_in">Date</span>.now())    <span class="hljs-keyword">const</span> changeTime=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        setTime(moment(<span class="hljs-built_in">Date</span>.now()).format())    &#125;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;&lt;button onClick=&#123;changeTime&#125;&gt;改变时间格式&lt;/</span>button&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Time</code></pre><p>这个案例，存在着一个潜在的风险，就是如何有半数以上页面使用了这个<code>momnet</code>的库，那它就会以公共库的形式进行打包发布，就算项目第一个页面不使用<code>moment</code>也会进行加载，这就是资源浪费，对于我这样有代码洁癖的良好程序员是绝对不允许的。下面我们就通过<code>Lazy Loading</code>来进行改造代码。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-comment">//删除import moment</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Time</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [nowTime,setTime] = useState(<span class="hljs-built_in">Date</span>.now())    <span class="hljs-keyword">const</span> changeTime= <span class="hljs-keyword">async</span> ()=&gt;&#123; <span class="hljs-comment">//把方法变成异步模式</span>        <span class="hljs-keyword">const</span> moment = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'moment'</span>) <span class="hljs-comment">//等待moment加载完成</span>        setTime(moment.default(<span class="hljs-built_in">Date</span>.now()).format()) <span class="hljs-comment">//注意使用defalut</span>    &#125;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;&lt;button onClick=&#123;changeTime&#125;&gt;改变时间格式&lt;/</span>button&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Time</code></pre><h5 id="懒加载自定义组件"><a href="#懒加载自定义组件" class="headerlink" title="懒加载自定义组件"></a>懒加载自定义组件</h5><p>先写一个最简单的组件，在<code>components</code>文件夹下建立一个<code>one.js</code>文件，然后编写如下代码：</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Lazy Loading Component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>有了自定义组件后，先要在懒加载这个组件的文件中引入<code>dynamic</code>,我们这个就在上边新建的<code>time.js</code>文件中编写了。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">'next/dynamic'</span></code></pre><p>引入后就可以懒加载自定义模块了，代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">'next/dynamic'</span><span class="hljs-keyword">const</span> One = dynamic(<span class="hljs-keyword">import</span>(<span class="hljs-string">'../components/one'</span>))<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Time</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [nowTime,setTime] = useState(<span class="hljs-built_in">Date</span>.now())    <span class="hljs-keyword">const</span> changeTime= <span class="hljs-keyword">async</span> ()=&gt;&#123;        <span class="hljs-keyword">const</span> moment = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'moment'</span>)        setTime(moment.default(<span class="hljs-built_in">Date</span>.now()).format())    &#125;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;One/</span>&gt;            &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;changeTime&#125;</span>&gt;</span>改变时间格式<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Time</code></pre><h4 id="11-自定义Head更加友好的SEO操作"><a href="#11-自定义Head更加友好的SEO操作" class="headerlink" title="11.自定义Head更加友好的SEO操作"></a>11.自定义Head更加友好的SEO操作</h4><p>一般有两种方式。</p><h5 id="方法1：在各页面加上标签"><a href="#方法1：在各页面加上标签" class="headerlink" title="方法1：在各页面加上标签"></a>方法1：在各页面加上<Head>标签</h5><p>先在<code>/pages</code>文件夹下面建立一个<code>header.js</code>文件，然后写一个最简单的<code>Hooks</code>页面，代码如下:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>JSPang.com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Header</code></pre><p>写完后到浏览器中预览一下，可以发现title部分并没有任何内容，显示的是<code>localhost:3000/header</code>,接下来就自定义下<code>&lt;Head&gt;</code>。自定义需要先进行引入<code>next/head</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">'next/head'</span></code></pre><p>引入后你就可以写一些列的头部标签了，全部代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">'next/head'</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;Head&gt;                &lt;title&gt;Header&lt;<span class="hljs-regexp">/title&gt;</span><span class="hljs-regexp">                &lt;meta charSet='utf-8' /</span>&gt;            &lt;<span class="hljs-regexp">/Head&gt;</span><span class="hljs-regexp">            &lt;div&gt;Karma520.com&lt;/</span>div&gt;        &lt;<span class="hljs-regexp">/&gt; </span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default Header</span></code></pre><p>这时候再打开浏览器预览，你发现已经有了<code>title</code>。</p><h5 id="方法2：全局定义"><a href="#方法2：全局定义" class="headerlink" title="方法2：全局定义"></a>方法2：全局定义</h5><p>比如在<code>components</code>文件夹下面新建立一个<code>myheader.js</code>,然后写入下面的代码:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">'next/head'</span><span class="hljs-keyword">const</span> MyHeader = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;Head&gt;                &lt;title&gt; Karma520.com &lt;<span class="hljs-regexp">/title&gt;   </span><span class="hljs-regexp">            &lt;/</span>Head&gt;        &lt;<span class="hljs-regexp">/&gt;</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default MyHeader</span></code></pre><p>把刚才编写的<code>header.js</code>页面改写一下，引入自定义的<code>myheader</code>，在页面里进行使用。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Myheader <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/myheader'</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;Myheader /&gt;            &lt;div&gt;Karma520.com&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">        &lt;/</span>&gt;     )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Header</code></pre><h4 id="12-Next-js脚手架中使用Ant-Design-UI"><a href="#12-Next-js脚手架中使用Ant-Design-UI" class="headerlink" title="12.Next.js脚手架中使用Ant Design UI"></a>12.Next.js脚手架中使用Ant Design UI</h4><p><code>Next.js</code>默认是不支持CSS文件的，它用的是<code>style jsx</code>，也就是说它是不支持直接用<code>import</code>进行引入<code>css</code>的。</p><p>在static下新建一个<code>test.css</code>文件，写入一些<code>CSS Style</code>。</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;    <span class="hljs-attribute">color</span>:green;&#125;</code></pre><p>然后用<code>import</code>在<code>header.js</code>里引入。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'../static/test.css'</span></code></pre><p>写完到浏览器中进行预览，没有任何输出结果而且报错了。这说明<code>Next.js</code>默认是不支持CSS样式引入的，要进行一些必要的设置，才可以完成。</p><p><strong>开始进行配置，让Next.js支持CSS文件</strong></p><p>先用<code>yarn</code>命令来安装<code>@zeit/next-css</code>包，它的主要功能就是让<code>Next.js</code>可以加载CSS文件。</p><pre><code class="hljs shell">yarn add @zeit/next-css</code></pre><p>包安装好以后就可以进行配置文件的编写了，建立一个<code>next.config.js</code>.这个就是<code>Next.js</code>的总配置文件（如果感兴趣可以自学一下）。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> withCss = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@zeit/next-css'</span>)<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">'undefined'</span>)&#123;    <span class="hljs-built_in">require</span>.extensions[<span class="hljs-string">'.css'</span>]=<span class="hljs-function"><span class="hljs-params">file</span>=&gt;</span>&#123;&#125;&#125;<span class="hljs-built_in">module</span>.exports = withCss(&#123;&#125;)</code></pre><p>重启服务可以让配置生效，这时候你到浏览器中可以发现CSS文件已经生效了，字变成了绿色。</p><h5 id="按需加载Ant-Design"><a href="#按需加载Ant-Design" class="headerlink" title="按需加载Ant Design"></a>按需加载<code>Ant Design</code></h5><p>加载<code>Ant Design</code>在我们打包的时候会把<code>Ant Design</code>的所有包都打包进来，这样就会产生性能问题，让项目加载变的非常慢。</p><p>** 先来安装<code>Ant Design</code>库 **</p><p>直接使用yarn来安装就可以。</p><pre><code class="hljs shell">yarn add antd</code></pre><p>** 安装和配置<code>babel-plugin-import</code> 插件 **</p><pre><code class="hljs shell">yarn add babel-plugin-import</code></pre><p>然后在项目根目录建立<code>.babelrc</code>文件，然后写入如下配置文件。</p><pre><code class="hljs js">&#123;    <span class="hljs-string">"presets"</span>:[<span class="hljs-string">"next/babel"</span>],  <span class="hljs-comment">//Next.js的总配置文件，相当于继承了它本身的所有配置</span>    <span class="hljs-string">"plugins"</span>:[     <span class="hljs-comment">//增加新的插件，这个插件就是让antd可以按需引入，包括CSS</span>        [            <span class="hljs-string">"import"</span>,            &#123;                <span class="hljs-string">"libraryName"</span>:<span class="hljs-string">"antd"</span>,                <span class="hljs-string">"style"</span>:<span class="hljs-string">"css"</span>            &#125;        ]    ]&#125;</code></pre><p>配置好了以后，<code>webpack</code>就不会默认把整个<code>Ant Design</code>的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。</p><p>然后在header.js里，引入<code>&lt;Button&gt;</code>组件，并进行使用。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Myheader <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/myheader'</span><span class="hljs-keyword">import</span> &#123;Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'../static/test.css'</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;Myheader /&gt;            &lt;div&gt;Karma520.com&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;&lt;Button&gt;按钮&lt;/</span>Button&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">        &lt;/</span>&gt;     )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Header</code></pre><p>运行，看效果。</p><h4 id="13-Next打包CSS问题"><a href="#13-Next打包CSS问题" class="headerlink" title="13.Next打包CSS问题"></a>13.Next打包CSS问题</h4><blockquote><p>打包 ：yarn build</p></blockquote><p>然后在终端里运行一下<code>yarn build</code>，如果这时候报错，其实是我们在加入<code>Ant Design</code>的样式时产生的，这个已经在<code>Ant Design</code>的Github上被提出了，但目前还没有被修改，你可以改完全局引入CSS解决问题。</p><p>在page目录下，修改<code>_app.js</code>文件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'next/app'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App</code></pre><p>并且注释.babelrc中该行配置  “style”:”css”，然后执行命令。</p><p>源码地址：<a href="https://github.com/kay-520/React_study/tree/master/demo13" target="_blank" rel="noopener">传送门</a> </p>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16 React.js之React Hooks使用</title>
    <link href="/2020/11/12/38%20React.js%E4%B9%8BReact%20Hooks%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/12/38%20React.js%E4%B9%8BReact%20Hooks%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong><em>仅供个人学习使用，源码请见文件末尾</em></strong></p><h4 id="1-React-Hooks简介"><a href="#1-React-Hooks简介" class="headerlink" title="1.React Hooks简介"></a>1.React Hooks简介</h4><blockquote><p><code>React Hooks</code>就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理<code>state</code>，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p></blockquote><h4 id="2-useState多状态声明"><a href="#2-useState多状态声明" class="headerlink" title="2.useState多状态声明"></a>2.useState多状态声明</h4><blockquote><p><code>useState</code>是react自带的一个hook函数，它的作用是用来声明状态变量。</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [ count , setCount ] = useState(<span class="hljs-number">0</span>);</code></pre><p><code>useState</code>这个函数接收的参数是状态的初始值(Initial state)，它返回一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变<code>count</code>的状态值的方法函数。</p><p>接下来如何读取状态中的值</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>最后改变<code>State</code>中的值</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><p>直接调用setCount函数，这个函数接收的参数是修改过的新状态值。</p><p>注意：<strong>React是根据useState出现的顺序来确定的</strong></p><h4 id="3-useEffect代替生命周期函数"><a href="#3-useEffect代替生命周期函数" class="headerlink" title="3.useEffect代替生命周期函数"></a>3.useEffect代替生命周期函数</h4><blockquote><p>使用useEffect代替两个生命周期函数<code>componentDidMount</code>和<code>componentDidUpdate</code>。</p></blockquote><p>案例如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState , useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [ count , setCount ] = useState(<span class="hljs-number">0</span>);    <span class="hljs-comment">//---关键代码---------start-------</span>    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`useEffect=&gt;You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>)    &#125;)    <span class="hljs-comment">//---关键代码---------end-------</span>    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;        &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default Example;</span></code></pre><p>useEffect需注意事项：</p><blockquote><ol><li>React首次渲染和之后的每次渲染都会调用一遍<code>useEffect</code>函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</li><li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而<code>componentDidMonut</code>和<code>componentDidUpdate</code>中的代码都是同步执行的。</li></ol></blockquote><h4 id="4-useEffect实现componentWillUnmount生命周期函数"><a href="#4-useEffect实现componentWillUnmount生命周期函数" class="headerlink" title="4.useEffect实现componentWillUnmount生命周期函数"></a>4.useEffect实现componentWillUnmount生命周期函数</h4><blockquote><p>componentWillUnmount生命周期函数：组件将要被卸载时执行.</p></blockquote><h5 id="useEffect解绑副作用"><a href="#useEffect解绑副作用" class="headerlink" title="useEffect解绑副作用"></a>useEffect解绑副作用</h5><p>学习<code>React Hooks</code> 时，要改掉生命周期函数的概念，因为<code>Hooks</code>叫它副作用，所以<code>componentWillUnmount</code>也可以理解成解绑副作用。这里用<code>useEffect</code>来实现类似<code>componentWillUnmount</code>效果，先安装<code>React-Router</code>路由,进入项目根本录，使用<code>npm</code>进行安装。</p><pre><code class="hljs shell">npm install --save react-router-dom</code></pre><p>然后打开<code>Example.js</code>文件，进行改写代码，先引入对应的<code>React-Router</code>组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span></code></pre><p>在文件中编写两个新组件，因为这两个组件都非常的简单，所以就不单独建立一个新的文件来写了。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Index Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>List-Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;&#125;</code></pre><p>有了这两个组件后，接下来可以编写路由配置，在以前的计数器代码中直接增加就可以了。</p><pre><code class="hljs js"><span class="hljs-keyword">return</span> (    &lt;div&gt;        &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">        &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;        &lt;Router&gt;            &lt;ul&gt;                &lt;li&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span> &lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                &lt;li&gt;&lt;Link to="/</span>list/<span class="hljs-string">"&gt;列表&lt;/Link&gt; &lt;/li&gt;</span><span class="hljs-string">            &lt;/ul&gt;</span><span class="hljs-string">            &lt;Route path="</span>/<span class="hljs-string">" exact component=&#123;Index&#125; /&gt;</span><span class="hljs-string">            &lt;Route path="</span>/list/<span class="hljs-string">" component=&#123;List&#125; /&gt;</span><span class="hljs-string">        &lt;/Router&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">)</span></code></pre><p>然后到浏览器中查看一下，看看组件和路由是否可用。如果可用，我们现在可以调整<code>useEffect</code>了。在两个新组件中分别加入<code>useEffect()</code>函数:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>&#123;    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'useEffect=&gt;老弟，你来了！Index页面'</span>)        )    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Index page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params"></span>) </span>&#123;    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'useEffect=&gt;老弟，你来了！List页面'</span>)    &#125;)    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>List-Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;&#125;</code></pre><p>这时候我们点击<code>Link</code>进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用<strong>返回一个函数的形式进行解绑</strong>，代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>&#123;    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'useEffect=&gt;老弟你来了！Index页面'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'老弟，你走了!Index页面'</span>)        &#125;    &#125;)    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>JSPang.com<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;  &#125;</code></pre><p>这时候你在浏览器中预览，我们仿佛实现了<code>componentWillUnmount</code>方法。但这只是好像实现了，当点击计数器按钮时，你会发现<code>老弟，你走了!Index页面</code>，也出现了。这到底是怎么回事呐？其实每次状态发生变化，<code>useEffect</code>都进行了解绑。</p><h5 id="useEffect的第二个参数"><a href="#useEffect的第二个参数" class="headerlink" title="useEffect的第二个参数"></a>useEffect的第二个参数</h5><p>如何实现类似<code>componentWillUnmount</code>的效果那?这就需要请出<code>useEffect</code>的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组<code>[]</code>时，就是当组件将被销毁时才进行解绑，这也就实现了<code>componentWillUnmount</code>的生命周期函数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>&#123;    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'useEffect=&gt;老弟你来了！Index页面'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'老弟，你走了!Index页面'</span>)        &#125;    &#125;,[])    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Index Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;&#125;</code></pre><p>为了更加深入了解第二个参数的作用，把计数器的代码也加上<code>useEffect</code>和解绑方法，并加入第二个参数为空数组。代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [ count , setCount ] = useState(<span class="hljs-number">0</span>);    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`useEffect=&gt;You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'===================='</span>)        &#125;    &#125;,[])    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;            &lt;Router&gt;                &lt;ul&gt;                    &lt;li&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span> &lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                    &lt;li&gt;&lt;Link to="/</span>list/<span class="hljs-string">"&gt;列表&lt;/Link&gt; &lt;/li&gt;</span><span class="hljs-string">                &lt;/ul&gt;</span><span class="hljs-string">                &lt;Route path="</span>/<span class="hljs-string">" exact component=&#123;Index&#125; /&gt;</span><span class="hljs-string">                &lt;Route path="</span>/list/<span class="hljs-string">" component=&#123;List&#125; /&gt;</span><span class="hljs-string">            &lt;/Router&gt;</span><span class="hljs-string">        &lt;/div&gt;</span><span class="hljs-string">    )</span><span class="hljs-string">&#125;</span></code></pre><p>这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次<code>count</code>发生变化，我们都进行解绑，只需要在第二个参数的数组里加入<code>count</code>变量就可以了。代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [ count , setCount ] = useState(<span class="hljs-number">0</span>);    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`useEffect=&gt;You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'===================='</span>)        &#125;    &#125;,[count])    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;            &lt;Router&gt;                &lt;ul&gt;                    &lt;li&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span> &lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                    &lt;li&gt;&lt;Link to="/</span>list/<span class="hljs-string">"&gt;列表&lt;/Link&gt; &lt;/li&gt;</span><span class="hljs-string">                &lt;/ul&gt;</span><span class="hljs-string">                &lt;Route path="</span>/<span class="hljs-string">" exact component=&#123;Index&#125; /&gt;</span><span class="hljs-string">                &lt;Route path="</span>/list/<span class="hljs-string">" component=&#123;List&#125; /&gt;</span><span class="hljs-string">            &lt;/Router&gt;</span><span class="hljs-string">        &lt;/div&gt;</span><span class="hljs-string">    )</span><span class="hljs-string">&#125;</span></code></pre><p>这时候只要<code>count</code>状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串<code>=================</code>。</p><h4 id="5-useContext父子组件传值"><a href="#5-useContext父子组件传值" class="headerlink" title="5.useContext父子组件传值"></a>5.useContext父子组件传值</h4><p>在用类声明组件时，父子组件的传值是通过组件属性和<code>props</code>进行的，那现在使用方法(Function)来声明组件，已经没有了<code>constructor</code>构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。<code>React Hooks</code> 为我们准备了<code>useContext</code>。<code>useContext</code>它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是<code>useContext</code>和<code>redux</code>的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和<code>useReducer</code>的配合使用，可以实现类似<code>Redux</code>的作用。</p><blockquote><p><code>Context</code>的作用就是对它所包含的组件树提供全局共享数据的一种技术。</p></blockquote><h5 id="createContext函数创建context"><a href="#createContext函数创建context" class="headerlink" title="createContext函数创建context"></a>createContext函数创建context</h5><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState , createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-comment">//===关键代码</span><span class="hljs-keyword">const</span> CountContext = createContext()<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example4</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [ count , setCount ] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;            &#123;<span class="hljs-comment">/*======关键代码 */</span>&#125;            &lt;CountContext.Provider value=&#123;count&#125;&gt;            &lt;<span class="hljs-regexp">/CountContext.Provider&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">        &lt;/</span>div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Example4;</code></pre><h5 id="useContext接收上下文变量"><a href="#useContext接收上下文变量" class="headerlink" title="useContext接收上下文变量"></a>useContext接收上下文变量</h5><p>已经有了上下文变量，剩下的就是如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入<code>useContext</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState , createContext , useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre><p>引入后写一个<code>Counter</code>组件，只是显示上下文中的<code>count</code>变量代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> count = useContext(CountContext)  <span class="hljs-comment">//一句话就可以得到count</span>    <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)&#125;</code></pre><p>得到后就可以显示出来了，但是要记得在<code>&lt;CountContext.Provider&gt;</code>的闭合标签中,代码如下。</p><pre><code class="hljs js">&lt;CountContext.Provider value=&#123;count&#125;&gt;    &lt;Counter /&gt;&lt;<span class="hljs-regexp">/CountContext.Provider&gt;</span></code></pre><h4 id="6-useReducer的使用"><a href="#6-useReducer的使用" class="headerlink" title="6.useReducer的使用"></a>6.useReducer的使用</h4><blockquote><p><code>reducer</code>是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。</p></blockquote><p>新建一个js文件，然后用useReducer实现计数器的加减双向操作。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReducerDemo</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [ count , dispatch ] =useReducer(<span class="hljs-function">(<span class="hljs-params">state,action</span>)=&gt;</span>&#123;        <span class="hljs-keyword">switch</span>(action)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">'add'</span>:                <span class="hljs-keyword">return</span> state+<span class="hljs-number">1</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">'sub'</span>:                <span class="hljs-keyword">return</span> state<span class="hljs-number">-1</span>            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> state        &#125;    &#125;,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> (       &lt;div&gt;           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;<span class="hljs-regexp">/h2&gt;</span><span class="hljs-regexp">           &lt;button onClick=&#123;()=&gt;dispatch('add')&#125;&gt;Increment&lt;/</span>button&gt;           &lt;button onClick=&#123;()=&gt;dispatch(<span class="hljs-string">'sub'</span>)&#125;&gt;Decrement&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">       &lt;/</span>div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReducerDemo</code></pre><h4 id="7-useMemo优化性能"><a href="#7-useMemo优化性能" class="headerlink" title="7.useMemo优化性能"></a>7.useMemo优化性能</h4><p><code>useMemo</code>主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了<code>shouldCompnentUpdate</code>（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分<code>mount</code>和<code>update</code>两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。<code>useMemo</code>和<code>useCallback</code>都是解决上述性能问题的。<code>useCallback</code>，目的是为了缓存方法(useMemo是为了缓存变量)。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React , &#123;useState,useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example7</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [xiaohong , setXiaohong] = useState(<span class="hljs-string">'小红待客状态'</span>)    <span class="hljs-keyword">const</span> [zhiling , setZhiling] = useState(<span class="hljs-string">'志玲待客状态'</span>)    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;button onClick=&#123;()=&gt;&#123;setXiaohong(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime())&#125;&#125;&gt;小红&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">            &lt;button onClick=&#123;()=&gt;&#123;setZhiling(new Date().getTime()+',志玲向我们走来了')&#125;&#125;&gt;志玲&lt;/</span>button&gt;            &lt;ChildComponent name=&#123;xiaohong&#125;&gt;&#123;zhiling&#125;&lt;<span class="hljs-regexp">/ChildComponent&gt;</span><span class="hljs-regexp">        &lt;/</span>&gt;    )&#125;</code></pre><p>父组件调用了子组件，子组件我们输出两个姑娘的状态，显示在界面上。代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildComponent</span>(<span class="hljs-params">&#123;name,children&#125;</span>)</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeXiaohong</span>(<span class="hljs-params">name</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'她来了，她来了。小红向我们走来了'</span>)        <span class="hljs-keyword">return</span> name+<span class="hljs-string">',小红向我们走来了'</span>    &#125;    <span class="hljs-keyword">const</span> actionXiaohong = changeXiaohong(name)    <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;&#123;actionXiaohong&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;        &lt;<span class="hljs-regexp">/&gt;</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span></code></pre><p>其实只要使用<code>useMemo</code>，然后给她传递第二个参数，参数匹配成功，才会执行。代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildComponent</span>(<span class="hljs-params">&#123;name,children&#125;</span>)</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeXiaohong</span>(<span class="hljs-params">name</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'她来了，她来了。小红向我们走来了'</span>)        <span class="hljs-keyword">return</span> name+<span class="hljs-string">',小红向我们走来了'</span>    &#125;    <span class="hljs-keyword">const</span> actionXiaohong = useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>changeXiaohong(name),[name])     <span class="hljs-keyword">return</span> (        &lt;&gt;            &lt;div&gt;&#123;actionXiaohong&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;        &lt;<span class="hljs-regexp">/&gt;</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">&#125;</span></code></pre><h4 id="8-useRef获取DOM元素和变量"><a href="#8-useRef获取DOM元素和变量" class="headerlink" title="8.useRef获取DOM元素和变量"></a>8.useRef获取DOM元素和变量</h4><blockquote><p>两个主要的作用:</p><ul><li>用<code>useRef</code>获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来作，React界面的变化可以通过状态来控制。</li><li>用<code>useRef</code>来保存变量.</li></ul></blockquote><p>源码地址：<a href="https://github.com/kay-520/React_study/tree/master/demo12-React%20Hooks" target="_blank" rel="noopener">传送门</a> 参考src/index.js中注释</p>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15 React-router路由</title>
    <link href="/2020/11/04/37%20React-router%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/11/04/37%20React-router%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h4 id="1-React-router安装及环境搭建"><a href="#1-React-router安装及环境搭建" class="headerlink" title="1.React router安装及环境搭建"></a>1.React router安装及环境搭建</h4><pre><code class="hljs shell">cnpm install -g create-react-appcreate-react-app demo10cd demo10yarn start<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 安装React router</span></span>cnpm install --save react-router-dom</code></pre><h4 id="2-编写一个简单的路由程序"><a href="#2-编写一个简单的路由程序" class="headerlink" title="2.编写一个简单的路由程序"></a>2.编写一个简单的路由程序</h4><p>在src下创建一个AppRouter.js文件，然后写入以下代码。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<span class="hljs-comment">//引入Index和List组件，还未创建</span><span class="hljs-keyword">import</span> Index <span class="hljs-keyword">from</span> <span class="hljs-string">'./Pages/Index'</span><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">'./Pages/List'</span><span class="hljs-comment">//exact 精准匹配 </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AppRouter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;Router&gt;        &lt;ul&gt;            &lt;li&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span> &lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">            &lt;li&gt;&lt;Link to="/</span>list/<span class="hljs-string">"&gt;列表&lt;/Link&gt; &lt;/li&gt;</span><span class="hljs-string">        &lt;/ul&gt;</span><span class="hljs-string">        &lt;Route path="</span>/<span class="hljs-string">" exact component=&#123;Index&#125; /&gt;</span><span class="hljs-string">        &lt;Route path="</span>/list/<span class="hljs-string">" component=&#123;List&#125; /&gt;</span><span class="hljs-string">    &lt;/Router&gt;</span><span class="hljs-string">  );</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">export default AppRouter;</span></code></pre><p>然后创建src/Pages/Index.js 和 List.js。</p><pre><code class="hljs js">#Index.js<span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;  &#125;    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Index页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span> );    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index;</code></pre><pre><code class="hljs js">#List.js<span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;  &#125;    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>List页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span> );    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> List;</code></pre><h4 id="3-动态传值"><a href="#3-动态传值" class="headerlink" title="3.动态传值"></a>3.动态传值</h4><p>在Route上设置运行动态传值，设置是以<code>:</code>开始的，然后紧跟着你传递的key（键名称）名称。</p><pre><code class="hljs js">&lt;Route path=<span class="hljs-string">"/list/:id"</span> component=&#123;List&#125; /&gt;</code></pre><p>然后在Link上传递值。</p><pre><code class="hljs js">&lt;Link to=<span class="hljs-string">"/list/111"</span>&gt;列表&lt;<span class="hljs-regexp">/Link&gt;</span></code></pre><p>在List组件上接收并显示值。首先我们在List组件中，调用生命周期函数componentDidMount，如下：</p><pre><code class="hljs js"> componentDidMount()&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.props.match) &#125;#打印出的对象，对象包括三个部分:#patch:自己定义的路由规则，可以清楚的看到是可以产地id参数的。#url: 真实的访问路径，这上面可以清楚的看到传递过来的参数是什么。#params：传递过来的参数，key和value值。</code></pre><p>然后我们将拿到的值，渲染到页面。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;  &#125;    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>List页面-&gt;&#123;this.state.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span> );    &#125;    componentDidMount()&#123;        <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">id</span>:<span class="hljs-keyword">this</span>.props.match.params.id &#125;)    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> List;</code></pre><h4 id="4-重定向-Redirect使用"><a href="#4-重定向-Redirect使用" class="headerlink" title="4.重定向-Redirect使用"></a>4.重定向-Redirect使用</h4><h5 id="标签式重定向"><a href="#标签式重定向" class="headerlink" title="标签式重定向"></a>标签式重定向</h5><p>首先我们先在创建Home组件，并在AppRouter.js中加入Route配置，并引入Home组件。</p><pre><code class="hljs js">#Home.js<span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;  &#125;    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home 页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span> );    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Home;</code></pre><pre><code class="hljs js">#AppRouter<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./Pages/Home'</span>&lt;Route path=<span class="hljs-string">"/home/"</span> component=&#123;Home&#125; /&gt;</code></pre><p>然后在Index组件中，使用标签式重定向到Home组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; Link , Redirect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;&lt;Redirect to=<span class="hljs-string">"/home/"</span> /&gt;</code></pre><h5 id="编程式重定向"><a href="#编程式重定向" class="headerlink" title="编程式重定向"></a>编程式重定向</h5><pre><code class="hljs js">#在Index组件构造函数constructor中加入下面的重定向代码。<span class="hljs-keyword">this</span>.props.history.push(<span class="hljs-string">"/home/"</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2020/11/02/36%20git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/02/36%20git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Git全局设置 </p><p>git config –global user.name “karma” </p><p>git config –global user.email “<a href="mailto:wang732276349@163.com">wang732276349@163.com</a>“</p></blockquote><h4 id="1-常用git-命令"><a href="#1-常用git-命令" class="headerlink" title="1.常用git 命令"></a>1.常用git 命令</h4><pre><code class="hljs shell">git init // 初始化 在工作路径上创建主分支git clone 地址 // 克隆远程仓库git clone -b 分支名 地址 // 克隆分支的代码到本地git status // 查看状态git add 文件名 // 将某个文件存入暂存区git add b c //把b和c存入暂存区git add . // 将所有文件提交到暂存区git add -p 文件名 // 一个文件分多次提交git stash -u -k // 提交部分文件内容 到仓库 例如本地有3个文件 a b c 只想提交a b到远程仓库 git add a b 然后 git stash -u -k 再然后git commit -m "备注信息" 然后再push push之后 git stash pop 把之前放入堆栈的c拿出来 继续下一波操作git commit -m "提交的备注信息"  // 提交到仓库若已经有若干文件放入仓库，再次提交可以不用git add和git commit -m "备注信息" 这2步， 直接用git commit -am "备注信息" // 将内容放至仓库 也可用git commit -a -m "备注信息"* git commit中的备注信息尽量完善 养成良好提交习惯 例如 git commit -m "变更(范围)：变更的内容"</code></pre><h4 id="2-存储密码凭证-设置别名-获取config信息以及配置"><a href="#2-存储密码凭证-设置别名-获取config信息以及配置" class="headerlink" title="2.存储密码凭证 设置别名 获取config信息以及配置"></a>2.存储密码凭证 设置别名 获取config信息以及配置</h4><pre><code class="hljs shell">git config --list // 获取config信息git config --global core.safecrlf false // 去掉git add 命令后 出现的一堆CR LF提示信息其中CR是回车的意思 LF是换行git config --global credential.helper wincred // 存储凭证 (可用于输入一次用户密码后，不再输入 有时我们已经用SSH key 绑定关联好了 但是每次git提交的时候 还是需要你输入用户名密码 在这个时候 敲入这个命令 将凭证存储起来 用户名密码就不需要再次输入了)git config --global alias.ci commit // 将commit命令设置别名ci git commit命令将由git ci来代替</code></pre><h4 id="3-查看git常用命令"><a href="#3-查看git常用命令" class="headerlink" title="3.查看git常用命令"></a>3.查看git常用命令</h4><pre><code class="hljs shell">git helper -a // 查看全部git子命令</code></pre><h4 id="4-逐行查看文件的修改历史"><a href="#4-逐行查看文件的修改历史" class="headerlink" title="4.逐行查看文件的修改历史"></a>4.逐行查看文件的修改历史</h4><pre><code class="hljs shell">git blame 文件名 // 查看该文件的修改历史git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史</code></pre><h4 id="5-清除"><a href="#5-清除" class="headerlink" title="5.清除"></a>5.清除</h4><pre><code class="hljs shell">git clean -n // 列出打算清除的档案(首先会对工作区的内容进行提示)git clean -f // 真正的删除git clean -x -f // 连.gitignore中忽略的档案也删除git status -sb (sb是 short branch) // 简洁的输出git status中的信息</code></pre><h4 id="6-删除放入暂存区文件的方法（已commit后）"><a href="#6-删除放入暂存区文件的方法（已commit后）" class="headerlink" title="6.删除放入暂存区文件的方法（已commit后）"></a>6.删除放入暂存区文件的方法（已commit后）</h4><pre><code class="hljs shell">git rm 文件名 // 将该文件从commit后撤回到add后git reset HEAD^ --hard // 删除后 可以用git rm 文件名再回撤一步</code></pre><h4 id="7-修改文件名以及移动"><a href="#7-修改文件名以及移动" class="headerlink" title="7.修改文件名以及移动"></a>7.修改文件名以及移动</h4><pre><code class="hljs shell">git mv a b // 把a文件名字改成b 并且直接放入git add后的暂存区git mv b ./demos/ // 把b文件移动到demos文件夹下</code></pre><h4 id="8-对比工作区，暂存区，仓库的差异"><a href="#8-对比工作区，暂存区，仓库的差异" class="headerlink" title="8.对比工作区，暂存区，仓库的差异"></a>8.对比工作区，暂存区，仓库的差异</h4><pre><code class="hljs shell">git diff // 查看变更 工作区与暂存区的差异比对git diff --cached // 暂存区与提交版本的差异git diff HEAD // 工作区与仓库中最后一次提交版本的差别git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别或者 git diff HEAD~数字 HEAD~数字git tag tt HEAD~4 给倒数第5次提交打一个tag tag名字是ttgit diff tt 就是倒数第5个版本与第一个版本之间的差异git diff --cached tt 暂存区与倒数第5个版本之间的比对</code></pre><h4 id="9-查看提交信息"><a href="#9-查看提交信息" class="headerlink" title="9.查看提交信息"></a>9.查看提交信息</h4><pre><code class="hljs shell">git show HEAD // 查看最后一次提交修改的详细信息 也可以用git show 哈希值 查看对应的内容git show HEAD^ // 查看倒数第二次的提交修改详细信息git show HEAD^^ 或者git show HEAD~2 查看前2次变更git show HEAD 或 git show 哈希值 或者git show tag(标签名) 都可以查看最近一次提交的详细信息</code></pre><h4 id="10-查看信息"><a href="#10-查看信息" class="headerlink" title="10.查看信息"></a>10.查看信息</h4><pre><code class="hljs shell">git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short// 获取git log里的树形详细信息 包括hasg 日期 提交信息 提交人等git log --oneline //拉出所有提交信息 q是退出git log -5 // 查看前5次的提交记录git log --oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注git log 文件名 // 查看该文件的提交git log --grep // 想过滤看到的内容   过滤日志git log -n // 查看近期提交的n条信息内容git log -p // 查看详细提交记录</code></pre><h4 id="11-变基操作，改写历史提交-把多次提交合并起来"><a href="#11-变基操作，改写历史提交-把多次提交合并起来" class="headerlink" title="11.变基操作，改写历史提交 把多次提交合并起来"></a>11.变基操作，改写历史提交 把多次提交合并起来</h4><pre><code class="hljs shell">git rebase -i HEAD~3 变基之后的哈希值与之前的不同 证明变基是重新做的提交 把多次提交合并成了几次提交</code></pre><h4 id="12-回撤操作"><a href="#12-回撤操作" class="headerlink" title="12.回撤操作"></a>12.回撤操作</h4><pre><code class="hljs shell">git commit --amend -m "提交信息" // 回撤上一次提交并与本次工作区一起提交git reset HEAD~2 --hard // 回撤2步git reset --files // 从仓库回撤到暂存区git reset HEAD // 回撤暂存区内容到工作目录git reset HEAD --soft 回撤提交到暂存区git reset HEAD --hard // 回撤提交 放弃变更 (慎用)git reset HEAD^  // 回撤仓库最后一次提交git reset --hard commitid // 回撤到该次提交id的位置git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支</code></pre><h4 id="13-标签操作"><a href="#13-标签操作" class="headerlink" title="13.标签操作"></a>13.标签操作</h4><pre><code class="hljs shell">git tag // 查看列出所有打过的标签名git tag -d 标签名 // 删除对应标签git tag 标签名字 // 在当前仓库打个标签git tag foo -m "message" // 在当前提交上，打标签foo 并给message信息注释git tag 标签名 哈希值 -m "message" // 在某个哈希值上打标签并且写上标签的信息git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foogit push origin --tags // 把所有打好的标签推送到远程仓库git push origin 标签名 // 把指定标签推送到远程仓库git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空git stash list // 查看stash了哪些存储git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除git stash clear // 删除所有缓存的stashgit pull --tags // 把远程仓库的标签也拉取下来git push origin :refs/tags/远程标签名 // 删除远程仓库的标签</code></pre><h4 id="14-分支"><a href="#14-分支" class="headerlink" title="14.分支"></a>14.分支</h4><pre><code class="hljs shell">git branch 分支名 // 新建分支git branch // 查看当前所有分支git checkout 分支名 // 检出分支git checkout -b 分支名 // 创建并切换分支git checkout commitId 文件名（文件路径下的文件名） 还原这个文件到对应的commitId的版本（例如src/page/attendance/attendanceSum.vue我想把它还原到2个版本之前 首先git log src/page/attendance/attendanceSum.vue找到对应想要还原的版本复制版本提交的commitID 然后执行git checkout commitID src/page/attendance/attendanceSum.vue这样就把attendanceSum.vue这个单个文件 还原到了对应版本）git branch -v // 查看分支以及提交hash值和commit信息git merge 分支名 // 把该分支的内容合并到现有分支上git branch -d 分支名 // 删除分支git branch -D 分支名 // 强制删除 若没有其他分支合并就删除 d会提示 D不会git branch -m 旧分支名 新分支名 // 修改分支名git branch -M 旧分支名 新分支名 // 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)git branch -r // 列出远程分支(远程所有分支名)git branch -a // 查看远程分支(列出远程分支以及本地分支名)git fetch // 更新remote索引git push -u origin 分支名 // 将本地分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push 也可解决 git建立远程分支关联时出现fatal ... upstram的问题</code></pre><h4 id="15-SSH密钥生成"><a href="#15-SSH密钥生成" class="headerlink" title="15.SSH密钥生成"></a>15.SSH密钥生成</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">生成秘钥</span>ssh-keygen -t rsa -C wang732276349@163.com<span class="hljs-meta">#</span><span class="bash">查看秘钥</span>cat ~/.ssh/id_rsa.pub<span class="hljs-meta">#</span><span class="bash">将秘钥添加到git仓库中，不要后面的邮箱地址</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201102112433243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14 React-redux组件使用</title>
    <link href="/2020/10/29/35%20React-redux%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/10/29/35%20React-redux%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-React-redux介绍及安装"><a href="#1-React-redux介绍及安装" class="headerlink" title="1.React-redux介绍及安装"></a>1.React-redux介绍及安装</h4><p><code>React-Redux</code>这是一个React生态中常用组件，它可以简化<code>Redux</code>流程（需要注意的是概念：React、Redux、React-redux是三个不同的东西）</p><h5 id="1-1-项目初始化"><a href="#1-1-项目初始化" class="headerlink" title="1.1 项目初始化"></a>1.1 项目初始化</h5><pre><code class="hljs dsconfig"><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">demo09-React-</span><span class="hljs-string">redux</span><span class="hljs-string">cd </span><span class="hljs-string">demo09-React-</span><span class="hljs-string">redux</span><span class="hljs-string">npm </span><span class="hljs-string">start</span></code></pre><p>安装完成后，删除一些没有必要的样式和代码，在<code>/src</code>目录下，只留一个<code>index.js</code>文件，其余的全部删除。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre><h5 id="1-2-安装react-redux"><a href="#1-2-安装react-redux" class="headerlink" title="1.2 安装react-redux"></a>1.2 安装react-redux</h5><pre><code class="hljs shell">npm install --save react-redux</code></pre><h5 id="1-3-修改代码，让他跑起来"><a href="#1-3-修改代码，让他跑起来" class="headerlink" title="1.3 修改代码，让他跑起来"></a>1.3 修改代码，让他跑起来</h5><p>创建一个<code>TodoList.js</code>的组件。项目代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;         <span class="hljs-keyword">return</span> ( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Karma<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> );    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;</code></pre><p>有了<code>TodoList.js</code>后，我们引入到<code>index.js</code>文件下，然后修改代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre><p>接下来编写一下<code>render</code>函数中的JSX页面。</p><pre><code class="hljs js">render() &#123;     <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;ul&gt;</span><span class="hljs-regexp">                &lt;li&gt;Karma&lt;/</span>li&gt;            &lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;        );&#125;</code></pre><p>接下来按原来的<code>Redux</code>方式作一个<code>store</code>出来。</p><h5 id="1-4-Redux的安装和使用（复习）"><a href="#1-4-Redux的安装和使用（复习）" class="headerlink" title="1.4 Redux的安装和使用（复习）"></a>1.4 <code>Redux</code>的安装和使用（复习）</h5><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save redux</span></code></pre><p>首先创建一个<code>store</code>文件夹，在<code>/store</code>下创建一个<code>index.js</code>文件,并写入下面代码：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducer'</span><span class="hljs-keyword">const</span> store = createStore(reducer)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre><p>目前我们还没有<code>reducer</code>，所以要创建<code>reducer.js</code>文件，代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defalutState = &#123;    inputValue : <span class="hljs-string">'Karma'</span>,    list :[]&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defalutState,action) =&gt;&#123;    <span class="hljs-keyword">return</span> state&#125;</code></pre><p>然后再<code>TodoList.js</code>中的构造函数<code>constructor</code>中使用。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-comment">//-----关键代码--------start</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-comment">//-----关键代码--------end</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-comment">//-----关键代码--------start</span>    <span class="hljs-keyword">constructor</span>(props)&#123;        <span class="hljs-keyword">super</span>(props)        <span class="hljs-keyword">this</span>.state = store.getState()    &#125;    <span class="hljs-comment">//-----关键代码--------end</span>    render() &#123;         <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    <span class="hljs-comment">//-----关键代码--------start</span>                    &lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; /&gt;                    <span class="hljs-comment">//-----关键代码--------end</span>                    &lt;button&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;ul&gt;                    &lt;li&gt;Karma&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                &lt;/u</span>l&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default TodoList;</span></code></pre><p>到目前为止，只是安装了<code>React-Redux</code>,但是还并没有进行使用。</p><h4 id="2-React-redux中provider和connect"><a href="#2-React-redux中provider和connect" class="headerlink" title="2.React-redux中provider和connect"></a>2.React-redux中provider和connect</h4><h5 id="2-1-提供器Provider介绍"><a href="#2-1-提供器Provider介绍" class="headerlink" title="2.1 提供器Provider介绍"></a>2.1 提供器Provider介绍</h5><p><code>&lt;Provider&gt;</code>是一个提供器，只要使用了这个组件，组件里边的其它所有组件都可以使用<code>store</code>了，这也是<code>React-redux</code>的核心组件了。有了<code>&lt;Provider&gt;</code>就可以把<code>/src/index.js</code>改写成下面的代码样式。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span><span class="hljs-comment">//---------关键代码--------start</span><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-comment">//声明一个App组件，然后这个组件用Provider进行包裹。</span><span class="hljs-keyword">const</span> App = (    &lt;Provider store=&#123;store&#125;&gt;        &lt;TodoList /&gt;    &lt;<span class="hljs-regexp">/Provider&gt;</span><span class="hljs-regexp">)</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/---------关键代码--------end</span><span class="hljs-regexp">ReactDOM.render(App, document.getElementById('root'));</span></code></pre><p>写完这个，去浏览器中进行查看，发现代码也是可以完美运行的。需要注意的是，现在还是用传统方法获取的<code>store</code>中的数据。有了<code>Provider</code>再获取数据就没有那么麻烦了。</p><h5 id="2-2-connect连接器的使用"><a href="#2-2-connect连接器的使用" class="headerlink" title="2.2 connect连接器的使用"></a>2.2 <code>connect</code>连接器的使用</h5><p>打开<code>TodoList.js</code>文件，引入<code>connect</code>，它是一个连接器（其实它就是一个方法），有了这个连接器就很容易的获得数据了。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>  <span class="hljs-comment">//引入连接器</span></code></pre><p>这时候暴露出去的就变成了<code>connect</code>了，代码如下。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(xxx,<span class="hljs-literal">null</span>)(TodoList);</code></pre><p>这里的<code>xxx</code>代表一个映射关系，目前还没有制作这个映射关系。</p><h5 id="2-3-映射关系的制作"><a href="#2-3-映射关系的制作" class="headerlink" title="2.3 映射关系的制作"></a>2.3 映射关系的制作</h5><p>映射关系就是把原来的state映射成组件中的<code>props</code>属性，比如我们想映射<code>inputValue</code>就可以写成如下代码。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> stateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputValue : state.inputValue    &#125;&#125;</code></pre><p>这时候再把<code>xxx</code>改为<code>stateToProps</code></p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,<span class="hljs-literal">null</span>)(TodoList)</code></pre><p>然后把<code>&lt;input&gt;</code>里的<code>state</code>标签，改为<code>props</code>,代码如下:</p><pre><code class="hljs js">&lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; /&gt;</code></pre><p><code>TodoList.js</code>的所有代码。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props)&#123;        <span class="hljs-keyword">super</span>(props)        <span class="hljs-keyword">this</span>.state = store.getState()    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; /&gt;                    &lt;button&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;ul&gt;                    &lt;li&gt;JSPang&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                &lt;/u</span>l&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">const stateToProps = (state)=&gt;&#123;</span><span class="hljs-regexp">    return &#123;</span><span class="hljs-regexp">        inputValue : state.inputValue</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default connect(stateToProps,null)(TodoList);</span></code></pre><h4 id="3-React-redux的数据修改"><a href="#3-React-redux的数据修改" class="headerlink" title="3.React-redux的数据修改"></a>3.React-redux的数据修改</h4><h5 id="3-1-编写onChange响应事件"><a href="#3-1-编写onChange响应事件" class="headerlink" title="3.1 编写onChange响应事件"></a>3.1 编写<code>onChange</code>响应事件</h5><p>打开<code>TodoList.js</code>文件，然后在<code>&lt;button&gt;</code>上加上<code>onChange</code>事件。</p><pre><code class="hljs jsx">&lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;</code></pre><p>有了事件需要编写对应的方法,这里先写一个最简单的<code>inputChange</code>方法。</p><pre><code class="hljs js">inputChange(e)&#123;    <span class="hljs-built_in">console</span>.log(e.target.value)&#125;</code></pre><p>然后到浏览器中的控制台就不再有报错，而且输入时可以打印出值。</p><h5 id="3-2-编写DispatchToProps"><a href="#3-2-编写DispatchToProps" class="headerlink" title="3.2 编写DispatchToProps"></a>3.2 编写<code>DispatchToProps</code></h5><p>要使用<code>react-redux</code>，可以编写另一个映射<code>DispatchToProps</code>,先看下面这段代码，你会发现有两个参数，第二个参数我们用的是<code>null</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,<span class="hljs-literal">null</span>)(TodoList);</code></pre><p><code>DispatchToProps</code>就是要传递的第二个参数，通过这个参数才能改变<code>store</code>中的值。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> dispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputChange(e)&#123;            <span class="hljs-built_in">console</span>.log(e.target.value)        &#125;    &#125;&#125;</code></pre><p>有了这个参数之后就可以把响应事件改成下面的代码.</p><pre><code class="hljs js">&lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.props.inputChange&#125; /&gt;</code></pre><p>然后把connect第二个参数传递过去。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,dispatchToProps)(TodoList);</code></pre><p>这时候原来的<code>inputChange</code>方法就没用了，可以删除掉。 </p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props)&#123;        <span class="hljs-keyword">super</span>(props)        <span class="hljs-keyword">this</span>.state = store.getState()    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.props.inputChange&#125; /&gt;                    &lt;button&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;ul&gt;                    &lt;li&gt;Karma&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">                &lt;/u</span>l&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">const stateToProps = (state)=&gt;&#123;</span><span class="hljs-regexp">    return &#123;</span><span class="hljs-regexp">        inputValue : state.inputValue</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">const dispatchToProps = (dispatch) =&gt;&#123;</span><span class="hljs-regexp">    return &#123;</span><span class="hljs-regexp">        inputChange(e)&#123;</span><span class="hljs-regexp">            console.log(e.target.value)</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default connect(stateToProps,dispatchToProps)(TodoList);</span></code></pre><h5 id="3-3-派发action到store中"><a href="#3-3-派发action到store中" class="headerlink" title="3.3 派发action到store中"></a>3.3 派发<code>action</code>到store中</h5><p>映射关系已经做好了，接下来只要进行<code>action</code>的派发和<code>reducer</code>对业务逻辑的编写就可以了。派发action和以前的流程一样。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> dispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputChange(e)&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'change_input'</span>,                value:e.target.value            &#125;            dispatch(action)        &#125;    &#125;&#125;</code></pre><p>派发后就需求在<code>reducer</code>里边，编写对应的业务逻辑了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defalutState = &#123;    inputValue : <span class="hljs-string">'jspang'</span>,    list :[]&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defalutState,action) =&gt;&#123;    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">'change_input'</span>)&#123;        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))        newState.inputValue = action.value        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-keyword">return</span> state&#125;</code></pre><h4 id="4-React-redux增加List数据"><a href="#4-React-redux增加List数据" class="headerlink" title="4.React-redux增加List数据"></a>4.React-redux增加List数据</h4><h5 id="4-1-给按钮增加点击事件"><a href="#4-1-给按钮增加点击事件" class="headerlink" title="4.1 给按钮增加点击事件"></a>4.1 给按钮增加点击事件</h5><p>直接在<code>/src/TodoList.js</code>里的<code>Button</code>增加一个<code>onClick</code>事件，代码如下:</p><pre><code class="hljs js">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.props.clickButton&#125;&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span></code></pre><p>注意这里依然使用的<code>props</code>，也就是说还需要把方法写在<code>dispatchToProps</code>里。我们这里先写一个测试，看看是否绑定上了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> dispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputChange(e)&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'change_input'</span>,                value:e.target.value            &#125;            dispatch(action)        &#125;,        clickButton()&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test'</span>)        &#125;    &#125;&#125;</code></pre><p>写完<code>clickButton</code>方法后，在浏览器中预览，打开浏览器的控制台看一下结果，应该在点击时，可以看到显示test。 这步完成，就是用<code>dispatch</code>派发<code>action</code>了。</p><pre><code class="hljs js">clickButton()&#123;    <span class="hljs-keyword">let</span> action = &#123; <span class="hljs-attr">type</span>:<span class="hljs-string">'add_item'</span> &#125;    dispatch(action)&#125;</code></pre><h5 id="4-2-编写Reducer的业务逻辑"><a href="#4-2-编写Reducer的业务逻辑" class="headerlink" title="4.2 编写Reducer的业务逻辑"></a>4.2 编写<code>Reducer</code>的业务逻辑</h5><p>派发完成后,到<code>Reducer</code>编写业务逻辑，这一步和以前的操作基本一样。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defalutState = &#123;    inputValue : <span class="hljs-string">'karma'</span>,    list :[]&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defalutState,action) =&gt;&#123;    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">'change_input'</span>)&#123;        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))        newState.inputValue = action.value        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-comment">//----关键代码------start---------</span>    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">'add_item'</span>)&#123;        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))        newState.list.push(newState.inputValue)        newState.inputValue = <span class="hljs-string">''</span>        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-comment">//----关键代码------end---------</span>    <span class="hljs-keyword">return</span> state&#125;</code></pre><h5 id="4-3-页面UI部分的制作"><a href="#4-3-页面UI部分的制作" class="headerlink" title="4.3 页面UI部分的制作"></a>4.3 页面UI部分的制作</h5><p>然后到TodoList.js<code>中进行</code>JSX<code>部分的编写，编写前需要先把</code>stateToProps`的映射关系做好。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> stateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputValue : state.inputValue,        list:state.list    &#125;&#125;</code></pre><p>有了映射关系，就可以再界面中用属性的方式，进行显示，代码如下：</p><pre><code class="hljs js">&lt;ul&gt;    &#123;        <span class="hljs-keyword">this</span>.props.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)        &#125;)    &#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>这样就实现了增加<code>TodoList</code>的列表项。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props)&#123;        <span class="hljs-keyword">super</span>(props)        <span class="hljs-keyword">this</span>.state = store.getState()    &#125;    render() &#123;         <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;input value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.props.inputChange&#125; /&gt;                    &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.props.clickButton&#125;&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;ul&gt;                    &#123;                        <span class="hljs-keyword">this</span>.props.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;                            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)                        &#125;)                    &#125;                &lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;        );    &#125;&#125;<span class="hljs-keyword">const</span> stateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputValue : state.inputValue,        list:state.list    &#125;&#125;<span class="hljs-keyword">const</span> dispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputChange(e)&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'change_input'</span>,                value:e.target.value            &#125;            dispatch(action)        &#125;,        clickButton()&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'add_item'</span>            &#125;            dispatch(action)        &#125;    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,dispatchToProps)(TodoList);</code></pre><h4 id="5-React-redux程序优化"><a href="#5-React-redux程序优化" class="headerlink" title="5.React-redux程序优化"></a>5.React-redux程序优化</h4><h5 id="5-1-用结构复制精简代码"><a href="#5-1-用结构复制精简代码" class="headerlink" title="5.1 用结构复制精简代码"></a>5.1 用结构复制精简代码</h5><p>现在代码中有好几处<code>this.props</code>都是重复的，这时候就可以用<code>javascript</code>的解构赋值方法，来精简代码。修改<code>TodoList.js</code>中的<code>Render</code>函数，把原来带代码修改为下面的代码:</p><pre><code class="hljs jsx">render() &#123;     <span class="hljs-keyword">let</span> &#123;inputValue ,inputChange,clickButton,list&#125; = <span class="hljs-keyword">this</span>.props;    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;div&gt;                &lt;input value=&#123;inputValue&#125; onChange=&#123;inputChange&#125; /&gt;                &lt;button onClick=&#123;clickButton&#125;&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;            &lt;ul&gt;                &#123;                    list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;                        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)                    &#125;)                &#125;            &lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;    );&#125;</code></pre><h5 id="5-2-把TodoList改为UI组件-提高性能"><a href="#5-2-把TodoList改为UI组件-提高性能" class="headerlink" title="5.2 把TodoList改为UI组件-提高性能"></a>5.2 把<code>TodoList</code>改为UI组件-提高性能</h5><p>可以看到，现在的<code>TodoList</code>组件里没有任何的业务逻辑，只有一个<code>Render</code>方法，这时候就可以把它改为UI组件(无状态组件)，UI组件就是一个方法，减少很多冗余操作，从而提高程序运行性能。这时候重新声明一个<code>TodoList</code>的变量，然后把render函数里的东西复制过来，只要稍加修改，就可以得到下面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> TodoList =<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> &#123;inputValue ,inputChange,clickButton,list&#125; = props; <span class="hljs-comment">// 粘贴过来后，此处要进行修改</span>    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;div&gt;                &lt;input value=&#123;inputValue&#125; onChange=&#123;inputChange&#125; /&gt;                &lt;button onClick=&#123;clickButton&#125;&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;            &lt;ul&gt;                &#123;                    list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;                        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)                    &#125;)                &#125;            &lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;    );&#125;</code></pre><p>代码写完后，我们删除一些不用的引入，然后就可以到浏览器中进行预览了。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span></code></pre><p><code>TodoList.js</code>的所有代码。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span><span class="hljs-keyword">const</span> TodoList =<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> &#123;inputValue ,inputChange,clickButton,list&#125; = props; <span class="hljs-comment">// 粘贴过来后，此处要进行修改</span>    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;div&gt;                &lt;input value=&#123;inputValue&#125; onChange=&#123;inputChange&#125; /&gt;                &lt;button onClick=&#123;clickButton&#125;&gt;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;            &lt;ul&gt;                &#123;                    list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;                        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)                    &#125;)                &#125;            &lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;    );&#125;<span class="hljs-keyword">const</span> stateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputValue : state.inputValue,        list:state.list    &#125;&#125;<span class="hljs-keyword">const</span> dispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        inputChange(e)&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'change_input'</span>,                value:e.target.value            &#125;            dispatch(action)        &#125;,        clickButton()&#123;            <span class="hljs-keyword">let</span> action = &#123;                type:<span class="hljs-string">'add_item'</span>            &#125;            dispatch(action)        &#125;    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,dispatchToProps)(TodoList);</code></pre><p>然后，再来理解一下最后一句话代码的意思。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(stateToProps,dispatchToProps)(TodoList);</code></pre><p><code>connect</code>的作用是把UI组件（无状态组件）和业务逻辑代码的分开，然后通过connect再链接到一起，让代码更加清晰和易于维护。这也是<code>React-Redux</code>最大的优点。</p>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13 Redux中间件-thunk和saga</title>
    <link href="/2020/10/29/34%20Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2020/10/29/34%20Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-Redux-thunk中间件"><a href="#1-Redux-thunk中间件" class="headerlink" title="1.Redux-thunk中间件"></a>1.Redux-thunk中间件</h4><h5 id="1-1-安装及配置"><a href="#1-1-安装及配置" class="headerlink" title="1.1 安装及配置"></a>1.1 安装及配置</h5><p><code>Redux-thunk</code>并不在<code>Redux</code>基础组件中，需要进行安装。</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save redux-thunk</span></code></pre><p>在/store/index.js中引入redux-thunck。</p><p>1.引入<code>applyMiddleware</code>,如果你要使用中间件，就必须在redux中引入<code>applyMiddleware</code>.</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore , applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span></code></pre><p>2.引入<code>redux-thunk</code>库</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span></code></pre><p>如果你按照官方文档来写，你直接把thunk放到<code>createStore</code>里的第二个参数就可以了，但以前配置了<code>Redux Dev Tools</code>，已经占用了第二个参数。</p><p>官方文档给的方法:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = createStore(    reducer,    applyMiddleware(thunk)) <span class="hljs-comment">// 创建数据存储仓库</span></code></pre><p>这样写是完全没有问题的，但是的<code>Redux Dev Tools</code>插件就不能使用了，如果想两个同时使用，需要使用<strong>增强函数</strong>。使用增加函数前需要先引入<code>compose</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore , applyMiddleware ,compose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span></code></pre><p>然后利用<code>compose</code>创造一个增强函数，就相当于建立了一个链式函数，代码如下:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> composeEnhancers =   <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?    <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;):compose</code></pre><p>有了增强函数后，就可以把<code>thunk</code>加入进来了，这样两个函数就都会执行了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> enhancer = composeEnhancers(applyMiddleware(thunk))</code></pre><p>这时候直接在<code>createStore</code>函数中的第二个参数，使用这个<code>enhancer</code>变量就可以了，相当于两个函数都执行了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = createStore( reducer, enhancer) <span class="hljs-comment">// 创建数据存储仓库</span></code></pre><p>也许你对增加函数还不能完全理解，其实你完全把这个想成固定代码，直接使用就好，我在这里给出全部代码，方便你以后学习使用。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore , applyMiddleware ,compose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>  <span class="hljs-comment">//  引入createStore方法</span><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducer'</span>    <span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span><span class="hljs-keyword">const</span> composeEnhancers =   <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?    <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;):compose<span class="hljs-keyword">const</span> enhancer = composeEnhancers(applyMiddleware(thunk))<span class="hljs-keyword">const</span> store = createStore( reducer, enhancer) <span class="hljs-comment">// 创建数据存储仓库</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store   <span class="hljs-comment">//暴露出去</span></code></pre><h5 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h5><p>以前<code>actionCreators.js</code>都是定义好的action，根本没办法写业务逻辑，有了<code>Redux-thunk</code>之后，可以把App.js<code>中的</code>componentDidMount<code>业务逻辑放到这里来编写。也就是把向后台请求数据的代码放到</code>actionCreators.js<code>文件里。那需要引入</code>axios<code>,并写一个新的函数方法。（以前的action是对象，现在的action可以是函数了，这就是</code>redux-thunk`带来的好处）</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-comment">//其余省略</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getTodoList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        axios.get(<span class="hljs-string">'https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;            <span class="hljs-keyword">const</span> data = res.data            <span class="hljs-built_in">console</span>.log(data)        &#125;)    &#125;&#125;</code></pre><p>现在需要执行这个方法，并在控制台查看结果，这时候可以修改<code>App.js</code>文件中的<code>componentDidMount</code>代码。</p><pre><code class="hljs js"><span class="hljs-comment">//先引入getTodoList</span><span class="hljs-keyword">import</span> &#123;getTodoList , changeInputAction , addItemAction ,deleteItemAction,getListAction&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/actionCreatores'</span>componentDidMount()&#123;    <span class="hljs-keyword">const</span> action = getTodoList()    store.dispatch(action)&#125;</code></pre><p>然后到浏览器的控制台中查看一下，看看是不是已经得到了后端传给的数据。得到之后，继续走以前的Redux流程就可以ok。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getTodoList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>)=&gt;</span>&#123;        axios.get(<span class="hljs-string">'https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;            <span class="hljs-keyword">const</span> data = res.data            <span class="hljs-keyword">const</span> action = getListAction(data)            dispatch(action)        &#125;)    &#125;&#125;</code></pre><p>这个函数可以直接传递<code>dispatch</code>进去，这是自动的，然后直接用<code>dispatch(action)</code>传递就好了。现在就可以打开浏览器进行测试了。</p><p>这时候还会有一些警告，主要是引入了并没有使用，按照警告的提示，删除没用的引入就可以了。</p><h4 id="2-Redux-saga中间件"><a href="#2-Redux-saga中间件" class="headerlink" title="2.Redux-saga中间件"></a>2.Redux-saga中间件</h4><p><strong>首先，中间件不是<code>React</code>的中间件，而是<code>Redux</code>的中间件。</strong></p><h5 id="2-1-安装及配置"><a href="#2-1-安装及配置" class="headerlink" title="2.1 安装及配置"></a>2.1 安装及配置</h5><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save redux-saga</span></code></pre><p>github地址：</p><blockquote><p><a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">https://github.com/redux-saga/redux-saga</a></p></blockquote><p>配置及使用省略。</p>]]></content>
    
    
    <categories>
      
      <category>2020-11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12 Redux案例-基于Ant Design React</title>
    <link href="/2020/10/25/33%20Redux%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8EAnt%20Design%20React/"/>
    <url>/2020/10/25/33%20Redux%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8EAnt%20Design%20React/</url>
    
    <content type="html"><![CDATA[<h4 id="1-Ant-Design介绍和环境初始化"><a href="#1-Ant-Design介绍和环境初始化" class="headerlink" title="1.Ant Design介绍和环境初始化"></a>1.Ant Design介绍和环境初始化</h4><p><code>Ant Design</code>是一套面向企业级开发的UI框架，视觉和动效作的很好。阿里开源的一套UI框架，它不只支持<code>React</code>，还有<code>ng</code>和<code>Vue</code>的版本，我认为不论你的前端框架用什么，<code>Ant Design</code>都是一个不错的选择。习惯性把<code>AntDesign</code>简称为<code>antd</code>。</p><blockquote><p>官网地址:<a href="https://ant.design/index-cn" target="_blank" rel="noopener">https://ant.design/index-cn</a></p></blockquote><h4 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2.项目初始化"></a>2.项目初始化</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装脚手架工具</span>cnpm install -g create-react-appcreate-react-app demo05-reduxcd demo05-reduxyarn start</code></pre><h4 id="3-生成基本代码结构"><a href="#3-生成基本代码结构" class="headerlink" title="3.生成基本代码结构"></a>3.生成基本代码结构</h4><p>删除src下所有文件，创建index.js。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>))</code></pre><p>创建App.js。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;Hello World&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default App;</span></code></pre><h4 id="3-安装Ant-Design"><a href="#3-安装Ant-Design" class="headerlink" title="3.安装Ant Design"></a>3.安装Ant Design</h4><pre><code class="hljs shell">cnpm install antd --save<span class="hljs-meta">#</span><span class="bash">或</span>yarn add antd</code></pre><h4 id="4-使用Ant-Design制作基础UI界面"><a href="#4-使用Ant-Design制作基础UI界面" class="headerlink" title="4.使用Ant Design制作基础UI界面"></a>4.使用Ant Design制作基础UI界面</h4><p>引入CSS样式</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span></code></pre><p>编写Input框和Button按钮</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">import</span> &#123;Input,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-comment">//需要什么组件，引入什么组件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;Input placeholder=&#123;<span class="hljs-string">'karma'</span>&#125; style=&#123;&#123; <span class="hljs-attr">width</span>:<span class="hljs-string">'250px'</span>&#125;&#125;/&gt;                    &lt;Button type=<span class="hljs-string">"primary"</span>&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default App;</span></code></pre><p>添加List列表，首先我们需要在class外声明一个data数组</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> data=[    <span class="hljs-string">'test1'</span>,    <span class="hljs-string">'test2'</span>,    <span class="hljs-string">'test3'</span>]</code></pre><p>再在App.js中，引入List组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Input,Button,List&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-comment">//需要什么组件，引入什么组件</span></code></pre><p>添加List组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">import</span> &#123;Input, Button, List&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-comment">//需要什么，引入什么</span><span class="hljs-keyword">const</span> data = [    <span class="hljs-string">'test1'</span>,    <span class="hljs-string">'test2'</span>,    <span class="hljs-string">'test3'</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;Input placeholder=&#123;<span class="hljs-string">'karma'</span>&#125; style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>&#125;&#125;/&gt;                    &lt;Button type=<span class="hljs-string">"primary"</span>&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &#123;<span class="hljs-comment">/*主要代码*/</span>&#125;                &lt;div&gt;                    &lt;List                        bordered                        dataSource=&#123;data&#125;                        renderItem=&#123;item =&gt; (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>)&#125;                    &gt;&lt;<span class="hljs-regexp">/List&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &#123;<span class="hljs-comment">/*主要代码*/</span>&#125;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default App;</span></code></pre><h4 id="5-创建Redux中的仓库-store和reducer"><a href="#5-创建Redux中的仓库-store和reducer" class="headerlink" title="5.创建Redux中的仓库-store和reducer"></a>5.创建Redux中的仓库-store和reducer</h4><p>首先需要先安装Redux。</p><pre><code class="hljs shell">cnpm install --save redux</code></pre><p>再在src目录下创建store目录，在store目录下创建index.js。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>  <span class="hljs-comment">// 引入createStore方法</span><span class="hljs-keyword">const</span> store = createStore()          <span class="hljs-comment">// 创建数据存储仓库</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store                 <span class="hljs-comment">//暴露出去</span></code></pre><p>再创建reducer.js在store目录下。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defaultState = &#123;&#125;  <span class="hljs-comment">//默认数据</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defaultState,action)=&gt;&#123;  <span class="hljs-comment">//就是一个方法函数</span>  <span class="hljs-comment">//state: 是整个项目中需要管理的数据信息,这里我们没有什么数据，所以用默认空的来表示。</span>    <span class="hljs-keyword">return</span> state&#125;</code></pre><p>最后在store/index.js中引入reducer，再将reducer以参数的形式传递给createStore方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">"./reducer"</span>;<span class="hljs-keyword">const</span> store =createStore(reducer);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;</code></pre><p>仓库<code>store</code>和<code>reducer</code>都创建好了，可以初始化下App.js中的数据了，在<code>reducer.js</code>文件的<code>defaultState</code>对象中，加入两个属性:<code>inputValue</code>和<code>list</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defaultState = &#123;    inputValue: <span class="hljs-string">'karma'</span>,    list: [        <span class="hljs-string">'test1'</span>,        <span class="hljs-string">'test2'</span>,        <span class="hljs-string">'test3'</span>    ]&#125;  <span class="hljs-comment">//默认数据</span></code></pre><p>让App.js组件获取到store中初始化的数据，在组件引入store。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>#或者<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/index'</span></code></pre><p>再在组件的构造函数中获取到数据，将它赋值给组件的<code>state</code>，最后再将数据进行渲染。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">import</span> &#123;Input, Button, List&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-comment">//需要什么，引入什么</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"./store"</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-comment">// 主要代码</span>    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state=store.getState();    &#125;    <span class="hljs-comment">// 主要代码</span>    render() &#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;                    &lt;Input placeholder=&#123;<span class="hljs-string">'karma'</span>&#125; style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>&#125;&#125;/&gt;                    &lt;Button type=<span class="hljs-string">"primary"</span>&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;div&gt;                    &#123;<span class="hljs-comment">/*主要代码*/</span>&#125;                    &lt;List                        bordered                        dataSource=&#123;<span class="hljs-keyword">this</span>.state.list&#125;                        renderItem=&#123;item =&gt; (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>)&#125;                    &gt;&lt;<span class="hljs-regexp">/List&gt;</span><span class="hljs-regexp">                    &#123;/</span>*主要代码*<span class="hljs-regexp">/&#125;</span><span class="hljs-regexp">                &lt;/</span>div&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default App;</span></code></pre><h4 id="6-通过Input体验Redux的流程"><a href="#6-通过Input体验Redux的流程" class="headerlink" title="6.通过Input体验Redux的流程"></a>6.通过Input体验Redux的流程</h4><p>给Input添加onChange时间，并在构造函数中进行bind绑定。</p><pre><code class="hljs js">##创建inputChange方法changeInputValue(e)&#123;    <span class="hljs-built_in">console</span>.log(e.target.value)&#125;##Input添加onChange事件,并再添加一个Input框，用来获取到第一个Input值的变化情况&lt;Input placeholder=&#123;<span class="hljs-string">'karma'</span>&#125; style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>&#125;&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange&#125;/&gt;&lt;Input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>&#125;&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange&#125;/&gt;##构造函数中，进行绑定<span class="hljs-keyword">this</span>.inputChange=<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)</code></pre><p>在changeInputValue方法中，创建Action交互动作。</p><pre><code class="hljs js">inputChange(e) &#123;  <span class="hljs-keyword">const</span> action = &#123;    type: <span class="hljs-string">'inputChange'</span>,    ##获取到Input框的值    value: e.target.value  &#125;  ##通过dispatch传递到store中  store.dispatch(action)&#125;</code></pre><p>然后在reducer.js中进行数据改变操作。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defaultState, action) =&gt; &#123;  <span class="hljs-comment">//就是一个方法函数</span>    <span class="hljs-comment">//state: 是整个项目中需要管理的数据信息,这里我们没有什么数据，所以用默认的来表示。</span>    <span class="hljs-keyword">if</span> (action.type===<span class="hljs-string">'inputChange'</span>)&#123;      <span class="hljs-comment">//Reducer里只能接收state，不能改变state,所以我们进行深度拷贝</span>        <span class="hljs-keyword">let</span> newState=<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝</span>        newState.inputValue=action.value        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-keyword">return</span> state&#125;</code></pre><p><strong>记住：Reducer里只能接收state，不能改变state。</strong></p><p>接着我们需要使得组件发生更新，我们需要在App组件构造函数中添加store订阅。</p><pre><code class="hljs js">    <span class="hljs-keyword">constructor</span>(props) &#123;  <span class="hljs-keyword">super</span>(props);  <span class="hljs-keyword">this</span>.state = store.getState();  <span class="hljs-keyword">this</span>.inputChange = <span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)  <span class="hljs-comment">// 主要代码</span>  <span class="hljs-keyword">this</span>.storeChange = <span class="hljs-keyword">this</span>.storeChange.bind(<span class="hljs-keyword">this</span>)  store.subscribe(<span class="hljs-keyword">this</span>.storeChange)  <span class="hljs-comment">// 主要代码</span>&#125;##并添加storeChange方法，进行重新setState更新组件数据storeChange() &#123;  <span class="hljs-keyword">this</span>.setState(store.getState())&#125;</code></pre><p>然后我们在浏览器第一个Input框中输入值，第二个Input也随着变化。</p><h4 id="7-添加Button响应事件"><a href="#7-添加Button响应事件" class="headerlink" title="7.添加Button响应事件"></a>7.添加Button响应事件</h4><p>首先我们给Button添加onClick点击事件，并在构造函数中进行绑定。</p><pre><code class="hljs js">&lt;Input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>&#125;&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange&#125;/&gt;&lt;Button type=<span class="hljs-string">"primary"</span> onClick=&#123;<span class="hljs-keyword">this</span>.addItem&#125;&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">##构造函数中添加绑定</span><span class="hljs-regexp">this.addItem = this.addItem.bind(this)</span><span class="hljs-regexp"></span><span class="hljs-regexp">##添加addItem方法，创建action，并通过dispatch将操作传递给store</span><span class="hljs-regexp">addItem() &#123;</span><span class="hljs-regexp">  const action = &#123;</span><span class="hljs-regexp">    type: 'addItem'</span><span class="hljs-regexp">  &#125;</span><span class="hljs-regexp">  store.dispatch(action)</span><span class="hljs-regexp">&#125;</span></code></pre><p>然后我们在reducer.js进行list数据添加操作。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defaultState, action) =&gt; &#123;  <span class="hljs-comment">//就是一个方法函数</span>    <span class="hljs-comment">//state: 是整个项目中需要管理的数据信息,这里我们没有什么数据，所以用默认的来表示。</span>    <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">'inputChange'</span>) &#123;        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝</span>        newState.inputValue = action.value        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">'addItem'</span>) &#123;        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝</span>        newState.list.push(newState.inputValue)        newState.inputValue = <span class="hljs-string">''</span>        <span class="hljs-keyword">return</span> newState    &#125;    <span class="hljs-keyword">return</span> state&#125;</code></pre><p>最后我们就可以点击Button按钮进行List数据添加。</p><h4 id="8-通过Redux进行List的删除"><a href="#8-通过Redux进行List的删除" class="headerlink" title="8.通过Redux进行List的删除"></a>8.通过Redux进行List的删除</h4><p>首先，我们需要给List子项绑定onClick事件，并传递下标进行绑定。</p><pre><code class="hljs js">&lt;List    bordered    dataSource=&#123;<span class="hljs-keyword">this</span>.state.list&#125;    renderItem=&#123;(item, index) =&gt; (               &lt;List.Item onClick=&#123;<span class="hljs-keyword">this</span>.itemChange.bind(<span class="hljs-keyword">this</span>, index)&#125;&gt;&#123;item&#125;&lt;<span class="hljs-regexp">/List.Item&gt;)&#125;&gt;&lt;/</span>List&gt;      ##添加删除方法，将action操作通过dispatch传递到store中    deleteItem(index) &#123;      <span class="hljs-keyword">const</span> action = &#123;        type: <span class="hljs-string">'deleteItem'</span>,        index      &#125;      store.dispatch(action)    &#125;</code></pre><p>再在reducer.js中，进行数据删除操作更新。</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">'deleteItem'</span>) &#123;  <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝</span>  newState.list.splice(action.index, <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> newState&#125;</code></pre><p>然后在浏览器中，我们就可以点击item子项，进行List数据删除。</p><h4 id="9-把Action-Type单独创建一个js文件管理"><a href="#9-把Action-Type单独创建一个js文件管理" class="headerlink" title="9.把Action Type单独创建一个js文件管理"></a>9.把Action Type单独创建一个js文件管理</h4><pre><code class="hljs js">#创建store/actionTypes.js<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CHANGE_INPUT=<span class="hljs-string">'changeInput'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_INFO=<span class="hljs-string">'addInfo'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DELETE_ITEM=<span class="hljs-string">'deleteItem'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> GET_LIST=<span class="hljs-string">'getList'</span></code></pre><p>引入Action中使用</p><pre><code class="hljs js">#actionTypes.js<span class="hljs-keyword">import</span> &#123;CHANGE_INPUT, ADD_INFO, DELETE_ITEM&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/actionTypes'</span>changeInput(e) &#123;  <span class="hljs-keyword">const</span> action = &#123;    type: CHANGE_INPUT,    value: e.target.value  &#125;  store.dispatch(action)&#125;clickBtn() &#123;  <span class="hljs-keyword">const</span> action = &#123;    type: ADD_INFO  &#125;  store.dispatch(action)&#125;deleteItem(index) &#123;  <span class="hljs-keyword">const</span> action = &#123;    type: DELETE_ITEM,    index  &#125;  store.dispatch(action)&#125;</code></pre><p>引入Reducer并进行更改</p><pre><code class="hljs js">#reducer.js<span class="hljs-keyword">import</span> &#123;CHANGE_INPUT, ADD_INFO, DELETE_ITEM&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionTypes'</span><span class="hljs-keyword">if</span> (action.type === CHANGE_INPUT) &#123;  <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝state</span>  newState.inputValue = action.value  <span class="hljs-keyword">return</span> newState&#125;<span class="hljs-keyword">if</span> (action.type === ADD_INFO) &#123;  <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝state</span>  newState.list.push(newState.inputValue)  newState.inputValue = <span class="hljs-string">''</span>  <span class="hljs-keyword">return</span> newState&#125;<span class="hljs-keyword">if</span> (action.type === DELETE_ITEM) &#123;  <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝state</span>  newState.list.splice(action.index, <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> newState;&#125;</code></pre><h4 id="10-编写actionCreators-js"><a href="#10-编写actionCreators-js" class="headerlink" title="10.编写actionCreators.js"></a>10.编写actionCreators.js</h4><blockquote><p>为了让action方便统一管理，使得代码更加简洁。</p></blockquote><pre><code class="hljs js">#actionCreators.js<span class="hljs-keyword">import</span> &#123;CHANGE_INPUT, ADD_INFO, DELETE_ITEM, GET_LIST&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionTypes'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> changeInput = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123;    type: CHANGE_INPUT,    value&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> clickBtn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;    type: ADD_INFO&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteItem = <span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> (&#123;    type: DELETE_ITEM,    index&#125;)</code></pre><p>在App.js中引入action常量方法</p><pre><code class="hljs js">#App.js<span class="hljs-keyword">import</span> &#123;changeInput, clickBtn, deleteItem&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/actionCreators'</span>#方法修改changeInput(e) &#123;  store.dispatch(changeInput(e.target.value))&#125;clickBtn() &#123;  store.dispatch(clickBtn())&#125;deleteItem(index) &#123;  store.dispatch(deleteItem(index))&#125;</code></pre><h4 id="11-Redux所遇到的坑"><a href="#11-Redux所遇到的坑" class="headerlink" title="11.Redux所遇到的坑"></a>11.Redux所遇到的坑</h4><ul><li><code>store</code>必须是唯一的，多个<code>store</code>是坚决不允许，只能有一个<code>store</code>空间</li><li>只有<code>store</code>能改变自己的内容，<code>Reducer</code>不能改变</li><li><code>Reducer</code>必须是纯函数</li></ul><h4 id="12-组建UI和业务拆分"><a href="#12-组建UI和业务拆分" class="headerlink" title="12.组建UI和业务拆分"></a>12.组建UI和业务拆分</h4><p>拆分UI组件，首先我们先创建一个AppUI.js文件，将App.js中的JSX部分代码复制过来，并引入所需的相关组件</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">import</span> &#123; Input , Button , List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppUI</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> (             &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>: <span class="hljs-string">'10px'</span>&#125;&#125;&gt;                &lt;div&gt;                    &lt;Input style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">'10px'</span>&#125;&#125;                           onChange=&#123;<span class="hljs-keyword">this</span>.changeInput&#125; value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;/&gt;                    &lt;Button type=&#123;<span class="hljs-string">"primary"</span>&#125; onClick=&#123;<span class="hljs-keyword">this</span>.clickBtn&#125;&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;div&gt;                    &lt;List                        bordered                        dataSource=&#123;<span class="hljs-keyword">this</span>.state.list&#125;                        renderItem=&#123;(item, index) =&gt; (                            &lt;List.Item onClick=&#123;<span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>, index)&#125;&gt;&#123;item&#125;&lt;<span class="hljs-regexp">/List.Item&gt;</span><span class="hljs-regexp">                        )&#125;</span><span class="hljs-regexp">                    /</span>&gt;                &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AppUI;</code></pre><p>修改App.js文件</p><pre><code class="hljs js">#引入AppUI组件<span class="hljs-keyword">import</span> AppUI <span class="hljs-keyword">from</span> <span class="hljs-string">"./AppUI"</span>;#并修改JSX部分代码render() &#123;     <span class="hljs-keyword">return</span> (         &lt;AppUI /&gt;    );&#125;</code></pre><h5 id="UI组件和业务逻辑组件整合"><a href="#UI组件和业务逻辑组件整合" class="headerlink" title="UI组件和业务逻辑组件整合"></a>UI组件和业务逻辑组件整合</h5><pre><code class="hljs js">#App.js<span class="hljs-keyword">constructor</span>(props) &#123;  <span class="hljs-keyword">super</span>(props);  <span class="hljs-keyword">this</span>.state = store.getState();  <span class="hljs-keyword">this</span>.changeInput = <span class="hljs-keyword">this</span>.changeInput.bind(<span class="hljs-keyword">this</span>)  <span class="hljs-keyword">this</span>.clickBtn = <span class="hljs-keyword">this</span>.clickBtn.bind(<span class="hljs-keyword">this</span>)  #需要在constructor(构造函数里)对deleteItem方法进行重新绑定this  <span class="hljs-keyword">this</span>.deleteItem = <span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>)  <span class="hljs-keyword">this</span>.storeChange = <span class="hljs-keyword">this</span>.storeChange.bind(<span class="hljs-keyword">this</span>)  store.subscribe(<span class="hljs-keyword">this</span>.storeChange)&#125;render() &#123;  <span class="hljs-keyword">return</span> (    &lt;AppUI    changeInput=&#123;<span class="hljs-keyword">this</span>.changeInput&#125;inputValue=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;clickBtn=&#123;<span class="hljs-keyword">this</span>.clickBtn&#125;list=&#123;<span class="hljs-keyword">this</span>.state.list&#125;deleteItem=&#123;<span class="hljs-keyword">this</span>.deleteItem&#125;/&gt;  );&#125;</code></pre><pre><code class="hljs js">#AppUI.js<span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> &#123;Button, Input, List&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppUI</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> (            &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>: <span class="hljs-string">'10px'</span>&#125;&#125;&gt;                &lt;div&gt;                    &lt;Input style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">'10px'</span>&#125;&#125;                           onChange=&#123;<span class="hljs-keyword">this</span>.props.changeInput&#125; value=&#123;<span class="hljs-keyword">this</span>.props.inputValue&#125;/&gt;                    &lt;Button type=&#123;<span class="hljs-string">"primary"</span>&#125; onClick=&#123;<span class="hljs-keyword">this</span>.props.clickBtn&#125;&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">                &lt;/</span>div&gt;                &lt;div&gt;                    &lt;List                        bordered                        dataSource=&#123;<span class="hljs-keyword">this</span>.props.list&#125;                        renderItem=&#123;(item, index) =&gt; (                            &lt;List.Item onClick=&#123;() =&gt; <span class="hljs-keyword">this</span>.props.deleteItem(index)&#125;&gt;&#123;item&#125;&lt;<span class="hljs-regexp">/List.Item&gt;</span><span class="hljs-regexp">                        )&#125;</span><span class="hljs-regexp">                    /</span>&gt;                &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AppUI;</code></pre><p>需要注意的是在<code>List</code>组件的删除功能,需要用箭头函数的形式，代替以前方法，并在箭头函数里使用属性的方法，调用出啊你过来的方法。</p><pre><code class="hljs js">&lt;List    bordered    dataSource=&#123;<span class="hljs-keyword">this</span>.props.list&#125;    renderItem=&#123;(item,index)=&gt;<span class="hljs-function">(<span class="hljs-params">&lt;List.Item onClick=&#123;(</span>)=&gt;</span>&#123;<span class="hljs-keyword">this</span>.props.deleteItem(index)&#125;&#125;&gt;&#123;item&#125;&lt;<span class="hljs-regexp">/List.Item&gt;)&#125;</span><span class="hljs-regexp">/</span>&gt;</code></pre><h4 id="13-Redux中的无状态组件"><a href="#13-Redux中的无状态组件" class="headerlink" title="13.Redux中的无状态组件"></a>13.Redux中的无状态组件</h4><ol><li>首先我们不在需要引入React中的<code>{ Component }</code>，删除就好。</li><li>然后些一个<code>TodoListUI</code>函数,里边只返回<code>JSX</code>的部分就好，这步可以复制。</li><li>函数传递一个<code>props</code>参数，之后修改里边的所有<code>props</code>，去掉<code>this</code>。</li></ol><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> &#123;Button, Input, List&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'antd/dist/antd.css'</span><span class="hljs-keyword">const</span> AppUI = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> (        &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>: <span class="hljs-string">'10px'</span>&#125;&#125;&gt;            &lt;div&gt;                &lt;Input style=&#123;&#123;<span class="hljs-attr">width</span>: <span class="hljs-string">'250px'</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">'10px'</span>&#125;&#125;                       onChange=&#123;props.changeInput&#125; value=&#123;props.inputValue&#125;/&gt;                &lt;Button type=&#123;<span class="hljs-string">"primary"</span>&#125; onClick=&#123;props.clickBtn&#125;&gt;添加&lt;<span class="hljs-regexp">/Button&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;            &lt;div&gt;                &lt;List                    bordered                    dataSource=&#123;props.list&#125;                    renderItem=&#123;(item, index) =&gt; (                        &lt;List.Item onClick=&#123;() =&gt; props.deleteItem(index)&#125;&gt;&#123;item&#125;&lt;<span class="hljs-regexp">/List.Item&gt;</span><span class="hljs-regexp">                    )&#125;</span><span class="hljs-regexp">                /</span>&gt;            &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AppUI;</code></pre><h4 id="14-Axios异步获取list数据"><a href="#14-Axios异步获取list数据" class="headerlink" title="14.Axios异步获取list数据"></a>14.Axios异步获取list数据</h4><p>利用easy-mock模拟数据</p><blockquote><pre><code class="hljs js">https:<span class="hljs-comment">//www.easy-mock.com/mock/5f96cc6134c55d14fda96ea1/example/query</span>#自定义返回数据格式&#123;  <span class="hljs-string">"success"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-string">"data"</span>: &#123;    <span class="hljs-string">"list"</span>: [      <span class="hljs-string">"test1"</span>,      <span class="hljs-string">"test2"</span>,      <span class="hljs-string">"test3"</span>    ]  &#125;&#125;</code></pre></blockquote><p>安装并使用Axios</p><pre><code class="hljs shell">cnpm install --save axios</code></pre><p>在App.js中引入axios，并在组件中声明周期函数</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>#声明周期函数 componentDidMountcomponentDidMount()&#123;    axios.get(<span class="hljs-string">'https://www.easy-mock.com/mock/5f96cc6134c55d14fda96ea1/example/query'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(res)    &#125;)&#125;</code></pre><p>将数据渲染传递给list，首先我们需要在store/actionCreators.js文件中，引入action常量，创建一个新的函数，</p><pre><code class="hljs js">#actionTypes.js<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> GET_LIST=<span class="hljs-string">'getList'</span>#actionCreators.js<span class="hljs-keyword">import</span> &#123;GET_LIST&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionTypes'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getList = <span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> (&#123;    type: GET_LIST,    list&#125;)</code></pre><p>然后在App.js中引入函数，并将数据通过store.dispatch传递list值</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;getList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/actionCreators'</span>componentDidMount() &#123;  Axios.get(<span class="hljs-string">'https://www.easy-mock.com/mock/5f96cc6134c55d14fda96ea1/example/query'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(res)    store.dispatch(getList(res.data.data.list))  &#125;)&#125;</code></pre><p>最后在reducer.js中将值赋给list</p><pre><code class="hljs js">#引入action常量<span class="hljs-keyword">import</span> &#123;GET_LIST&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionTypes'</span>#创建action事件<span class="hljs-keyword">if</span> (action.type === GET_LIST) &#123;  <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<span class="hljs-comment">//深度拷贝statec</span>  newState.list=action.list  <span class="hljs-keyword">return</span> newState;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11 Redux认识</title>
    <link href="/2020/10/13/32%20Redux%E8%AE%A4%E8%AF%86/"/>
    <url>/2020/10/13/32%20Redux%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1-Redux介绍"><a href="#1-Redux介绍" class="headerlink" title="1.Redux介绍"></a>1.Redux介绍</h4><p>Redux是一个用来管理管理数据状态和UI状态的JavaScript应用工具（数据流框架）。随着JavaScript单页应用（SPA）开发日趋复杂，JavaScript需要管理比任何时候都要多的state（状态），Redux就是降低管理难度的。（Redux支持React，Angular、jQuery甚至纯JavaScript）</p><p><img src="https://img-blog.csdnimg.cn/20201013225228569.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>从以上图可以看出，Redux可以将数据先放到数据仓库（store-公用状态存储空间）中，在store中可以统一管理状态，我们用到什么组件，就直接去store中寻找什么组件。如果途中的Reducers想改变状态，只需要改变store中的状态，然后其他组件就会自动进行改变。</p><h4 id="2-Redux工作流程"><a href="#2-Redux工作流程" class="headerlink" title="2.Redux工作流程"></a>2.Redux工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20201013225228569.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如上图所示，<em>React Components</em>就是我们在浏览器中直接看到的渲染页面，比如我们在页面上需要进行点击操作，而这个操作就是<em>Action Creators</em>，当我们执行该点击操作时，Redux就会执行Store对象下的<em>Reducers</em>函数，Reducers会对该操作进行逻辑上的处理，然后形成一个新的数据，将其存到Store中。当Store中的数据发生变化时，<em>React Components</em>视图层也就会发生更新。</p>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10 React高级-生命周期</title>
    <link href="/2020/10/09/31%20React%E9%AB%98%E7%BA%A7-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/10/09/31%20React%E9%AB%98%E7%BA%A7-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="1-React生命周期图"><a href="#1-React生命周期图" class="headerlink" title="1.React生命周期图"></a>1.React生命周期图</h4><p><img src="https://img-blog.csdnimg.cn/20201009201912289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>通过这张图可以看到React声明周期的四大阶段：</p><blockquote><ol><li><code>Initialization</code>:初始化阶段。</li><li><code>Mounting</code>: 挂在阶段。</li><li><code>Updation</code>: 更新阶段。</li><li><code>Unmounting</code>: 销毁阶段</li></ol></blockquote><h4 id="2-什么是生命周期函数"><a href="#2-什么是生命周期函数" class="headerlink" title="2.什么是生命周期函数"></a>2.什么是生命周期函数</h4><blockquote><p>生命周期函数指在某一个时刻组件会自动调用执行的函数</p></blockquote><ul><li><code>constructor</code>不算生命周期函数。</li></ul><p><code>constructor</code>叫构造函数，它是ES6的基本语法。虽然它和生命周期函数的性质一样，但不能认为是生命周期函数。</p><p>但是你要心里把它当成一个生命周期函数，我个人把它看成React的<code>Initialization</code>阶段，定义属性（props）和状态(state)。</p><h4 id="3-Mounting阶段"><a href="#3-Mounting阶段" class="headerlink" title="3.Mounting阶段"></a>3.Mounting阶段</h4><p>Mounting阶段叫挂载阶段，伴随着整个虚拟DOM的生成，它里边有三个小的生命周期函数，分别是：</p><ol><li><code>componentWillMount</code> : 在组件即将被挂载到页面的时刻执行。</li><li><code>render</code> : 页面state或props发生变化时执行。</li><li><code>componentDidMount</code> : 组件挂载完成时被执行。</li></ol><p><strong>componentWillMount</strong>代码</p><pre><code class="hljs js">componentWillMount()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'componentWillMount----组件将要挂载到页面的时刻'</span>)&#125;</code></pre><p><strong>componentDidMount</strong>代码</p><pre><code class="hljs js">componentDidMount()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'componentDidMount----组件挂载完成的时刻执行'</span>)&#125;</code></pre><p><strong>render</strong>代码</p><pre><code class="hljs js">render()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'render---组件挂载中.......'</span>)&#125;</code></pre><p>这时候我们查看一下控制台，会为我们打出如下提示：</p><pre><code class="hljs s">componentWillMount----组件将要挂载到页面的时刻执行render----开始挂载渲染componentDidMount----组件挂载完成的时刻执行</code></pre><p>这也是生命周期的顺序。有小伙伴会问我，这个函数书写有顺序吗?哪个在前？哪个在后？其实是没有顺序的，你可以随便改动他们的顺序。</p><p><strong>注意的问题</strong></p><p><code>componentWillMount</code>和<code>componentDidMount</code>这两个生命周期函数，只在页面刷新时执行一次，而<code>render</code>函数是只要有state和props变化就会执行。</p><h4 id="4-Updation阶段"><a href="#4-Updation阶段" class="headerlink" title="4.Updation阶段"></a>4.Updation阶段</h4><p><code>Updation</code>阶段，就是组件发生改变的更新阶段，它有两个基本部分组成，一个是<code>props</code>属性改变，一个是<code>state</code>状态改变。它里边有四个小的生命周期函数，分别是：</p><ol><li><code>shouldComponentUpdate</code> : 函数会在组件更新之前，自动被执行。</li><li><code>componentWillUpdate</code> : <code>componentWillUpdate</code>在组件更新之前，但<code>shouldComponenUpdate</code>之后被执行。</li><li><code>componentDidUpdate</code> : 在组件更新之后执行，它是组件更新的最后一个环节。</li><li><code>componentWillReceiveProps</code>：子组件接收到父组件传递过来的参数，父组件render函数重新被执行后执行。</li></ol><p>1.<code>shouldComponentUpdate</code>函数会在组件发生变化之前执行。</p><pre><code class="hljs javascript">shouldComponentUpdate()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1-shouldComponentUpdate---组件发生改变前执行'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><p>它要求返回一个布尔类型的结果，必须有返回值。</p><p>如果返回是false，该组件就不会进行更新。true反之。</p><p>2.<code>componentWillUpdate</code>函数会在组件发生变化之前执行，但在shouldComponentUpdate之后被执行，如果shouldComponentUpdate返回的是false，该函数就不会被执行。</p><pre><code class="hljs js"><span class="hljs-comment">//shouldComponentUpdate返回true才会被执行。</span>componentWillUpdate()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2-componentWillUpdate---组件更新前，shouldComponentUpdate函数之后执行'</span>)&#125;</code></pre><p>3.<code>componentDidUpdate</code>在组件发生变化之后执行，它是组件更新的最后一个环节。</p><pre><code class="hljs javascript">componentDidUpdate()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'3-componentDidUpdate----组件更新之后执行'</span>)&#125;</code></pre><p>最后我们可以看到控制台输出的结果如下：</p><pre><code class="hljs ada"><span class="hljs-number">1</span>-shouldComponentUpdate<span class="hljs-comment">---组件发生改变前执行</span><span class="hljs-number">2</span>-componentWillUpdate<span class="hljs-comment">---组件更新前，shouldComponentUpdate函数之后执行</span><span class="hljs-number">3</span>-render<span class="hljs-comment">----开始挂载渲染</span><span class="hljs-number">4</span>-componentDidUpdate<span class="hljs-comment">----组件更新之后执行</span></code></pre><p>4.<code>componentWillReceiveProps</code>函数式在子组件接收到父组件传递过来的参数，父组件render函数重新被执行，才会被执行。</p><ul><li>也就是说这个组件第一次存在于Dom中，函数是不会被执行的;</li><li>如果已经存在于Dom中，函数才会被执行。</li></ul><pre><code class="hljs javascript">componentWillReceiveProps()&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child - componentWillReceiveProps'</span>)&#125;</code></pre><h4 id="5-Unmounting阶段"><a href="#5-Unmounting阶段" class="headerlink" title="5.Unmounting阶段"></a>5.Unmounting阶段</h4><p>Unmounting阶段就是在销毁阶段执行的生命周期函数。</p><p>1.shouldComponentUpdate函数：是在组件从页面删除的时候被执行。</p><pre><code class="hljs javascript"><span class="hljs-comment">//当组件从页面中删除的时候执行</span>componentWillUnmount()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child - componentWillUnmount'</span>)&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201009201924364.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09 React高级-PropTypes校验传递值及ref的使用</title>
    <link href="/2020/10/09/30%20React%E9%AB%98%E7%BA%A7-PropTypes%E6%A0%A1%E9%AA%8C%E4%BC%A0%E9%80%92%E5%80%BC%E5%8F%8Aref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/09/30%20React%E9%AB%98%E7%BA%A7-PropTypes%E6%A0%A1%E9%AA%8C%E4%BC%A0%E9%80%92%E5%80%BC%E5%8F%8Aref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="1-PropTypes简单使用"><a href="#1-PropTypes简单使用" class="headerlink" title="1.PropTypes简单使用"></a>1.PropTypes简单使用</h4><p>在<code>Xiaojiejie.js</code>组件里传递了4个值，有字符串，有数字，有方法，这些都是可以使用<code>PropTypes</code>限制的。在使用需要先引入<code>PropTypes</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span></code></pre><p>引入后，就可以在组件的下方进行引用了，需要注意的是子组件的最下面（不是类里边）。</p><pre><code class="hljs js"><span class="hljs-comment">//校验传递值</span>SmailSmailGirlItem.propTypes = &#123;  <span class="hljs-comment">//content:'默认值'</span>    content: PropTypes.string,    index: PropTypes.number.isRequired, <span class="hljs-comment">//isRequired 必传，不传会报错</span>    deleteItem: PropTypes.func&#125;</code></pre><h4 id="2-ref的使用方法"><a href="#2-ref的使用方法" class="headerlink" title="2.ref的使用方法"></a>2.ref的使用方法</h4><h5 id="2-1-代替原来的e-target-value"><a href="#2-1-代替原来的e-target-value" class="headerlink" title="2.1.代替原来的e.target.value"></a>2.1.代替原来的e.target.value</h5><p>以前的案例中，我们写了下面的代码，使用了<code>e.target</code>，这并不直观，也不好看。这种情况我们可以使用<code>ref</code>来进行解决。</p><pre><code class="hljs javascript">inputChange(e)&#123;    <span class="hljs-keyword">this</span>.setState(&#123;        inputValue:e.target.value    &#125;)&#125;</code></pre><p>如果要使用<code>ref</code>来进行，需要现在<code>JSX</code>中进行绑定， 绑定时最好使用ES6语法中的箭头函数，这样可以简洁明了的绑定DOM元素。</p><pre><code class="hljs jsx">&lt;input     value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;     onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125;    <span class="hljs-comment">//关键代码——----------start</span>    ref=&#123;(input)=&gt;&#123;<span class="hljs-keyword">this</span>.input=input&#125;&#125;    <span class="hljs-comment">//关键代码------------end</span>    /&gt;</code></pre><p>绑定后可以把上边的类改写成如下代码:</p><pre><code class="hljs js">inputChange()&#123;    <span class="hljs-keyword">this</span>.setState(&#123;        inputValue:<span class="hljs-keyword">this</span>.input.value    &#125;)&#125;</code></pre><p>这就使我们的代码变得语义化和优雅的多。但是就我个人的经验来讲，我是不建议用<code>ref</code>这样操作的，因为<code>React</code>的是数据驱动的，所以用ref会出现各种问题。</p><h5 id="2-2-ref使用中的坑"><a href="#2-2-ref使用中的坑" class="headerlink" title="2.2.ref使用中的坑"></a>2.2.<code>ref</code>使用中的坑</h5><p>比如现在我们要用ref绑定取得要服务的数量，可以先用<code>ref</code>进行绑定。</p><pre><code class="hljs jsx">&lt;ul ref=&#123;(ul)=&gt;&#123;<span class="hljs-keyword">this</span>.ul=ul&#125;&#125;&gt;    &#123;        <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;            <span class="hljs-keyword">return</span> (                &lt;SmailSmailGirl                 key=&#123;index+item&#125;                  content=&#123;item&#125;                index=&#123;index&#125;                deleteItem=&#123;<span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>)&#125;                /&gt;            )        &#125;)    &#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>绑定后可以在<code>addList()</code>方法中，获取当前<code>&lt;div&gt;</code>的值.</p><pre><code class="hljs js"> addList()&#123;    <span class="hljs-keyword">this</span>.setState(&#123;        list:[...this.state.list,<span class="hljs-keyword">this</span>.state.inputValue],        inputValue:<span class="hljs-string">''</span>    &#125;)    <span class="hljs-comment">//关键代码--------------start</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.ul.querySelectorAll(<span class="hljs-string">'div'</span>).length)    <span class="hljs-comment">//关键代码--------------end</span>&#125;</code></pre><p>这时候你打开控制台，点击添加服务按钮，你会返现数量怎么少一个？（就是这个坑），其实这个坑是因为React中更多<code>setState</code>是一个异步函数所造成的。也就是这个<code>setState</code>，代码执行是有一个时间的，如果你真的想了解清楚，你需要对什么是虚拟DOM有一个了解。简单的说，就是因为是异步，还没等虚拟Dom渲染，我们的<code>console.log</code>就已经执行了。</p><p>那这个代码怎么编写才会完全正常那，其实<code>setState</code>方法提供了一个回调函数，也就是它的第二个函数。下面这样写就可以实现我们想要的方法了。</p><pre><code class="hljs js">addList()&#123;    <span class="hljs-keyword">this</span>.setState(&#123;        list:[...this.state.list,<span class="hljs-keyword">this</span>.state.inputValue],        inputValue:<span class="hljs-string">''</span>        <span class="hljs-comment">//关键代码--------------start</span>    &#125;,()=&gt;&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.ul.querySelectorAll(<span class="hljs-string">'div'</span>).length)    &#125;)    <span class="hljs-comment">//关键代码--------------end</span>&#125;</code></pre><p>现在到浏览器中查看代码，就完全正常了。</p>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08 React进阶-单项数据流和其他</title>
    <link href="/2020/10/09/29%20React%E8%BF%9B%E9%98%B6-%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%85%B6%E4%BB%96/"/>
    <url>/2020/10/09/29%20React%E8%BF%9B%E9%98%B6-%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h4 id="1-单项数据流"><a href="#1-单项数据流" class="headerlink" title="1.单项数据流"></a>1.单项数据流</h4><p>React的特性中有一个概念叫做“单项数据流”，以以上练习的Demo讲解。比如我们在父组件中可以直接把<code>this.state.list</code>传递过来。</p><pre><code class="hljs js">&lt;ul&gt;    &#123;        <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;            <span class="hljs-keyword">return</span> (                &lt;SmailSmailGirl                 key=&#123;index+item&#125;                  content=&#123;item&#125;                index=&#123;index&#125;                list=&#123;<span class="hljs-keyword">this</span>.state.list&#125;                deleteItem=&#123;<span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>)&#125;                /&gt;            )        &#125;)    &#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>其实这样传是没有问题的，问题是你只能使用这个值，而不能修改这个值，如果你修改了，比如我们把代码写成这样：</p><pre><code class="hljs js">handleClick()&#123;    <span class="hljs-comment">//关键代码——---------start</span>    <span class="hljs-keyword">this</span>.props.list=[]    <span class="hljs-comment">//关键代码-----------end</span>    <span class="hljs-keyword">this</span>.props.deleteItem(<span class="hljs-keyword">this</span>.props.index)&#125;</code></pre><p>就会报下面的错误；</p><pre><code class="hljs js"><span class="hljs-built_in">TypeError</span>: Cannot assign to read only property <span class="hljs-string">'list'</span> <span class="hljs-keyword">of</span> object <span class="hljs-string">'#&lt;Object&gt;'</span></code></pre><p>意思就是<code>list</code>是只读的，单项数据流。</p><h4 id="2-和其他框架配合使用"><a href="#2-和其他框架配合使用" class="headerlink" title="2.和其他框架配合使用"></a>2.和其他框架配合使用</h4><p><code>React</code>和<code>jquery</code>能一起使用吗？</p><p>答案：是可以的，React其实可以模块化和组件化开发。看<code>/public/index.html</code>文件，代码如下：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"%PUBLIC_URL%/favicon.ico"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"theme-color"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"#000000"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"manifest"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"%PUBLIC_URL%/manifest.json"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>    <span class="hljs-comment">&lt;!--关键代码start--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-comment">&lt;!--关键代码end--&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>其实React只对这一个<code>&lt;div&gt;</code>,外边的其他DOM并不受任何影响，比如我们在它的下方再写一个<code>&lt;div&gt;</code>，然后查看效果。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span>今天过的好开心，服务很满意！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>你可以在其他的div里加入任何内容，但是这种情况很少，我也不建议这么使用。</p><h4 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.函数式编程"></a>3.函数式编程</h4><p>函数式编程的好处是什么？</p><ol><li>函数式编程让我们的代码更清晰，每个功能都是一个函数。</li><li>函数式编程为我们的代码测试代理了极大的方便，更容易实现前端自动化测试。</li></ol><p>React框架也是函数式编程，所以说优势在大型多人开发的项目中会更加明显，让配合和交流都得心应手。</p><h4 id="4-浏览器调试工具"><a href="#4-浏览器调试工具" class="headerlink" title="4.浏览器调试工具"></a>4.浏览器调试工具</h4><p>React developer tools</p>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07 React进阶-组件拆分及父子间传值</title>
    <link href="/2020/10/09/28%20React%E8%BF%9B%E9%98%B6-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E5%8F%8A%E7%88%B6%E5%AD%90%E9%97%B4%E4%BC%A0%E5%80%BC/"/>
    <url>/2020/10/09/28%20React%E8%BF%9B%E9%98%B6-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E5%8F%8A%E7%88%B6%E5%AD%90%E9%97%B4%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h4 id="1-新建服务菜单组件"><a href="#1-新建服务菜单组件" class="headerlink" title="1.新建服务菜单组件"></a>1.新建服务菜单组件</h4><p>在src目录下，新建一个组件SmailSmailGirlItem.js。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirlItem</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;     render() &#123;         <span class="hljs-keyword">return</span> (             &lt;div&gt;小姐姐&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">         );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default SmailSmailGirlItem;</span></code></pre><p>然后我们在SmailSmailGirl.js文件中引入该子组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> SmailSmailGirlItem <span class="hljs-keyword">from</span> <span class="hljs-string">'./SmailSmailGirlItem'</span></code></pre><p>并修改组件内容。</p><pre><code class="hljs js">&lt;ul&gt;  &#123;  <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> (      <span class="hljs-comment">//----------------关键修改代码----start</span>      &lt;div&gt;      &lt;SmailSmailGirlItem key=&#123;index+item&#125;/&gt;      &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      /</span><span class="hljs-regexp">/----------------关键修改代码----end</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">  &#125;)</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">&lt;/u</span>l&gt;</code></pre><h4 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h4><p>这里我们使用组件属性的形式父组件给子组件传值。在SmailSmailGirlItem组件中加入content属性，然后给属性传递{item}，这样就实现了父组件向子组件传值。</p><pre><code class="hljs js">&lt;SmailSmailGirlItem content=&#123;item&#125; /&gt;</code></pre><p>然后我们在子组件中，通过this.props.属性名的形式来接收该值。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirlItem</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;     render() &#123;         <span class="hljs-keyword">return</span> (             &lt;div&gt;&#123;<span class="hljs-keyword">this</span>.props.content&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">         );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default SmailSmailGirlItem;</span></code></pre><p>需要记住：父组件向子组件传递内容，靠属性的形式传递。</p><h4 id="3-子组件向父组件传递数据"><a href="#3-子组件向父组件传递数据" class="headerlink" title="3.子组件向父组件传递数据"></a>3.子组件向父组件传递数据</h4><p>现在我们需要点击组件中的菜单项后，删除该菜单项。</p><p>首先先来绑定点击事件，我们在SmailSmailGirlItem组件中绑定handleClick方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirlItem</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;     render() &#123;         <span class="hljs-keyword">return</span> (             &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;&#123;<span class="hljs-keyword">this</span>.props.content&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">         );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    handleClick()&#123;</span><span class="hljs-regexp">      console.log('你触发了点击事件！')</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default SmailSmailGirlItem;</span></code></pre><p>绑定成功之后，我们需要通过操作子组件删除父组件中的数据。但React明确说明子组件不能操作父组件中的数据，所以我们需要借助一个父组件中的方法，来修改内容，在这里我们需要在子组件中调用父组件中的deleteItem方法。</p><p>首先我们在父组件中添加index下标.</p><pre><code class="hljs js">&lt;ul&gt;  &#123;  <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> (      <span class="hljs-comment">//----------------关键修改代码----start</span>      &lt;div&gt;      &lt;SmailSmailGirlItem key=&#123;index+item&#125; index=&#123;index&#125;/&gt;      &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      /</span><span class="hljs-regexp">/----------------关键修改代码----end</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">  &#125;)</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">&lt;/u</span>l&gt;</code></pre><p>然后在子组件中获取到下标值。</p><pre><code class="hljs js">handleClick()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.props.index)&#125;</code></pre><p>这时候预览一下，你会发现点击后报错，错误还是我们的老朋友,没有<code>bind(this)</code>。那可以用以前的老方法绑定this。</p><pre><code class="hljs js"><span class="hljs-keyword">return</span> (     &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;        &#123;<span class="hljs-keyword">this</span>.props.content&#125;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">);</span></code></pre><p>可以通过以上方式解决，但是构造函数中绑定性能会高一些，特别是在高级组件开发中，会有很大的作用。</p><p><code>constructor</code>绑定this方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirlItem</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;   <span class="hljs-comment">//--------------主要代码--------start</span>   <span class="hljs-keyword">constructor</span>(props)&#123;       <span class="hljs-keyword">super</span>(props)       <span class="hljs-keyword">this</span>.handleClick=<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)   &#125;   <span class="hljs-comment">//--------------主要代码--------end</span>    render() &#123;         <span class="hljs-keyword">return</span> (             &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;&#123;<span class="hljs-keyword">this</span>.props.content&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">         );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    handleClick()&#123;</span><span class="hljs-regexp">      console.log('你触发了点击事件！')</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default SmailSmailGirlItem;</span></code></pre><p>如果子组件要调用父组件方法，其实和传递数据差不多，只要在组件调用时，把方法传递给子组件就可以了，记得这里也要进行<code>this</code>的绑定，如果不绑定子组件是没办法找到这个父组件的方法的。</p><pre><code class="hljs js">&lt;ul&gt;  &#123;  <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> (      <span class="hljs-comment">//----------------关键修改代码----start</span>      &lt;div&gt;      &lt;SmailSmailGirlItem key=&#123;index+item&#125; index=&#123;index&#125; deleteItem=&#123;<span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>)&#125;/&gt;      &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      /</span><span class="hljs-regexp">/----------------关键修改代码----end</span><span class="hljs-regexp">    )</span><span class="hljs-regexp">  &#125;)</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">&lt;/u</span>l&gt;</code></pre><p>传递后，在<code>SmailSmailGirlItem</code>组件里就可以直接使用，代码如下：</p><pre><code class="hljs js">handleClick()&#123;    <span class="hljs-keyword">this</span>.props.deleteItem(<span class="hljs-keyword">this</span>.props.index)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06 React进阶-JSX防踩坑的几个地方</title>
    <link href="/2020/10/08/27%20React%E8%BF%9B%E9%98%B6-JSX%E9%98%B2%E8%B8%A9%E5%9D%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9/"/>
    <url>/2020/10/08/27%20React%E8%BF%9B%E9%98%B6-JSX%E9%98%B2%E8%B8%A9%E5%9D%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1-JSX代码注释"><a href="#1-JSX代码注释" class="headerlink" title="1.JSX代码注释"></a>1.JSX代码注释</h4><p>我第一次写JSX的注释，是直接像以前js注释写的，当然这样写是不对的。</p><pre><code class="hljs js">&lt;Fragment&gt;    <span class="hljs-comment">//第一次写注释，这个是错误的</span>    &lt;div&gt;        &lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;        &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;&lt;<span class="hljs-regexp">/Fragment&gt;</span></code></pre><p>JSX注释，有以下两种写法。</p><pre><code class="hljs js">&lt;Fragment&gt;    &#123;<span class="hljs-comment">/* 正确注释的写法 */</span>&#125;&#123;        <span class="hljs-comment">//正确注释的写法 </span>    &#125;    &lt;div&gt;        &lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;        &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;&lt;<span class="hljs-regexp">/Fragment&gt;</span></code></pre><p>推荐第一种注释。</p><h4 id="2-JSX中的class陷阱"><a href="#2-JSX中的class陷阱" class="headerlink" title="2.JSX中的class陷阱"></a>2.JSX中的class陷阱</h4><p>比如要给朴素单纯的界面，加入黄色成分，让我们的文本框又粗又黄。我们先来错误演示。</p><p>第一步：先写一个CSS样式文件，在<code>src</code>目录下，新建一个<code>style.css</code>的样式文件。</p><pre><code class="hljs css"><span class="hljs-selector-class">.input</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">3px</span> solid <span class="hljs-number">#ae7000</span>&#125;</code></pre><p>第二步：在<code>Xiaojiejie.js</code>里引入，先用<code>import</code>进行引入</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span></code></pre><p>第三部：给<code>JSX</code>加入class,注意下面的代码是错误的。</p><pre><code class="hljs jsx">&lt;input <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"input"</span> value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;</code></pre><p>虽然现在页面是可以正常显示结果的，但是你代开浏览器控制台会发现<code>Warning</code>警告。</p><pre><code class="hljs jsx">index.js:<span class="hljs-number">1437</span> Warning: Invalid DOM property <span class="hljs-string">`class`</span>. Did you mean <span class="hljs-string">`className`</span>?    <span class="hljs-keyword">in</span> input (at SmailSmailGirl.js:<span class="hljs-number">19</span>)    <span class="hljs-keyword">in</span> div (at SmailSmailGirl.js:<span class="hljs-number">18</span>)    <span class="hljs-keyword">in</span> Xiaojiejie (at src/index.js:<span class="hljs-number">5</span>)</code></pre><p>意思就是要把<code>class</code>换成<code>className</code>，它是防止和<code>js</code>中的<code>class</code>类名 冲突，所以要求换掉。这也算是一个小坑吧。</p><h4 id="3-JSX中的html解析问题"><a href="#3-JSX中的html解析问题" class="headerlink" title="3.JSX中的html解析问题"></a>3.JSX中的html解析问题</h4><p>如果想在文本框里输入一个<code>&lt;h1&gt;</code>标签，并进行渲染。默认是不会生效的，只会把<code>&lt;h1&gt;</code>标签打印到页面上，这并不是我想要的。如果工作中有这种需求，可以使用<code>dangerouslySetInnerHTML</code>属性解决。具体代码如下：</p><pre><code class="hljs jsx">&lt;ul&gt;    &#123;        <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;            <span class="hljs-keyword">return</span> (                &lt;li                     key=&#123;index+item&#125;                    onClick=&#123;<span class="hljs-keyword">this</span>.deleteItem.bind(<span class="hljs-keyword">this</span>,index)&#125;                    dangerouslySetInnerHTML=&#123;&#123;<span class="hljs-attr">__html</span>:item&#125;&#125;                &gt;                &lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">            )</span><span class="hljs-regexp">        &#125;)</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&lt;/u</span>l&gt;</code></pre><p>上面的代码就可以实现<code>html</code>格式的输出。</p><h4 id="4-JSX中标签的坑"><a href="#4-JSX中标签的坑" class="headerlink" title="4.JSX中标签的坑"></a>4.JSX中<label>标签的坑</h4><p>JSX中<code>&lt;label&gt;</code>的坑，也算是比较大的一个坑，label是<code>html</code>中的一个辅助标签，也是非常有用的一个标签。</p><p>先看下面的代码，我们在文本框前面加入一个<code>&lt;label&gt;</code>。</p><pre><code class="hljs jsx">&lt;div&gt;    &lt;label&gt;加入服务：&lt;<span class="hljs-regexp">/label&gt;</span><span class="hljs-regexp">    &lt;input className="input" value=&#123;this.state.inputValue&#125; onChange=&#123;this.inputChange.bind(this)&#125; /</span>&gt;    &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;</code></pre><p>这时候想点击“加入服务”直接可以激活文本框，方便输入。按照<code>html</code>的原思想，是直接加ID就可以了。代码如下：</p><pre><code class="hljs jsx">&lt;div&gt;    &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">"jspang"</span>&gt;加入服务：&lt;<span class="hljs-regexp">/label&gt;</span><span class="hljs-regexp">    &lt;input id="jspang" className="input" value=&#123;this.state.inputValue&#125; onChange=&#123;this.inputChange.bind(this)&#125; /</span>&gt;    &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;</code></pre><p>这时候你浏览效果虽然可以正常，但<code>console</code>里还是有红色警告提示的。大概意思是不能使用<code>for</code>.它容易和javascript里的for循环混淆，会提示你使用<code>htmlfor</code>。</p><pre><code class="hljs jsx">&lt;div&gt;    &lt;label htmlFor=<span class="hljs-string">"jspang"</span>&gt;加入服务：&lt;<span class="hljs-regexp">/label&gt;</span><span class="hljs-regexp">    &lt;input id="jspang" className="input" value=&#123;this.state.inputValue&#125; onChange=&#123;this.inputChange.bind(this)&#125; /</span>&gt;    &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;</code></pre><p>这时候代码就正确了，可以实现点击<code>&lt;label&gt;</code>后,激活<code>&lt;input&gt;</code>标签了。</p>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05 React实例1-实现删除操作</title>
    <link href="/2020/10/08/26%20React%E5%AE%9E%E4%BE%8B1-%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/10/08/26%20React%E5%AE%9E%E4%BE%8B1-%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-组件下标传递"><a href="#1-组件下标传递" class="headerlink" title="1.组件下标传递"></a>1.组件下标传递</h4><p>传递下标就要有事件产生，先来绑定一个双击事件。我们在li标签上绑定一个onClick事件，执行删除操作。</p><pre><code class="hljs js">&lt;ul&gt;    &#123;      <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteItem.bind(this,</span> <span class="hljs-attr">index</span>)&#125; <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index</span> + <span class="hljs-attr">item</span>&#125;&gt;</span>&#123;item&#125;&#123;index&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>       &#125;)    &#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><h4 id="2-编写deleteItem方法删除数据"><a href="#2-编写deleteItem方法删除数据" class="headerlink" title="2.编写deleteItem方法删除数据"></a>2.编写deleteItem方法删除数据</h4><p>编写deleteItem方法，并传递index参数</p><pre><code class="hljs js">deleteItem(index) &#123;  <span class="hljs-built_in">console</span>.log(index)  <span class="hljs-keyword">let</span> list = <span class="hljs-keyword">this</span>.state.list  list.splice(index, <span class="hljs-number">1</span>)  <span class="hljs-keyword">this</span>.setState(&#123;    list: list  &#125;)&#125;</code></pre><p>在这里，我们需要注意的坑，React是禁止直接操作state，因为在后期的性能优化上带来很多麻烦。如一下操作，是错误的。</p><pre><code class="hljs js"><span class="hljs-comment">//删除单项服务</span>deleteItem(index)&#123;    <span class="hljs-keyword">this</span>.state.list.splice(index,<span class="hljs-number">1</span>)    <span class="hljs-keyword">this</span>.setState(&#123;        list:<span class="hljs-keyword">this</span>.state.list    &#125;) &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04 React实例1-列表渲染和按钮添加操作</title>
    <link href="/2020/10/08/25%20React%E5%AE%9E%E4%BE%8B1-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8C%89%E9%92%AE%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/10/08/25%20React%E5%AE%9E%E4%BE%8B1-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8C%89%E9%92%AE%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-渲染服务列表"><a href="#1-渲染服务列表" class="headerlink" title="1.渲染服务列表"></a>1.渲染服务列表</h4><p>现在的列表是写死的两个li标签，倘若我们需要将其变成动态的，那我们就需要把这个列表进行数据化，然后通过js代码循环到页面上。</p><pre><code class="hljs js"><span class="hljs-keyword">constructor</span>(props)&#123;    <span class="hljs-keyword">super</span>(props) <span class="hljs-comment">//调用父类的构造函数，固定写法</span>    <span class="hljs-keyword">this</span>.state=&#123;        inputValue:<span class="hljs-string">''</span> ,         <span class="hljs-comment">//----------主要 代码--------start</span>        list:[<span class="hljs-string">'推拿'</span>,<span class="hljs-string">'敲背'</span>]           <span class="hljs-comment">//----------主要 代码--------end</span>    &#125;&#125;</code></pre><p>然后我们进行页面数据渲染。</p><pre><code class="hljs js">render()&#123;    <span class="hljs-keyword">return</span>  (        &lt;Fragment&gt;            &lt;div&gt;                &lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;                &lt;button&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;            &lt;ul&gt;                &#123;                    <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;                      <span class="hljs-keyword">return</span> &lt;li&gt;&#123;item&#125;&lt;li&gt;                    &#125;)                &#125;<span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  </span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>    )&#125;</code></pre><h4 id="2-增加服务选项"><a href="#2-增加服务选项" class="headerlink" title="2.增加服务选项"></a>2.增加服务选项</h4><p>我们先给button按钮绑定一个addList方法</p><pre><code class="hljs js">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.addList.bind(<span class="hljs-keyword">this</span>)&#125;&gt; 增加服务 &lt;<span class="hljs-regexp">/button&gt;</span></code></pre><p>addList代码如下：</p><pre><code class="hljs js"><span class="hljs-comment">//增加服务的按钮响应方法</span>addList()&#123;  <span class="hljs-keyword">this</span>.setState(&#123;    list:[...this.state.list,<span class="hljs-keyword">this</span>.state.inputVal] <span class="hljs-comment">//扩展运算符</span>    <span class="hljs-comment">//把list数组进行了分解，形成了新的数组，然后再进行组合。</span>  &#125;)&#125;</code></pre><h4 id="3-解决key值错误问题"><a href="#3-解决key值错误问题" class="headerlink" title="3.解决key值错误问题"></a>3.解决key值错误问题</h4><p>F12打开浏览器控制台，看见报错，意思是缺少key值。在用map循环时，需要设置一个不同的值，这是react的要求。我们可以暂时使用index+item代替，防止重复。</p><pre><code class="hljs js">&lt;ul&gt;    &#123;        <span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;            <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index+item&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>        &#125;)    &#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03 React实例1-响应式原理和数据绑定</title>
    <link href="/2020/10/08/24%20React%E5%AE%9E%E4%BE%8B1-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/2020/10/08/24%20React%E5%AE%9E%E4%BE%8B1-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h4 id="1-响应式数据绑定"><a href="#1-响应式数据绑定" class="headerlink" title="1.响应式数据绑定"></a>1.响应式数据绑定</h4><p><code>React</code>不建议你直接操作<code>DOM</code>元素，而是要通过数据进行驱动，改变界面中的效果。React会根据数据的变化，自动的帮助你完成界面的改变。所以在写React代码时，你无需关注DOM相关的操作，只需要关注数据的操作就够了。</p><p>现在的需求是增加小姐姐的服务项，就需要先定义数据。数据定义在SmailSmailGirl组件中的构造函数里<code>constructor</code>。</p><pre><code class="hljs js"><span class="hljs-comment">//js的构造函数，由于其他任何函数执行</span><span class="hljs-keyword">constructor</span>(props)&#123;    <span class="hljs-keyword">super</span>(props) <span class="hljs-comment">//调用父类的构造函数，固定写法</span>    <span class="hljs-keyword">this</span>.state=&#123;        inputVal:<span class="hljs-string">''</span> , <span class="hljs-comment">// input中的值</span>        list:[]    <span class="hljs-comment">//服务列表</span>    &#125;&#125;</code></pre><p>在<code>React</code>中的数据绑定和<code>Vue</code>中几乎一样，也是采用<code>字面量</code>(我自己起的名字)的形式，就是使用<code>{}</code>来标注，其实这也算是js代码的一种声明。比如现在我们要把<code>inputVal</code>值绑定到<code>input</code>框中，只要写入下面的代码就可以了。</p><pre><code class="hljs js">&lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputVal&#125; /&gt;</code></pre><h4 id="2-绑定事件"><a href="#2-绑定事件" class="headerlink" title="2.绑定事件"></a>2.绑定事件</h4><p>这时候我们在文本框中输入值，并没有什么变化，这是因为我们绑定了inputVal的值。如果要想改变，需要绑定响应事件，改变inputVal的值。</p><pre><code class="hljs js">&lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputVal&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange&#125;/&gt;</code></pre><p>然后我们在render方法下面，新建一个inputChange方法，如下：</p><pre><code class="hljs js">inputChange(e)&#123;  <span class="hljs-built_in">console</span>.log(e);  <span class="hljs-built_in">console</span>.log(e.target.value) <span class="hljs-comment">//获取响应值</span>  <span class="hljs-comment">//this.state.inputValue=e.target.value; 这种写法是错误的</span>&#125;</code></pre><p>最后一个赋值方式是错误的，程序会直接报错，如以下两个错：</p><p>1.一个是this的指向不对，你需要重新用bind设置一个指向。</p><p>2.另一个是React中改变值需要使用this.setState方法</p><p>第一个错误好解决，直接使用bind进行绑定。</p><pre><code class="hljs js">&lt;input value=&#123;<span class="hljs-keyword">this</span>.state.inputVal&#125; onChange=&#123;<span class="hljs-keyword">this</span>.inputChange.bind(<span class="hljs-keyword">this</span>)&#125;/&gt;</code></pre><p>第二个我们直接使用this.setState方法进行赋值。</p><pre><code class="hljs js">inputChange(e)&#123;<span class="hljs-keyword">this</span>.setState(&#123;    inputVal:e.target.value  &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02 React实例1-新建组件</title>
    <link href="/2020/10/08/23%20React%E5%AE%9E%E4%BE%8B1-%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/10/08/23%20React%E5%AE%9E%E4%BE%8B1-%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-新建组件"><a href="#1-新建组件" class="headerlink" title="1.新建组件"></a>1.新建组件</h4><p>在src目录下新建一个文件SmailSmailGirl.js文件，然后建立一个基本的HTML结构。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;  render()&#123;      <span class="hljs-keyword">return</span> (      &lt;div&gt;           &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span> 增加服务 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">           &lt;ul&gt;</span><span class="hljs-regexp">             &lt;li&gt;头部按摩&lt;/</span>li&gt;             &lt;li&gt;精油推背&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">           &lt;/u</span>l&gt;         &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default SmailSmailGirl</span></code></pre><p>然后在src下创建index.js文件，在入口中引入SmailSmailGirl组件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-keyword">import</span> SmailSmailGirl <span class="hljs-keyword">from</span> <span class="hljs-string">"./SmailSmailGirl"</span>;<span class="hljs-comment">//JSX js+xml 虚拟dom</span>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SmailSmailGirl</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));</code></pre><h4 id="2-组件外层包裹原则"><a href="#2-组件外层包裹原则" class="headerlink" title="2.组件外层包裹原则"></a>2.组件外层包裹原则</h4><p>在SmailSmailGirl.js文件中，我们可以看到以上代码中最外层存在<div>，如果将其去掉就会报错，和Vue一样，最外层必须有一层包裹。</p><h4 id="3-Fragment标签讲解"><a href="#3-Fragment标签讲解" class="headerlink" title="3.Fragment标签讲解"></a>3.Fragment标签讲解</h4><p>假若你的组件布局偏偏不要最外层的标签，那我们可以使用<Fragment>标签，React16已经有所考虑。</p><p>首先我们先引用<Fragment>，需要先进行引入。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;Component,Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span></code></pre><p>然后把最外层的div换成Fragment，如下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;Component,Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmailSmailGirl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    render()&#123;        <span class="hljs-keyword">return</span>  (            &lt;Fragment&gt;           &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span> 增加服务 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">           &lt;ul&gt;</span><span class="hljs-regexp">             &lt;li&gt;头部按摩&lt;/</span>li&gt;             &lt;li&gt;精油推背&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">           &lt;/u</span>l&gt;             &lt;<span class="hljs-regexp">/Fragment&gt;</span><span class="hljs-regexp">        )</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp">export default SmailSmailGirl</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01 ReactJs项目构建</title>
    <link href="/2020/09/16/22%20Reactjs%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/09/16/22%20Reactjs%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="1-通过node环境创建react工程插件"><a href="#1-通过node环境创建react工程插件" class="headerlink" title="1.通过node环境创建react工程插件"></a>1.通过node环境创建react工程插件</h5><pre><code class="hljs shell">npm install -g create-react-app</code></pre><h5 id="2-指定目录创建React工程"><a href="#2-指定目录创建React工程" class="headerlink" title="2.指定目录创建React工程"></a>2.指定目录创建React工程</h5><pre><code class="hljs shell">create-react-app &lt;工程名&gt;</code></pre><h5 id="3-进入目录启动项目"><a href="#3-进入目录启动项目" class="headerlink" title="3.进入目录启动项目"></a>3.进入目录启动项目</h5><pre><code class="hljs shell">cd &lt;工程根目录&gt;yarn start</code></pre><h5 id="4-创建第一个组件"><a href="#4-创建第一个组件" class="headerlink" title="4.创建第一个组件"></a>4.创建第一个组件</h5><p>创建welcome.js</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> Hello, World! <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Welcome</code></pre><p>并将新组件引入到主页面中</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'./logo.svg'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'./App.css'</span>;<span class="hljs-keyword">import</span> Welcome <span class="hljs-keyword">from</span> <span class="hljs-string">'./Welcome'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div className=<span class="hljs-string">"App"</span>&gt;      &lt;header className=<span class="hljs-string">"App-header"</span>&gt;        &lt;img src=&#123;logo&#125; className=<span class="hljs-string">"App-logo"</span> alt=<span class="hljs-string">"logo"</span> /&gt;        &lt;p&gt;          Edit &lt;code&gt;src/App.js&lt;<span class="hljs-regexp">/code&gt; and save to reload.</span><span class="hljs-regexp">        &lt;/</span>p&gt;        &lt;a          className=<span class="hljs-string">"App-link"</span>          href=<span class="hljs-string">"https://reactjs.org"</span>          target=<span class="hljs-string">"_blank"</span>          rel=<span class="hljs-string">"noopener noreferrer"</span>        &gt;          Learn React        &lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">        &lt;Welcome/</span>&gt; &#123;<span class="hljs-comment">/* 引入新组件 */</span>&#125;      &lt;<span class="hljs-regexp">/header&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;  );&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>刷新页面</p><p><img src="https://img-blog.csdnimg.cn/20200916103641452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="启动成功"></p><h5 id="5-打包"><a href="#5-打包" class="headerlink" title="5.打包"></a>5.打包</h5><pre><code class="hljs shell">yarn build</code></pre><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><h6 id="1-目录介绍"><a href="#1-目录介绍" class="headerlink" title="1.目录介绍"></a>1.目录介绍</h6><ul><li><strong>README.md</strong> :对项目的说明。</li><li><strong>package.json</strong>: 这个文件是<code>webpack</code>配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置。</li><li><strong>package-lock.json</strong>：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再<code>npm install</code> 时大家的依赖能保证一致。</li><li><strong>gitignore</strong> : 这个是git的忽略上传的配置文件，比如一会要介绍的<code>node_modules</code>文件夹，就需要配置不上传。</li><li><strong>node_modules</strong> :项目的依赖包。</li><li><strong>public</strong> ：公共文件，里边有公用模板和图标等一些东西。</li><li><strong>src</strong> ： 主要代码编写文件。</li></ul><p>public文件夹介绍</p><ul><li><strong>favicon.ico</strong> : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。</li><li><strong>index.html</strong> : 首页的模板文件，我们可以试着改动一下，就能看到结果。</li><li><strong>mainifest.json</strong>：移动端配置文件。</li></ul><p>src文件夹介绍</p><ul><li><strong>index.js</strong> : 这个就是项目的入口文件。</li><li><strong>index.css</strong> ：这个是<code>index.js</code>里的CSS文件。</li><li><strong>app.js</strong> : 这个文件相当于一个方法模块，也是一个简单的模块化编程。</li><li><strong>serviceWorker.js</strong>: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>2020-10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rancher安装kubernetes报错[etcd] Failed to bring up Etcd Plane [etcd] Etcd Cluster is not healthy</title>
    <link href="/2020/07/08/21%20rancher%E5%AE%89%E8%A3%85kubernetes%E6%8A%A5%E9%94%99%5Betcd%5D%20Failed%20to%20bring%20up%20Etcd%20Plane%20%5Betcd%5D%20Etcd%20Cluster%20is%20not%20healthy/"/>
    <url>/2020/07/08/21%20rancher%E5%AE%89%E8%A3%85kubernetes%E6%8A%A5%E9%94%99%5Betcd%5D%20Failed%20to%20bring%20up%20Etcd%20Plane%20%5Betcd%5D%20Etcd%20Cluster%20is%20not%20healthy/</url>
    
    <content type="html"><![CDATA[<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>个人认为可能服务器上存在以前的k8s内容，通过rancher安装时，并没有覆盖以前的，导致一直报错</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>删除k8s相关文件以及网络，挂载等。</p><p>在每个集群中的主机节点执行该命令，然后重新构建rancher并安装k8s集群。</p><pre><code class="hljs shell">df -h|grep kubelet |awk -F % '&#123;print $2&#125;'|xargs umountsudo rm /var/lib/kubelet/* -rfsudo rm /etc/kubernetes/* -rfsudo rm /etc/cni/* -rfsudo rm /var/lib/rancher/* -rfsudo rm /var/lib/etcd/* -rfsudo rm /var/lib/cni/* -rfsudo rm /opt/cni/* -rfsudo ip link del flannel.1ip link del cni0iptables -F &amp;&amp; iptables -t nat -Fdocker ps -a|awk '&#123;print $1&#125;'|xargs docker rm -fdocker volume ls|awk '&#123;print $2&#125;'|xargs docker volume rmsystemctl restart docker</code></pre><p>可能会有些步骤报执行不成功或错误，其主要目的是为了删除k8s相关文件以及网络，挂载等。</p>]]></content>
    
    
    <categories>
      
      <category>2020-07</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>错误总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Postgresql-12 安装及设置远程访问</title>
    <link href="/2020/07/06/20%20Postgresql-12%20%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <url>/2020/07/06/20%20Postgresql-12%20%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="1-安装（CentOS-7）"><a href="#1-安装（CentOS-7）" class="headerlink" title="1.安装（CentOS 7）"></a>1.安装（CentOS 7）</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">拉取rp包，并install</span>yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm<span class="hljs-meta">#</span><span class="bash">install pg服务</span>yum install postgresql12-server<span class="hljs-meta">#</span><span class="bash">初始化db</span>/usr/pgsql-12/bin/postgresql-12-setup initdb<span class="hljs-meta">#</span><span class="bash">启动服务</span>systemctl enable postgresql-12systemctl start postgresql-12</code></pre><h4 id="2-允许远程访问"><a href="#2-允许远程访问" class="headerlink" title="2.允许远程访问"></a>2.允许远程访问</h4><pre><code class="hljs angelscript">#进入/var/lib/pgsql/<span class="hljs-number">12</span>/data<span class="hljs-number">1.</span>修改postgresql.conf取消#listen_addresses = <span class="hljs-string">'localhost'</span>注释修改为listen_addresses = <span class="hljs-string">'*'</span><span class="hljs-number">2.</span>修改pg_hba.conf# IPv4 local connections:host     all     all                 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>              trust #本地信任访问，密码可有可无host     all     all                 <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>（内网网段）/<span class="hljs-number">24</span>              md5 #内网可访问，密码md5加密，<span class="hljs-number">24</span>是允许网段<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>的所有主机可访问host     all     all                 <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">0</span>                 md5 #允许外网访问，，密码md5加密</code></pre><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h4><h5 id="3-1-关于postgresql-yum安装，目录迁移问题"><a href="#3-1-关于postgresql-yum安装，目录迁移问题" class="headerlink" title="3.1 关于postgresql yum安装，目录迁移问题"></a>3.1 关于postgresql yum安装，目录迁移问题</h5><p>参考：<a href="https://blog.csdn.net/wk1134314305/article/details/79054248" target="_blank" rel="noopener">postgresql目录迁移问题（无需卸载重装）</a></p>]]></content>
    
    
    <categories>
      
      <category>2020-07</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群高可用环境</title>
    <link href="/2020/05/31/19%20Redis%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/05/31/19%20Redis%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h4 id="一、Redis分布式锁实现思路"><a href="#一、Redis分布式锁实现思路" class="headerlink" title="一、Redis分布式锁实现思路"></a>一、Redis分布式锁实现思路</h4><blockquote><p>Redis实现分布式锁基于SetNx命令，因为在redis中key是保证是唯一的。所以当多个线程同时创建setNx时，只要谁能够创建成功谁就能获取到锁。</p><p>Set命令：每次set时，可以修改原来旧值；</p><p>SetNx命令：每次SetNx检查key是否已经存在，如果已经存在的话就不会执行任何操作，返回0；反之，新增该key。</p><p>获取锁的时候：当多个线程同时创建SetNx key，只要谁能够创建成功谁就能够获取到锁。</p><p>释放锁：可以对该key设置一个有效期可以避免死锁的现象。</p></blockquote><h4 id="二、Zookeeper实现分布式锁思路"><a href="#二、Zookeeper实现分布式锁思路" class="headerlink" title="二、Zookeeper实现分布式锁思路"></a>二、Zookeeper实现分布式锁思路</h4><blockquote><p>Zookeeper实现分布式锁核心采用临时节点+事件通知，因为Zookeeper节点路径是保证全局唯一的，当多个线程同时创建该临时节点，只要谁能够创建成功谁就能获取到锁。</p><p>获取锁：当多个线程同时创建该临时节点，只要谁能够创建成功谁就能够获取到锁。 </p><p>释放锁：关闭当前Session连接，自动的删除当前的zk节点路径，其他线程重新进入到获取锁阶段。</p></blockquote><h4 id="三、分布式锁应用场景"><a href="#三、分布式锁应用场景" class="headerlink" title="三、分布式锁应用场景"></a>三、分布式锁应用场景</h4><blockquote><ol><li><p>分布式任务调度平台保证任务的幂等性。</p></li><li><p>分布式全局id的生成</p></li></ol></blockquote><h4 id="四、Redis分布式锁核心代码"><a href="#四、Redis分布式锁核心代码" class="headerlink" title="四、Redis分布式锁核心代码"></a>四、Redis分布式锁核心代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;    <span class="hljs-comment">//protected static Logger logger = Logger.getLogger(RedisUtil.class);</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String IP = <span class="hljs-string">"192.168.75.128"</span>;    <span class="hljs-comment">//Redis的端口号</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6379</span>;    <span class="hljs-comment">//可用连接实例的最大数目，默认值为8；</span>    <span class="hljs-comment">//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_ACTIVE = <span class="hljs-number">100</span>;    <span class="hljs-comment">//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_IDLE = <span class="hljs-number">20</span>;    <span class="hljs-comment">//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_WAIT = <span class="hljs-number">3000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> TIMEOUT = <span class="hljs-number">3000</span>;    <span class="hljs-comment">//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> TEST_ON_BORROW = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//在return给pool时，是否提前进行validate操作；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> TEST_ON_RETURN = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * redis过期时间,以秒为单位</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_HOUR = <span class="hljs-number">60</span> * <span class="hljs-number">60</span>; <span class="hljs-comment">//一小时</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_DAY = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>; <span class="hljs-comment">//一天</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_MONTH = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>; <span class="hljs-comment">//一个月</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化Redis连接池</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();            config.setMaxTotal(MAX_ACTIVE);            config.setMaxIdle(MAX_IDLE);            config.setMaxWaitMillis(MAX_WAIT);            config.setTestOnBorrow(TEST_ON_BORROW);            jedisPool = <span class="hljs-keyword">new</span> JedisPool(config, IP, PORT, TIMEOUT, <span class="hljs-string">"123456"</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//logger.error("First create JedisPool error : "+e);</span>            e.getMessage();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在多线程环境同步初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">poolInit</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedisPool == <span class="hljs-keyword">null</span>) &#123;            initialPool();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同步获取Jedis实例</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Jedis</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedisPool == <span class="hljs-keyword">null</span>) &#123;            poolInit();        &#125;        Jedis jedis = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (jedisPool != <span class="hljs-keyword">null</span>) &#123;                jedis = jedisPool.getResource();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getMessage();            <span class="hljs-comment">// logger.error("Get jedis error : "+e);</span>        &#125;        <span class="hljs-keyword">return</span> jedis;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放jedis资源</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnResource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Jedis jedis)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span> &amp;&amp; jedisPool != <span class="hljs-keyword">null</span>) &#123;            jedisPool.returnResource(jedis);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">sadd</span><span class="hljs-params">(String key, String... members)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">null</span>;        Long res = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            jedis = getJedis();            res = jedis.sadd(key, members);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//logger.error("sadd  error : "+e);</span>            e.getMessage();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisLock</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> setnxSuccss = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取锁</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey        定义锁的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> notLockTimeOut 没有获取锁的超时时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockTimeOut    使用锁的超时时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLock</span><span class="hljs-params">(String lockKey, <span class="hljs-keyword">int</span> notLockTimeOut, <span class="hljs-keyword">int</span> lockTimeOut)</span> </span>&#123;        <span class="hljs-comment">// 获取Redis连接</span>        Jedis jedis = RedisUtil.getJedis();        <span class="hljs-comment">// 定义没有获取锁的超时时间</span>        Long endTimeOut = System.currentTimeMillis() + notLockTimeOut;        <span class="hljs-keyword">while</span> (System.currentTimeMillis() &lt; endTimeOut) &#123;            String lockValue = UUID.randomUUID().toString();            <span class="hljs-comment">// 如果在多线程情况下谁能够setnx 成功返回0 谁就获取到锁</span>            <span class="hljs-keyword">if</span> (jedis.setnx(lockKey, lockValue) == setnxSuccss) &#123;                jedis.expire(lockKey, lockTimeOut / <span class="hljs-number">1000</span>);                <span class="hljs-keyword">return</span> lockValue;            &#125;            <span class="hljs-comment">// 否则情况下 在超时时间内继续循环</span>        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;                jedis.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放锁 其实就是将该key删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String lockValue)</span> </span>&#123;        Jedis jedis = RedisUtil.getJedis();        <span class="hljs-comment">// 确定是对应的锁 ，才删除</span>        <span class="hljs-keyword">if</span> (lockValue.equals(jedis.get(lockKey))) &#123;            <span class="hljs-keyword">return</span> jedis.del(lockKey) &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;    <span class="hljs-keyword">private</span> RedisLock redisLock = <span class="hljs-keyword">new</span> RedisLock();    <span class="hljs-keyword">private</span> String lockKey = <span class="hljs-string">"redis_lock"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 1.获取锁</span>        String lockValue = redisLock.getLock(lockKey, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(lockValue)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">",获取锁失败!"</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 2.获取锁成功执行业务逻辑</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">",获取成功，lockValue："</span> + lockValue);        <span class="hljs-comment">// 3.释放lock锁</span>        redisLock.unLock(lockKey, lockValue);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ如何保证消息顺序性问题</title>
    <link href="/2020/05/31/12%20RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/31/12%20RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="RabbitMQ如何保证消息顺序性问题"><a href="#RabbitMQ如何保证消息顺序性问题" class="headerlink" title="RabbitMQ如何保证消息顺序性问题"></a>RabbitMQ如何保证消息顺序性问题</h3><p><img src="https://img-blog.csdnimg.cn/20191222000449900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>每个消费者消费的速率的是不一样的，如果消费者先执行完delete语句 那么整个消息就没有保证顺序的问题。</p><p>解决办法：</p><p><img src="https://img-blog.csdnimg.cn/20191222000524724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>比如我们在对某行数据做操作，可以计算出hash值，相同的行数据都投递到同一个队列中，同一个队列中可以保证消费的顺序的问题。``</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js安装及环境变量配置</title>
    <link href="/2020/05/31/14%20Node.js%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/05/31/14%20Node.js%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>==个人记录，便于安装==</p><h5 id="1-下载安装（省略）"><a href="#1-下载安装（省略）" class="headerlink" title="1.下载安装（省略）"></a>1.下载安装（省略）</h5><h5 id="2-检查node、npm是否安装成功"><a href="#2-检查node、npm是否安装成功" class="headerlink" title="2.检查node、npm是否安装成功"></a>2.检查node、npm是否安装成功</h5><pre><code class="hljs shell">node -vnpm -v</code></pre><h5 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h5><p>进入node.js根目录，创建node_global和node_cache文件夹，输入cmd命令：</p><pre><code class="hljs shell">npm config set prefix "D:\Program Files\nodejs\node_global"npm config set cache "D:\Program Files\nodejs\node_cache"</code></pre><p>接下来设置环境变量</p><pre><code class="hljs taggerscript">1.系统创建 NODE_PATHD:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\n</span>odejs<span class="hljs-symbol">\n</span>ode_modules2.修改用户 pathC:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\K</span>arma<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\n</span>pm 修改为 D:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\n</span>odejs<span class="hljs-symbol">\n</span>ode_global</code></pre><h5 id="4-淘宝镜像安装（cnpm）"><a href="#4-淘宝镜像安装（cnpm）" class="headerlink" title="4.淘宝镜像安装（cnpm）"></a>4.淘宝镜像安装（cnpm）</h5><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>测试：</p><pre><code class="hljs shell">cnpm install express -g</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ消息幂等问题</title>
    <link href="/2020/05/31/13%20RabbitMQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/31/13%20RabbitMQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="RabbitMQ消息幂等问题"><a href="#RabbitMQ消息幂等问题" class="headerlink" title="RabbitMQ消息幂等问题"></a>RabbitMQ消息幂等问题</h3><h4 id="一、RabbitMQ消息自动重试机制"><a href="#一、RabbitMQ消息自动重试机制" class="headerlink" title="一、RabbitMQ消息自动重试机制"></a>一、RabbitMQ消息自动重试机制</h4><blockquote><ol><li><p>当消费者业务逻辑代码中，抛出异常自动实现重试 （默认是无数次重试）</p></li><li><p>应该对RabbitMQ重试次数实现限制，比如最多重试5次，每次间隔3s；重试多次还是失败的情况下，存放到死信队列或者存放到数据库表中记录后期人工补偿</p></li></ol></blockquote><h4 id="二、如何合理选择消息重试"><a href="#二、如何合理选择消息重试" class="headerlink" title="二、如何合理选择消息重试"></a>二、如何合理选择消息重试</h4><blockquote><ol><li><p>消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试 ？</p></li><li><p>消费者获取消息后，代码问题抛出数据异常，是否需要重试？</p></li></ol><p>总结：如果消费者处理消息时，因为代码原因抛出异常是需要从新发布版本才能解决的，那么就不需要重试，重试也解决不了该问题的。存放到死信队列或者是数据库表记录、后期人工实现补偿。</p></blockquote><h4 id="三、SpringBoot开启重试策略"><a href="#三、SpringBoot开启重试策略" class="headerlink" title="三、SpringBoot开启重试策略"></a>三、SpringBoot开启重试策略</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-comment">####连接地址</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>    <span class="hljs-comment">####端口号</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-comment">####账号</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">####密码</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">### 地址</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/wmh</span>    <span class="hljs-attr">listener:</span>      <span class="hljs-attr">simple:</span>        <span class="hljs-attr">retry:</span>          <span class="hljs-comment">####开启消费者（程序出现异常的情况下会）进行重试</span>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment">####最大重试次数</span>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">5</span>          <span class="hljs-comment">####重试间隔次数</span>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-number">3000</span></code></pre><h5 id="1-邮件消费者开启重试策略"><a href="#1-邮件消费者开启重试策略" class="headerlink" title="1.邮件消费者开启重试策略"></a>1.邮件消费者开启重试策略</h5><pre><code class="hljs java">System.out.println(<span class="hljs-string">"邮件消费者消息msg:"</span> + msg);JSONObject msgJson = JSONObject.parseObject(msg);String email = msgJson.getString(<span class="hljs-string">"email"</span>);String emailUrl = <span class="hljs-string">"http://127.0.0.1:8081/sendEmail?email="</span> + email;JSONObject jsonObject = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    jsonObject = HttpClientUtils.httpGet(emailUrl);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    String errorMsg = email + <span class="hljs-string">",调用第三方邮件接口失败:"</span> + <span class="hljs-string">",错误原因:"</span> + e.getMessage();    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(errorMsg);&#125;System.out.println(<span class="hljs-string">"邮件消费者调用第三方接口结果:"</span> + jsonObject);</code></pre><h5 id="2-SpringBoot开启消息确认机制"><a href="#2-SpringBoot开启消息确认机制" class="headerlink" title="2. SpringBoot开启消息确认机制"></a>2. SpringBoot开启消息确认机制</h5><p>消息者开启手动ack</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = orderMapper.addOrder(orderEntity);<span class="hljs-keyword">if</span> (result &gt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 开启消息确认机制</span>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);&#125;</code></pre><p>application.yml中添加：</p><pre><code class="hljs yaml"><span class="hljs-attr">listener:</span>  <span class="hljs-attr">simple:</span>    <span class="hljs-attr">retry:</span>      <span class="hljs-comment">####开启消费者（程序出现异常的情况下会）进行重试</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment">####最大重试次数</span>      <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">5</span>      <span class="hljs-comment">####重试间隔次数</span>      <span class="hljs-attr">initial-interval:</span> <span class="hljs-number">3000</span>  <span class="hljs-comment">###开启ack模式</span>    <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span></code></pre><h5 id="3-rabbitMQ如何解决消息幂等问题"><a href="#3-rabbitMQ如何解决消息幂等问题" class="headerlink" title="3.rabbitMQ如何解决消息幂等问题"></a>3.rabbitMQ如何解决消息幂等问题</h5><blockquote><p>采用消息全局id根据业务来定</p></blockquote><p>生产者：</p><pre><code class="hljs java">RequestMapping(<span class="hljs-string">"/sendOrderMsg"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendOrderMsg</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 1.生产订单id</span>        String orderId = System.currentTimeMillis() + <span class="hljs-string">""</span>;        String orderName = <span class="hljs-string">"测试订单名字-------------"</span>;        OrderEntity orderEntity = <span class="hljs-keyword">new</span> OrderEntity(orderName, orderId);        String msg = JSONObject.toJSONString(orderEntity);        sendMsg(msg, orderId);        <span class="hljs-keyword">return</span> orderId;        <span class="hljs-comment">// 后期客户端主动使用orderId调用服务器接口 查询该订单id是否在数据库中存在数据 消费成功 消费失败</span>    &#125;    <span class="hljs-meta">@Async</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg, String orderId)</span> </span>&#123;        rabbitTemplate.convertAndSend(orderExchange, orderRoutingKey, msg,                <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;<span class="hljs-comment">//                        message.getMessageProperties().setExpiration("10000");</span>                        message.getMessageProperties().setMessageId(orderId);                        <span class="hljs-keyword">return</span> message;                    &#125;                &#125;);        <span class="hljs-comment">// 消息投递失败</span>    &#125;</code></pre><p>消费者：</p><pre><code class="hljs java">String msg = <span class="hljs-keyword">new</span> String(message.getBody());System.out.println(<span class="hljs-string">"订单队列获取消息:"</span> + msg);OrderEntity orderEntity = JSONObject.parseObject(msg, OrderEntity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">if</span> (orderEntity == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// messageId根据具体业务来定,如果已经在数据表中插入过数据，则不会插入</span>String orderId = message.getMessageProperties().getMessageId();<span class="hljs-keyword">if</span> (StringUtils.isEmpty(orderId)) &#123;    <span class="hljs-comment">// 开启消息确认机制</span>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);    <span class="hljs-keyword">return</span>;&#125;OrderEntity dbOrderEntity = orderMapper.getOrder(orderId);<span class="hljs-keyword">if</span> (dbOrderEntity != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 说明已经处理过请求</span>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> result = orderMapper.addOrder(orderEntity);<span class="hljs-keyword">if</span> (result &gt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 开启消息确认机制</span>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka集群设计原理</title>
    <link href="/2020/05/31/09%20Kafka%E9%9B%86%E7%BE%A4%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <url>/2020/05/31/09%20Kafka%E9%9B%86%E7%BE%A4%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Kafka集群设计原理"><a href="#Kafka集群设计原理" class="headerlink" title="Kafka集群设计原理"></a>Kafka集群设计原理</h3><blockquote><p>Apache Kafka是分布式发布-订阅消息系统，在 kafka官网上对 kafka 的定义：一个分布式发布-订阅消息传递系统。 它最初由LinkedIn公司开发，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。</p><p>Kafka并没有遵循JMS规范，它只提供了发布和订阅通讯方式。  </p></blockquote><p>kafka中文官网:<a href="http://kafka.apachecn.org/quickstart.html" target="_blank" rel="noopener">http://kafka.apachecn.org/quickstart.html</a></p><h3 id="一、Kafka核心相关名称"><a href="#一、Kafka核心相关名称" class="headerlink" title="一、Kafka核心相关名称"></a>一、Kafka核心相关名称</h3><blockquote><p>Broker：kafka节点，一个kafka就是一个broker，多个可以可组成一个集群</p><p>Topic：主题，相当于一个一类消息，kafka集群能够同时负责多个topic的分发</p><p>message：消息</p><p>Partition：topic上一个物理分区，一个topic可以有多个Partition，每个Partition是一个有序的队列</p><p>Segment：Partition是由多个Partition组成，每个Segment存放着独立的message</p><p>Producer：生产者，推送消息到topic中</p><p>Consumer：消费者，订阅topic并消费message，Consumer作为一个线程来消费</p><p>Offset：偏移量，相当于消息Partition中的索引即可</p></blockquote><h3 id="二、Kafka集群环境搭建"><a href="#二、Kafka集群环境搭建" class="headerlink" title="二、Kafka集群环境搭建"></a>二、Kafka集群环境搭建</h3><blockquote><p>1.每台服务器上安装jdk1.8环境</p><p>2.安装Zookeeper集群环境（本文使用三台服务器集群）</p><p>3.安装kafka集群环境（本文使用三台服务器集群）</p><p>4.运行环境测试</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#服务器ip如下</span></span>192.168.75.130192.168.75.132192.168.75.133</code></pre><p><strong><em>本文使用Kafka2.11版本，需要依赖Zookeeper，最新版本的Kafka无需搭建Zk</em></strong></p></blockquote><h4 id="1-Zookeeper集群环境搭建"><a href="#1-Zookeeper集群环境搭建" class="headerlink" title="1.Zookeeper集群环境搭建"></a>1.Zookeeper集群环境搭建</h4><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> tar -zxvf zookeeper-3.4.14.tar.gz</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> zookeeper-3.4.14</span><span class="hljs-meta">&gt;</span><span class="bash"> mv zoo_sample.cfg zoo.cfg</span><span class="hljs-meta">&gt;</span><span class="bash"> vi zoo.cfg</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 修改zoo.cfg两处 三台服务器一样</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 1.修改dataDIr路径，并创建data目录</span></span>dataDir=/usr/local/zookeeper-3.4.14/data<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 2.添加</span></span>server.0=192.168.75.130:2888:3888server.1=192.168.75.132:2888:3888server.2=192.168.75.133:2888:3888<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 分别在三台zookeeper服务器创建myid文件，添加唯一标识id</span></span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/zookeeper-3.4.14/data</span><span class="hljs-meta">&gt;</span><span class="bash"> touch myid</span><span class="hljs-meta">&gt;</span><span class="bash"> vi myid</span>1<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 其余两台分别为1、2</span></span><span class="hljs-meta">#</span><span class="bash"> 启动Zookeeper 三台同时执行</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/zookeeper-3.4.14/bin</span><span class="hljs-meta">&gt;</span><span class="bash"> ./zkServer.sh start</span><span class="hljs-meta">#</span><span class="bash"> 查看zk状态</span><span class="hljs-meta">&gt;</span><span class="bash"> zkServer.sh status</span><span class="hljs-meta">#</span><span class="bash"> 出现Mode:follower或是Mode:leader则代表成功</span></code></pre><h4 id="2-Kafka集群环境搭建"><a href="#2-Kafka集群环境搭建" class="headerlink" title="2.Kafka集群环境搭建"></a>2.Kafka集群环境搭建</h4><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> tar -zxvf kafka_2.11-2.2.1.tgz</span><span class="hljs-meta">&gt;</span><span class="bash"> vi ./kafka_2.11-2.2.1/config/server.properties</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 分别修改3处</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 1.kafka唯一标识</span></span>broker.id=0<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 2.申明此kafka服务器需要监听的端口号</span></span>listeners=PLAINTEXT://192.168.75.130:9092<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 3.zk集群ip</span></span>zookeeper.connect=192.168.75.130:2181,192.168.75.132:2181,192.168.75.133:2181<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 其余两台只需修改broker.id，分别为1、2即可</span></span><span class="hljs-meta">#</span><span class="bash"> 后台启动kafka集群</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/kafka_2.11-2.2.1/bin</span><span class="hljs-meta">&gt;</span><span class="bash"> ./kafka-server-start.sh -daemon ../config/server.properties</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在其中一台服务中创建topic主题</span></span><span class="hljs-meta">&gt;</span><span class="bash"> ./kafka-topics.sh --create –zookeeper 192.168.75.130:2181 –replication-factor 3 –partitions 1 –topic my-replicated-topic</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 查看创建的topic信息</span></span><span class="hljs-meta">&gt;</span><span class="bash"> kafka-topics.sh –describe –zookeeper 192.168.75.130:2181 –topic my-replicated-topic</span></code></pre><p>详情文档参考官网 <a href="http://kafka.apachecn.org/quickstart.html" target="_blank" rel="noopener">http://kafka.apachecn.org/quickstart.html</a></p><h3 id="三、Kafka保证消息顺序性"><a href="#三、Kafka保证消息顺序性" class="headerlink" title="三、Kafka保证消息顺序性"></a>三、Kafka保证消息顺序性</h3><p>Kafka集群是如何知道投递到那个broker中呢？靠的就是生产者在投递消息的时候传递key，根据key计算hash值存在到具体的broker中，如果是相同的key，最终投递消息都是同一个broker中。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消费者使用日志打印消息</span><span class="hljs-comment"> */</span><span class="hljs-meta">@KafkaListener</span>(topicPartitions = &#123;<span class="hljs-meta">@TopicPartition</span>(topic = <span class="hljs-string">"mayikt"</span>, partitions = &#123;<span class="hljs-string">"0"</span>&#125;)&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(ConsumerRecord&lt;?, ?&gt; consumer)</span> </span>&#123;    System.out.println(<span class="hljs-string">"topic名称:"</span> + consumer.topic() + <span class="hljs-string">",key:"</span> +            consumer.key() + <span class="hljs-string">","</span> +            <span class="hljs-string">"分区位置:"</span> + consumer.partition()            + <span class="hljs-string">", 下标"</span> + consumer.offset());&#125;</code></pre><p>场景：比如我们基于MQ解决Redis与MySql数据一致性的问题，可以采用MQ订阅MySQL binLog文件异步的实现数据的同步；先发送insert、update、delete的请求到同一个的队列中存放。<br><img src="https://img-blog.csdnimg.cn/20191222000314935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="四、RabbitMQ如何保证消息顺序性问题"><a href="#四、RabbitMQ如何保证消息顺序性问题" class="headerlink" title="四、RabbitMQ如何保证消息顺序性问题"></a>四、RabbitMQ如何保证消息顺序性问题</h3><p>Kafka默认只要设置是相同的key最终都会存放到同一个分区中，每个分区中单独对应一个消费者实现消费。</p><img src="https://img-blog.csdnimg.cn/20191222000808820.png" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:150%;" /><p>但是如果消费者中里面是多线程的时候，这时候也会存在顺序的问题，采用内存队列形式实现，每个内存队列对应Thread线程从而提高速率。</p><h3 id="四、Kafka如何保证高吞吐量"><a href="#四、Kafka如何保证高吞吐量" class="headerlink" title="四、Kafka如何保证高吞吐量"></a>四、Kafka如何保证高吞吐量</h3><ol><li>使用顺序写方式实现数据存储</li></ol><p>Kafka是采用不断的将数据追加到文件中，该特性利用了磁盘的顺序读写性能比传统的磁盘读写可以减少寻地址浪费的时间；</p><ol start="2"><li>能够支持生产者与消费者(批量发送和批量消费) 减少ioc操作</li></ol><p>可以将消息投递到缓存区中，在以定时或者/缓存大小方式将数据写入到MQ服务器中，</p><p>这样可以减少IO的网络操作，但是这种方式也存在很大缺陷数据可能会丢失。</p><ol start="3"><li><p>数据零拷贝</p></li><li><p>实现数据的分区 </p></li></ol><p>根据Partition实现对我们的数据的分区</p><ol start="5"><li>数据的压缩 会对我们的数据实现压缩，减少网络的传输</li></ol><p>``</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger2API接口管理</title>
    <link href="/2020/05/31/08%20Swagger2API%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/31/08%20Swagger2API%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Swagger2API接口管理"><a href="#Swagger2API接口管理" class="headerlink" title="Swagger2API接口管理"></a>Swagger2API接口管理</h1><h3 id="1-课题引入"><a href="#1-课题引入" class="headerlink" title="1.课题引入"></a>1.课题引入</h3><p>随着微服务架构体系的发展和应用， 为了前后端能够更好的集成与对接，同时为了项目的方便交付，每个项目都需要提供相应的API文档。</p><p>来源：PC端、微信端、H5端、移动端（安卓和IOS端）</p><h3 id="2-传统的API文档编写存在以下几个痛点"><a href="#2-传统的API文档编写存在以下几个痛点" class="headerlink" title="2.传统的API文档编写存在以下几个痛点"></a>2.传统的API文档编写存在以下几个痛点</h3><p>对API文档进行更新的时候，需要通知前端开发人员，导致文档更新交流不及时；</p><p>API接口返回信息不明确</p><p>大公司中肯定会有专门文档服务器对接口文档进行更新。 </p><p>缺乏在线接口测试，通常需要使用相应的API测试工具，比如postman、SoapUI等</p><p>接口文档太多，不便于管理</p><p>为了解决传统API接口文档维护的问题，为了方便进行测试后台Restful接口并实现动态的更新，因而引入Swagger接口工具。</p><h3 id="3-Swagger具有以下优点"><a href="#3-Swagger具有以下优点" class="headerlink" title="3.Swagger具有以下优点"></a>3.Swagger具有以下优点</h3><p>1.功能丰富：支持多种注解，自动生成接口文档界面，支持在界面测试API接口功能；</p><p>2.及时更新：开发过程中花一点写注释的时间，就可以及时的更新API文档，省心省力；</p><p>3.整合简单：通过添加pom依赖和简单配置，内嵌于应用中就可同时发布API接口文档界面，不需要部署独立服务。</p><h3 id="4-Swagger-2-0-集成配置"><a href="#4-Swagger-2-0-集成配置" class="headerlink" title="4.Swagger 2.0 集成配置"></a>4.Swagger 2.0 集成配置</h3><h4 id="4-1-Maven依赖信息"><a href="#4-1-Maven依赖信息" class="headerlink" title="4.1.Maven依赖信息"></a>4.1.Maven依赖信息</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-comment">&lt;!-- 管理依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Finchley.M7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- SpringBoot整合eureka客户端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/libs-milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre><h4 id="4-2-SwaggerConfig"><a href="#4-2-SwaggerConfig" class="headerlink" title="4.2.SwaggerConfig"></a>4.2.SwaggerConfig</h4><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select()<span class="hljs-comment">// api扫包</span>.apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.itmayiedu.api"</span>)).paths(PathSelectors.any()).build();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder().title(<span class="hljs-string">"每特教育|蚂蚁课堂 微服务电商系统"</span>).description(<span class="hljs-string">"每特教育|蚂蚁课堂 Java分布式&amp;微服务培训"</span>).termsOfServiceUrl(<span class="hljs-string">"http://www.itmayiedu.com"</span>)<span class="hljs-comment">// .contact(contact)</span>.version(<span class="hljs-string">"1.0"</span>).build();&#125;&#125;</code></pre><p>Swagger模板</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-models<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//@Profile(&#123; "dev", "test" &#125;) 指定环境</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-comment">//在1.9.0版本或之后版本，SwaggerBootstrapUi提供了简单的Basic认证功能</span><span class="hljs-comment">//@EnableSwaggerBootstrapUI 账户权限配置</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                <span class="hljs-comment">// api扫包</span>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.xxx.controller"</span>))                <span class="hljs-comment">// 接口地址前缀</span>                .paths(PathSelectors.any())                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"xxxx系统"</span>)                .description(<span class="hljs-string">"xxxxxx描述"</span>)                .termsOfServiceUrl(<span class="hljs-string">"http://www.xxxxx.com"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"karma"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>))                .version(<span class="hljs-string">"1.0"</span>)                .build();    &#125;&#125;</code></pre><p>若添加了账户权限配置，在yml文件添加一下配置</p><pre><code class="hljs yaml"><span class="hljs-attr">swagger:</span>  <span class="hljs-attr">production:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">basic:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span></code></pre><p>访问-&gt; ip:端口/前缀/swagger-ui.html 或者 ip:端口/前缀/doc.html</p><pre><code class="hljs java">/doc.html    SwaggerBootstrapUi提供的文档访问地址/api-docs-ext    SwaggerBootstrapUi提供的增强接口地址/swagger-resources    Springfox-Swagger提供的分组接口/api-docs    Springfox-Swagger提供的分组实例详情接口/swagger-ui.html    Springfox-Swagger提供的文档访问地址/swagger-resources/configuration/ui    Springfox-Swagger提供/swagger-resources/configuration/security    Springfox-Swagger提供</code></pre><h3 id="5-Zull整合Swagger管理微服务所有API"><a href="#5-Zull整合Swagger管理微服务所有API" class="headerlink" title="5.Zull整合Swagger管理微服务所有API"></a>5.Zull整合Swagger管理微服务所有API</h3><h4 id="5-1-会员和订单"><a href="#5-1-会员和订单" class="headerlink" title="5.1.会员和订单"></a>5.1.会员和订单</h4><h5 id="5-1-1-引入Maven依赖"><a href="#5-1-1-引入Maven依赖" class="headerlink" title="5.1.1.引入Maven依赖"></a>5.1.1.引入Maven依赖</h5><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- swagger-spring-boot --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spring4all<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="5-1-2-application-yml配置"><a href="#5-1-2-application-yml配置" class="headerlink" title="5.1.2.application.yml配置"></a>5.1.2.application.yml配置</h5><p>Api接口扫描范围</p><pre><code class="hljs yml"><span class="hljs-attr">swagger:</span>  <span class="hljs-attr">base-package:</span> <span class="hljs-string">com.wmh.wechat.service</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">微信服务系统</span>  <span class="hljs-attr">description:</span> <span class="hljs-string">微信服务接口</span>  <span class="hljs-attr">version:</span> <span class="hljs-number">1.1</span>  <span class="hljs-attr">terms-of-service-url:</span> <span class="hljs-string">http://127.0.0.1:9090</span>  <span class="hljs-attr">contact:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">karma</span>    <span class="hljs-attr">email:</span> <span class="hljs-string">xxxxxx@qq.com</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:9090</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h5 id="5-1-3-项目启动引入开启生成文档"><a href="#5-1-3-项目启动引入开启生成文档" class="headerlink" title="5.1.3.项目启动引入开启生成文档"></a>5.1.3.项目启动引入开启生成文档</h5><p>@EnableSwagger2Doc</p><h4 id="5-2-ZuulGateway网关"><a href="#5-2-ZuulGateway网关" class="headerlink" title="5.2.ZuulGateway网关"></a>5.2.ZuulGateway网关</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableZuulProxy</span><span class="hljs-meta">@EnableSwagger</span>2Doc<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppGateWay</span> </span>&#123;<span class="hljs-comment">// @EnableZuulProxy 开启网关代理</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(AppGateWay<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;<span class="hljs-comment">// zuul配置能够使用config实现实时更新</span><span class="hljs-meta">@RefreshScope</span><span class="hljs-meta">@ConfigurationProperties</span>(<span class="hljs-string">"zuul"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ZuulProperties <span class="hljs-title">zuulProperties</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZuulProperties();&#125;<span class="hljs-comment">// 添加文档来源</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Primary</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentationConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwaggerResourcesProvider</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SwaggerResource&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;List resources = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">// app-itmayiedu-order</span>resources.add(swaggerResource(<span class="hljs-string">"app-itmayiedu-member"</span>, <span class="hljs-string">"/api-member/v2/api-docs"</span>, <span class="hljs-string">"2.0"</span>));resources.add(swaggerResource(<span class="hljs-string">"app-itmayiedu-order"</span>, <span class="hljs-string">"/api-order/v2/api-docs"</span>, <span class="hljs-string">"2.0"</span>));<span class="hljs-keyword">return</span> resources;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> SwaggerResource <span class="hljs-title">swaggerResource</span><span class="hljs-params">(String name, String location, String version)</span> </span>&#123;SwaggerResource swaggerResource = <span class="hljs-keyword">new</span> SwaggerResource();swaggerResource.setName(name);swaggerResource.setLocation(location);swaggerResource.setSwaggerVersion(version);<span class="hljs-keyword">return</span> swaggerResource;&#125;&#125;&#125;</code></pre><p>Maven依赖信息</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spring4all<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="5-3-Swagger整合Gateway网关"><a href="#5-3-Swagger整合Gateway网关" class="headerlink" title="5.3.Swagger整合Gateway网关"></a>5.3.Swagger整合Gateway网关</h4><h5 id="5-3-1-添加maven依赖"><a href="#5-3-1-添加maven依赖" class="headerlink" title="5.3.1 添加maven依赖"></a>5.3.1 添加maven依赖</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-models<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="5-3-2-添加获取swagger-v2-api-docs接口信息配置类"><a href="#5-3-2-添加获取swagger-v2-api-docs接口信息配置类" class="headerlink" title="5.3.2 添加获取swagger /v2/api-docs接口信息配置类"></a>5.3.2 添加获取swagger /v2/api-docs接口信息配置类</h5><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwaggerResourcesProvider</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String API_URI = <span class="hljs-string">"/v2/api-docs"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RouteLocator routeLocator;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GatewayProperties gatewayProperties;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SwaggerResource&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        List&lt;SwaggerResource&gt; resources = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;String&gt; routes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        routeLocator.getRoutes().subscribe(route -&gt; routes.add(route.getId()));        gatewayProperties.getRoutes().stream().filter(routeDefinition -&gt; routes.contains(routeDefinition.getId()))                .forEach(routeDefinition -&gt; routeDefinition.getPredicates().stream()                        .filter(predicateDefinition -&gt; (<span class="hljs-string">"Path"</span>).equalsIgnoreCase(predicateDefinition.getName()))                        .forEach(predicateDefinition -&gt; resources.add(swaggerResource(routeDefinition.getId(),                                predicateDefinition.getArgs().get(NameUtils.GENERATED_NAME_PREFIX + <span class="hljs-string">"0"</span>)                                        .replace(<span class="hljs-string">"/**"</span>, API_URI)))));        <span class="hljs-keyword">return</span> resources;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> SwaggerResource <span class="hljs-title">swaggerResource</span><span class="hljs-params">(String name, String location)</span> </span>&#123;        SwaggerResource swaggerResource = <span class="hljs-keyword">new</span> SwaggerResource();        swaggerResource.setName(name);        swaggerResource.setLocation(location);        swaggerResource.setSwaggerVersion(<span class="hljs-string">"2.0"</span>);        <span class="hljs-keyword">return</span> swaggerResource;    &#125;&#125;</code></pre><h5 id="5-3-3-添加swagger地址过滤器"><a href="#5-3-3-添加swagger地址过滤器" class="headerlink" title="5.3.3 添加swagger地址过滤器"></a>5.3.3 添加swagger地址过滤器</h5><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerHeaderFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGatewayFilterFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADER_NAME = <span class="hljs-string">"X-Forwarded-Prefix"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title">apply</span><span class="hljs-params">(Object config)</span> </span>&#123;        <span class="hljs-keyword">return</span> (exchange, chain) -&gt; &#123;            ServerHttpRequest request = exchange.getRequest();            String path = request.getURI().getPath();            <span class="hljs-keyword">if</span> (!StringUtils.endsWithIgnoreCase(path, SwaggerProvider.API_URI)) &#123;                <span class="hljs-keyword">return</span> chain.filter(exchange);            &#125;            String basePath = path.substring(<span class="hljs-number">0</span>, path.lastIndexOf(SwaggerProvider.API_URI));            ServerHttpRequest newRequest = request.mutate().header(HEADER_NAME, basePath).build();            ServerWebExchange newExchange = exchange.mutate().request(newRequest).build();            <span class="hljs-keyword">return</span> chain.filter(newExchange);        &#125;;    &#125;&#125;</code></pre><h5 id="5-3-4-添加swagger适配器"><a href="#5-3-4-添加swagger适配器" class="headerlink" title="5.3.4 添加swagger适配器"></a>5.3.4 添加swagger适配器</h5><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * SwaggerHandler</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/swagger-resources"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerHandler</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)    <span class="hljs-keyword">private</span> SecurityConfiguration securityConfiguration;    <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)    <span class="hljs-keyword">private</span> UiConfiguration uiConfiguration;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SwaggerResourcesProvider swaggerResources;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SwaggerHandler</span><span class="hljs-params">(SwaggerResourcesProvider swaggerResources)</span> </span>&#123;        <span class="hljs-keyword">this</span>.swaggerResources = swaggerResources;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/configuration/security"</span>)    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;SecurityConfiguration&gt;&gt; securityConfiguration() &#123;        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(                Optional.ofNullable(securityConfiguration).orElse(SecurityConfigurationBuilder.builder().build()), HttpStatus.OK));    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/configuration/ui"</span>)    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;UiConfiguration&gt;&gt; uiConfiguration() &#123;        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(                Optional.ofNullable(uiConfiguration).orElse(UiConfigurationBuilder.builder().build()), HttpStatus.OK));    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">""</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="hljs-title">swaggerResources</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Mono.just((<span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(swaggerResources.get(), HttpStatus.OK)));    &#125;&#125;</code></pre><h5 id="5-3-5-添加application-yml文件"><a href="#5-3-5-添加application-yml文件" class="headerlink" title="5.3.5 添加application.yml文件"></a>5.3.5 添加application.yml文件</h5><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">wmh-gateway</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">##nacos服务注册地址</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span>    <span class="hljs-attr">gateway:</span>      <span class="hljs-attr">locator:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">routes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">wmh-wechat</span>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://wmh-wechat</span>          <span class="hljs-attr">predicates:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/wmh-wechat/**</span>          <span class="hljs-attr">filters:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">SwaggerHeaderFilter</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">wmh-member</span>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://wmh-member</span>          <span class="hljs-attr">predicates:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/wmh-member/**</span>          <span class="hljs-attr">filters:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">SwaggerHeaderFilter</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 入门教程</title>
    <link href="/2020/05/31/07%20Gradle%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2020/05/31/07%20Gradle%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Gradle-入门教程"><a href="#Gradle-入门教程" class="headerlink" title="Gradle 入门教程"></a>Gradle 入门教程</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>Gradle 是一种构建工具，它抛弃了基于XML的构建脚本，取而代之的是采用一种基于 Groovy（现在也支持 Kotlin）的内部领域特定语言。</p><h4 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h4><ol><li>Gradle是很成熟的技术，可以处理大规模构建</li><li>Gradle对多语言、多平台支持性更好</li><li>Gradle关注在构建效率上</li><li>Gradle发布很频繁，重要feature开发计划透明化</li><li>Gradle社区很活跃，并且增加迅速</li></ol><h4 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h4><p>1.官网 (<a href="https://gradle.org/install/)[下载](https://gradle.org/next-steps/?version=5.5.1&amp;format=bin)二进制文件，并解压" target="_blank" rel="noopener">https://gradle.org/install/)[下载](https://gradle.org/next-steps/?version=5.5.1&amp;format=bin)二进制文件，并解压</a></p><p>2.配置环境变量</p><pre><code class="hljs taggerscript">Path    D:<span class="hljs-symbol">\t</span>ools<span class="hljs-symbol">\g</span>radle-5.5.1<span class="hljs-symbol">\b</span>in</code></pre><p>3.验证</p><pre><code class="hljs shell">gradle -v</code></pre><h4 id="四、使用IDEA快速构建SpringBoot项目"><a href="#四、使用IDEA快速构建SpringBoot项目" class="headerlink" title="四、使用IDEA快速构建SpringBoot项目"></a>四、使用IDEA快速构建SpringBoot项目</h4><p><strong>在setting配置中设置本地仓库地址</strong></p><p>1.创建一个Gradle项目</p><p><img src="https://img-blog.csdnimg.cn/20190722162510935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>2.Type选择Gradle Project<br><img src="https://img-blog.csdnimg.cn/20190722162527819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>3.选择Web中的Spring Web Starter<br><img src="https://img-blog.csdnimg.cn/20190722162603403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>4.使用本地Gradle并配置本地仓库地址<br><img src="https://img-blog.csdnimg.cn/20190722162718870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>5.项目创建完成<br><img src="https://img-blog.csdnimg.cn/20190722162959847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="五、gradle配置及依赖方式说明"><a href="#五、gradle配置及依赖方式说明" class="headerlink" title="五、gradle配置及依赖方式说明"></a>五、gradle配置及依赖方式说明</h4><p>1.setting.gradle</p><pre><code class="hljs delphi">pluginManagement <span class="hljs-comment">&#123;</span><span class="hljs-comment">    repositories &#123;</span><span class="hljs-comment">        gradlePluginPortal()</span><span class="hljs-comment">    &#125;</span>&#125;rootProject.<span class="hljs-keyword">name</span> = <span class="hljs-string">'demo'</span> <span class="hljs-comment">//项目名</span></code></pre><p>2.build.gradle</p><pre><code class="hljs gradle">plugins &#123;    id <span class="hljs-string">'org.springframework.boot'</span> version <span class="hljs-string">'2.1.6.RELEASE'</span>    id <span class="hljs-string">'java'</span>&#125;apply plugin: <span class="hljs-string">'io.spring.dependency-management'</span>  <span class="hljs-comment">//应用的插件</span><span class="hljs-keyword">group</span> = <span class="hljs-string">'com.example'</span>version = <span class="hljs-string">'0.0.1-SNAPSHOT'</span><span class="hljs-keyword">sourceCompatibility</span> = <span class="hljs-string">'1.8'</span><span class="hljs-keyword">repositories</span> &#123;  <span class="hljs-comment">//远程仓库，根据先后顺序，决定优先级</span>maven &#123; url <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;    mavenCentral() &#125;<span class="hljs-keyword">dependencies</span> &#123;    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>    testImplementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>&#125;</code></pre><p>3.build.gradle中各种依赖说明</p><blockquote><p>1.implementation<br>这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。</p><p>2.api<br>完全等同于compile指令。</p><p>3.compile<br>这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。</p><p>4.testCompile<br>testCompile 只在单元测试代码的编译以及最终打包测试时有效。</p><p>5.debugCompile<br>debugCompile 只在debug模式的编译和最终的debug打包时有效。</p><p>6.releaseCompile<br>releaseCompile 仅仅针对Release模式的编译和最终的Release打包。</p><p>7.provided<br>只在编译时有效，不会参与打包，可以在自己的moudle中使用该方式依赖。</p><p>8.apk（runtimeOnly） </p><p>只在生成apk的时候参与打包，编译时不会参与，很少用。</p></blockquote><p>4.依赖版本号处理</p><pre><code class="hljs css"><span class="hljs-selector-tag">compile</span> ‘<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-pseudo">:gson</span><span class="hljs-selector-pseudo">:2.8.0</span>’</code></pre><p>在Gradle中可以不指定版本号，比如：</p><pre><code class="hljs css"><span class="hljs-selector-tag">compile</span> ‘<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-pseudo">:gson</span><span class="hljs-selector-pseudo">:2.+</span>’ 引入<span class="hljs-selector-tag">gson</span> 大版本为2的包 <span class="hljs-selector-tag">compile</span> ‘<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-pseudo">:gson</span><span class="hljs-selector-pseudo">:latest.release</span>’引入<span class="hljs-selector-tag">gson</span> 最新的包</code></pre><p>5.统一管理版本号</p><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dpc</span> </span>= rootProject.ext.testVersionext&#123;    <span class="hljs-comment">//dependencies</span>    testVersion ='xx.xx.xx'&#125;<span class="hljs-comment">//使用</span>compile test dpc</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zuul网关服务集成阿波罗及Swagger文档配置</title>
    <link href="/2020/05/31/06%20Zuul%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90%E9%98%BF%E6%B3%A2%E7%BD%97%E5%8F%8ASwagger%E6%96%87%E6%A1%A3%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/05/31/06%20Zuul%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90%E9%98%BF%E6%B3%A2%E7%BD%97%E5%8F%8ASwagger%E6%96%87%E6%A1%A3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h5 id="1-在Apollo配置中心创建项目，并导入配置。"><a href="#1-在Apollo配置中心创建项目，并导入配置。" class="headerlink" title="1.在Apollo配置中心创建项目，并导入配置。"></a>1.在Apollo配置中心创建项目，并导入配置。</h5><p><img src="https://img-blog.csdnimg.cn/20190601155309251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"app-member"</span>,        <span class="hljs-attr">"location"</span>: <span class="hljs-string">"/app-mayikt-member/v2/api-docs"</span>,        <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2.0"</span>    &#125;,    &#123;        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"app-weixin"</span>,        <span class="hljs-attr">"location"</span>: <span class="hljs-string">"/app-mayikt-weixin/v2/api-docs"</span>,        <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2.0"</span>    &#125;]</code></pre><h5 id="2-在Zuul网关中，导入依赖。"><a href="#2-在Zuul网关中，导入依赖。" class="headerlink" title="2.在Zuul网关中，导入依赖。"></a>2.在Zuul网关中，导入依赖。</h5><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--阿波罗配置中心依赖--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apollo-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apollo-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="3-创建application-properties配置文件"><a href="#3-创建application-properties配置文件" class="headerlink" title="3.创建application.properties配置文件"></a>3.创建application.properties配置文件</h5><pre><code class="hljs properties"><span class="hljs-meta">app.id</span>=<span class="hljs-string">app-mayikt-zuul #上图中的项目的appid</span><span class="hljs-meta">apollo.meta</span>=<span class="hljs-string">http://172.20.10.3:8080  #阿波罗ip地址</span></code></pre><h5 id="4-在启动类上加上-EnableApolloConfig和-EnableSwagger2Doc"><a href="#4-在启动类上加上-EnableApolloConfig和-EnableSwagger2Doc" class="headerlink" title="4.在启动类上加上@EnableApolloConfig和@EnableSwagger2Doc"></a>4.在启动类上加上@EnableApolloConfig和@EnableSwagger2Doc</h5><h5 id="5-获取Swagger文档配置信息"><a href="#5-获取Swagger文档配置信息" class="headerlink" title="5.获取Swagger文档配置信息"></a>5.获取Swagger文档配置信息</h5><pre><code class="hljs java">   <span class="hljs-comment">//获取ApolloConfig</span>   <span class="hljs-meta">@ApolloConfig</span>   <span class="hljs-keyword">private</span> Config config;   <span class="hljs-comment">// 添加文档来源</span>   <span class="hljs-meta">@Component</span>   <span class="hljs-meta">@Primary</span>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentationConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwaggerResourcesProvider</span> </span>&#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SwaggerResource&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;           config.addChangeListener(<span class="hljs-keyword">new</span> ConfigChangeListener() &#123;               <span class="hljs-comment">// 开启监听，配置文件发生改变需要更改</span>               <span class="hljs-meta">@Override</span>               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChange</span><span class="hljs-params">(ConfigChangeEvent configChangeEvent)</span> </span>&#123;                   get();               &#125;           &#125;);           <span class="hljs-keyword">return</span> resources();       &#125;       <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;SwaggerResource&gt; <span class="hljs-title">resources</span><span class="hljs-params">()</span></span>&#123;           List resources=<span class="hljs-keyword">new</span> ArrayList();           <span class="hljs-comment">// 网关使用服务别名获取远程服务的SwaggerApi</span>           String swaggerDocJson=swaggerDocument();           JSONArray jsonArray = JSONArray.parseArray(swaggerDocJson);           <span class="hljs-keyword">for</span> (Object object : jsonArray) &#123;               JSONObject jsonObject = (JSONObject) object;               String name = jsonObject.getString(<span class="hljs-string">"name"</span>);               String location = jsonObject.getString(<span class="hljs-string">"location"</span>);               String version = jsonObject.getString(<span class="hljs-string">"version"</span>);               resources.add(swaggerResource(name, location, version));           &#125;           <span class="hljs-keyword">return</span>  resources;       &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 获取swaggerDocument配置</span><span class="hljs-comment">        *</span><span class="hljs-comment">        * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">        */</span>       <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">swaggerDocument</span><span class="hljs-params">()</span> </span>&#123;           String property = config.getProperty(<span class="hljs-string">"mayikt.zuul.swaggerDocument"</span>, <span class="hljs-string">""</span>);           <span class="hljs-keyword">return</span> property;       &#125;       <span class="hljs-function"><span class="hljs-keyword">private</span> SwaggerResource <span class="hljs-title">swaggerResource</span><span class="hljs-params">(String name, String location, String version)</span> </span>&#123;           SwaggerResource swaggerResource = <span class="hljs-keyword">new</span> SwaggerResource();           swaggerResource.setName(name);           swaggerResource.setLocation(location);           swaggerResource.setSwaggerVersion(version);           <span class="hljs-keyword">return</span> swaggerResource;       &#125;   &#125;</code></pre><h5 id="6-阿波罗分布式配置中心监听"><a href="#6-阿波罗分布式配置中心监听" class="headerlink" title="6.阿波罗分布式配置中心监听"></a>6.阿波罗分布式配置中心监听</h5><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;<span class="hljs-meta">@ApolloConfig</span><span class="hljs-keyword">private</span> Config config;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;config.addChangeListener(<span class="hljs-keyword">new</span> ConfigChangeListener() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChange</span><span class="hljs-params">(ConfigChangeEvent changeEvent)</span> </span>&#123;log.debug(<span class="hljs-string">"####分布式配置中心监听#####"</span> + changeEvent.changedKeys().toString());&#125;&#125;);&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx相关资料</title>
    <link href="/2020/05/31/05%20Nginx%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/"/>
    <url>/2020/05/31/05%20Nginx%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>1.安装编译工具及库文件</p><pre><code class="hljs shell">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</code></pre><p>2.解压</p><pre><code class="hljs shell">tar -zxvf nginx.nginx-1.16.1.tar.gz</code></pre><p>3.编译，并指定目录</p><pre><code class="hljs shell">./configure --prefix=/usr/local/nginxmake &amp;&amp; make install</code></pre><p>4.启动</p><pre><code class="hljs shell">cd /usr/local/nginx/sbin<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 启动</span></span>./nginx<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 停止</span></span>./nginx -s stop</code></pre><h4 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 修改配置文件nginx.conf</span></span>server &#123;        listen       80;        server_name  localhost;<span class="hljs-meta">#</span><span class="bash"> </span>        location / &#123;            proxy_pass   http://127.0.0.1:8080;            index  index.html index.htm;        &#125;    &#125;</code></pre><h4 id="三、负载均衡"><a href="#三、负载均衡" class="headerlink" title="三、负载均衡"></a>三、负载均衡</h4><blockquote><p>五种负载均衡策略</p><p>1.轮训（default）：根据时间顺序分配不同服务器</p><p>2.权重：指定轮训机率，weight和访问比率成正比  </p><p>3.Ip绑定：固定ip访问</p><p>4.fair：第三方，根据服务响应时间分配</p><p>5.url_hash：第三方，按访问url的hash结果来分配请求 ，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效  </p><p>Nginx负载均衡提供上游服务器(真实业务逻辑访问的服务器),负载均衡、故障转移、失败重试、容错、健康检查等。</p><p>当上游服务器(真实业务逻辑访问的服务器)发生故障时，可以转移到其他上游服务器(真实业务逻辑访问的服务器)。</p></blockquote><p>1.upstream server配置</p><p>1.1 轮训</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##定义上游服务器(需要被nginx真实代理访问的服务器) 默认是轮训机制</span></span>upstream  backServer&#123;server 127.0.0.1:8080;server 127.0.0.1:8081;&#125;server &#123;listen       80;server_name  localhost;location / &#123;<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 指定上游服务器负载均衡服务器</span></span>proxy_pass http://backServer;index  index.html index.htm;&#125;&#125;</code></pre><p>1.2 权重</p><pre><code class="hljs shell"> upstream  backServer&#123;    server 127.0.0.1:8080 weight=1;    server 127.0.0.1:8081 weight=2;&#125;server &#123;       listen       80;       server_name  localhost;       location / &#123;    ### 指定上游服务器负载均衡服务器    proxy_pass http://backServer;           index  index.html index.htm;       &#125;   &#125;</code></pre><h4 id="nginx-conf详解"><a href="#nginx-conf详解" class="headerlink" title="nginx.conf详解"></a>nginx.conf详解</h4><pre><code class="hljs clean">##代码块中的events、http、server、location、upstream等都是块配置项####块配置项可以嵌套。内层块直接继承外层快，例如：server块里的任意配置都是基于http块里的已有配置的## ##Nginx worker进程运行的用户及用户组 #语法：user username[groupname]    默认：user nobody nobody#user用于设置master进程启动后，fork出的worker进程运行在那个用户和用户组下。当按照<span class="hljs-string">"user username;"</span>设置时，用户组名与用户名相同。#若用户在configure命令执行时，使用了参数--user=usergroup 和 --group=groupname,此时nginx.conf将使用参数中指定的用户和用户组。#user  nobody; ##Nginx worker进程个数：其数量直接影响性能。#每个worker进程都是单线程的进程，他们会调用各个模块以实现多种多样的功能。如果这些模块不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程，反之，有可能出现阻塞式调用，那么，需要配置稍多一些的worker进程。worker_processes  <span class="hljs-number">1</span>;##绑定Nginx worker进程到指定的CPU内核#语法：worker_cpu_affinity cpumask[cpumask...]#例如有<span class="hljs-number">4</span>个CPU内核#worker_cpu_affinity <span class="hljs-number">1000</span> <span class="hljs-number">0100</span> <span class="hljs-number">0010</span> <span class="hljs-number">0001</span>; ##ssl硬件加速。#用户可以用OpneSSL提供的命令来查看是否有ssl硬件加速设备：openssl engine -t#ssl_engine device;##系统调用gettimeofday的执行频率#语法： timer_resolution t##Nginx worker进程优先级设置#语法： worker_priority nice;#默认： worker_priority <span class="hljs-number">0</span>;##守护进程(daemon)。是脱离终端在后台允许的进程。它脱离终端是为了避免进程执行过程中的信息在任何终端上显示。这样一来，进程也不会被任何终端所产生的信息所打断。####关闭守护进程的模式，之所以提供这种模式，是为了方便跟踪调试nginx，毕竟用gdb调试进程时最繁琐的就是如何继续跟进fork出的子进程了。####如果用off关闭了master_proccess方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求#daemon off;   #查看是否以守护进程的方式运行Nginx 默认是on#master_process off; #是否以master/worker方式工作 默认是on ##error日志的设置##语法： error_log /path/file level;#默认： error_log / log/error.log error;#当path/file 的值为 /dev/null时，这样就不会输出任何日志了，这也是关闭error日志的唯一手段；#leve的取值范围是debug、info、notice、warn、error、crit、alert、emerg从左至右级别依次增大。#当level的级别为error时，error、crit、alert、emerg级别的日志就都会输出。大于等于该级别会输出，小于该级别的不会输出。#如果设定的日志级别是debug，则会输出所有的日志，这一数据量会很大，需要预先确保/path/file所在的磁盘有足够的磁盘空间。级别设定到debug，必须在configure时加入 --<span class="hljs-keyword">with</span>-debug配置项。#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;##用来帮助用户跟踪调试Nginx 接收两个参数stop和abort 通常不会使用#stop Nginx的代码执行到这些调试点就会发出SIGSTOP信号以用于调试#abort 会产生一个coredump文件，可以使用gdb来查看Nginx当时的各种信息#debug_points point[stop|abort]##限制coredump核心转储文件的大小#Nginx强制停止，将信息存储在core文件中，以做调试使用。一个core文件可能达到几GB，所以需要加以限制#语法：worker_rlimit_core size#worker_rlimit_core <span class="hljs-number">1</span>g;##指定coredump文件生成目录#语法：working_directory path;#working_directory ./core;##指定Nginx worker进程可以打开的最大句柄描述符个数#语法：worker_rlimit_nofile limit##设置每个用户发往Nginx的信号队列的大小。#也就是说用户的信号队列满了，再发送就会被丢失#语法：worker_rlimit_sigpending limit;##pid文件（master进程ID的pid文件存放路径）的路径#pid        logs/nginx.pid;##定义环境变量#语法：env VAR|VAR=VALUE#env TESTPATH=/tmp/;##是否打开accept锁 accept_mutex是Nginx的负载均衡锁#语法： accept_mutex[on|off]#默认： accept_mutext on;##lock文件的路径#语法： lock_file path/file;#默认： lock_file logs/nginx.lock;##使用accept锁后到真正建立连接之间的延迟时间#语法： accept_mutex_delay Nms;#默认： accept_mutex_delay <span class="hljs-number">500</span>ms;##批量建立新连接#语法： multi_accept[on|off];#默认： multi_accept off;##选择事件模型 #语法： use[kqueue|rtsig|epoll|/dev/poll|select|poll|eventport];#默认： Nginx会自动使用最适合的事件模型。#对于Linux操作系统来说， 可供选择的事件驱动模型有poll、 select、 epoll三种。 epoll当然是性能最高的一种，events &#123; #仅对指定的客户端输出debug级别的日志： 语法：debug_connection[IP|CIDR] #这个设置项实际上属于事件类配置，因此必须放在events&#123;……&#125;中才会生效。它的值可以是IP地址或者是CIRD地址。 #debug_connection <span class="hljs-number">10.224</span><span class="hljs-number">.66</span><span class="hljs-number">.14</span>;  #或是debug_connection <span class="hljs-number">10.224</span><span class="hljs-number">.57</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> #这样，仅仅以上IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。 #注意：在使用debug_connection前，需确保在执行configure时已经加入了--<span class="hljs-keyword">with</span>-debug参数，否则不会生效。 ##每个worker的最大连接数worker_connections  <span class="hljs-number">1024</span>;&#125; ##核心转储(coredump):在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容(核心映像)写入一个文件(core文件)，以作为调试只用，这就是所谓的核心转储(coredump). http &#123;##嵌入其他配置文件 语法：include /path/file#参数既可以是绝对路径也可以是相对路径（相对于Nginx的配置目录，即nginx.conf所在的目录）    include       mime.types;    default_type  application/octet-stream;     #log_format  main  <span class="hljs-string">'$remote_addr - $remote_user [$time_local] "$request" '</span>    #                  <span class="hljs-string">'$status $body_bytes_sent "$http_referer" '</span>    #                  <span class="hljs-string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;     #access_log  logs/access.log  main;     sendfile        on;    #tcp_nopush     on;     #keepalive_timeout  <span class="hljs-number">0</span>;    keepalive_timeout  <span class="hljs-number">65</span>;     #gzip  on;     server &#123;##listen监听的端口#语法：listen address:port [ default(deprecated <span class="hljs-keyword">in</span> <span class="hljs-number">0.8</span><span class="hljs-number">.21</span>) | default_server | [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]#default_server: 如果没有设置这个参数，那么将会以在nginx.conf中找到的第一个server块作为默认server块#backlog=num：表示TCP中backlog队列的大小，默认<span class="hljs-number">-1</span>，表示不予设置#rcvbuf=size： 设置监听句柄的SO_RCVBUF参数。#sndbuf=size： 设置监听句柄的SO_SNDBUF参数。#accept_filter： 设置accept过滤器， 只对FreeBSD操作系统有用#bind：绑定当前端口/地址，只有同时对一个端口监听多个地址时才会生效。#ssl： 在当前监听的端口上建立的连接必须基于SSL协议。listen       <span class="hljs-number">8080</span>; #主机名称：其后可以跟多个主机名称，开始处理一个HTTP请求时，nginx会取出header头中的Host，与每个server中的server_name进行匹配，以此决定到底由那一个server来处理这个请求。有可能一个Host与多个server块中的server_name都匹配，这时会根据匹配优先级来选择实际处理的server块。 server_name  localhost;         #charset koi8-r;         #access_log  logs/host.access.log  main;         #location / &#123;        #    root   html;                ##用来设置文件资源路径的#语法： alias path;#配置块： location#alias usr/local/nginx/conf/;        #    index  index.html index.htm;        #&#125;                ##若请求的URI是/download/index/test.html， 那服务器就会返回服务器上optwebhtml、download/index/test.html文件的内容。        #location /download/ &#123;#root optwebhtml;#&#125; ##location 语法： location [=|~|~*|^~|@]/uri/ &#123; ... &#125;#注意：location时有顺序的，当一个请求有可能匹配多个location时，实际上这个请求会被第一个location处理。location / &#123;proxy_pass http:<span class="hljs-comment">//192.168.1.60;</span>    &#125;        ##按HTTP方法名限制用户请求#语法： limit_except method...&#123;...&#125;#配置块： location#方法名可取值包括： GET、HEAD、 POST、 PUT、 DELETE、 MKCOL、 COPY、 MOVE、 OPTIONS、 PROPFIND、PROPPATCH、 LOCK、 UNLOCK或者PATCH。 #limit_except GET &#123;#allow <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">32</span>;#deny all;#&#125;#注意， 允许GET方法就意味着也允许HEAD方法。 因此， 上面这段代码表示的是禁止GET方法和HEAD方法， 但其他HTTP方法是允许的。 ##根据HTTP返回码重定向页面#语法：error_page <span class="hljs-keyword">code</span>[<span class="hljs-keyword">code</span>...][=|=answer-<span class="hljs-keyword">code</span>]uri|@named_location#配置块： http、 server、 location、 <span class="hljs-keyword">if</span>        #error_page  <span class="hljs-number">404</span>              /<span class="hljs-number">404.</span>html;        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;                ##是否允许递归使用error_page#语法： recursive_error_pages[on|off];#默认： recursive_error_pages off;#配置块： http、 server、 location##尝试按照顺序访问每一个path， 如果可以有效地读取， 就直接向用户返回这个path对应的文件结束请求， 否则继续向下访问。 如果所有的path都找不到有效的文件， 就重定向到最后的参数uri上。 #因此最后一个path必须有url参数#语法： try_files path1[path2]uri;#配置块： server、 location                location = /<span class="hljs-number">50</span>x.html &#123;            root   html;        &#125;                ##为了提高快速寻找到相应server name的能力， Nginx使用散列表来存储server name。#server_names_hash_bucket_size设置了每个散列桶占用的内存大小。    #语法： server_names_hash_bucket_size size;#默认： server_names_hash_bucket_size <span class="hljs-number">32</span>|<span class="hljs-number">64</span>|<span class="hljs-number">128</span>;#配置块： http、 server、 location##server_names_hash_max_size会影响散列表的冲突率。 server_names_hash_max_size越大，消耗的内存就越多， 但散列key的冲突率则会降低， 检索速度也更快。#语法： server_names_hash_max_size size;#默认： server_names_hash_max_size <span class="hljs-number">512</span>;#配置块： http、 server、 location##重定向主机名称的处理#该配置需要配合server_name使用。 在使用on打开时， 表示在重定向请求时会使用server_name里配置的第一个主机名代替原先请求中的Host头部， 而使用off关闭时， 表示在重定向请求时使用请求本身的Host头部。#语法： server_name_in_redirect on|off;#默认： server_name_in_redirect on;#配置块： http、 server或者location##HTTP包体只存储到磁盘文件中#当值为非off时， 用户请求中的HTTP包体一律存储到磁盘文件中， 即使只有<span class="hljs-number">0</span>字节也会存储为文件。 当请求结束时， 如果配置为on， 则这个文件不会被删除（该配置一般用于调试、定位问题） ， 但如果配置为clean， 则会删除该文件。#语法： client_body_in_file_only on|clean|off;#默认： client_body_in_file_only off;#配置块： http、 server、 location##HTTP包体尽量写入到一个内存buffer中#用户请求中的HTTP包体一律存储到内存buffer中。 当然， 如果HTTP包体的大小超过了下面client_body_buffer_size设置的值， 包体还是会写入到磁盘文件中。#语法： client_body_in_single_buffer on|off;#默认： client_body_in_single_buffer off;#配置块： http、 server、 location##存储HTTP头部的内存buffer大小#语法： client_header_buffer_size size;#默认： client_header_buffer_size <span class="hljs-number">1</span>k;#配置块： http、 server##存储超大HTTP头部的内存buffer大小#语法： large_client_header_buffers number size;#默认： large_client_header_buffers <span class="hljs-number">48</span>k;#配置块： http、 server##存储HTTP包体的内存大小#语法： client_body_buffer_siz size#默认： client_body_buffer_siz <span class="hljs-number">8</span>k/<span class="hljs-number">16</span>k;#配置块：http、 server、 location##HTTP包体的临时存放目录#语法： client_body_temp_path dir-path[level1[level2[level3]]]#默认： client_body_temp_path client_body_temp;#配置块： http、 server、 location##指定内存池的初始大小#语法： connection_pool_size size;#默认： connection_pool_size <span class="hljs-number">256</span>;#配置块： http、 server##指定每个请求的内存池大小#语法： request_pool_size size;#默认： request_pool_size <span class="hljs-number">4</span>k;#配置块： http、 server##读取HTTP头部的超时时间#语法： client_header_timeout time（默认单位： 秒） ;#默认： client_header_timeout <span class="hljs-number">60</span>;#配置块： http、 server、 location##读取HTTP包体的超时时间#语法： client_body_timeout time（默认单位： 秒） ；#默认： client_body_timeout <span class="hljs-number">60</span>;#配置块： http、 server、 location##发送响应的超时时间#语法： send_timeout time;#默认： send_timeout <span class="hljs-number">60</span>;#配置块： http、 server、 location##连接超时后将通过向客户端发送RST包来直接重置连接#语法： reset_timeout_connection on|off;#默认： reset_timeout_connection off;#配置块： http、 server、 location##该配置控制Nginx关闭用户连接的方式。#语法： lingering_close off|on|always;#默认： lingering_close on;#配置块： http、 server、 location##lingering_close启用后， 这个配置项对于上传大文件很有用#语法： lingering_time time;#默认： lingering_time <span class="hljs-number">30</span>s;配置块： http、 server、 location##lingering_close生效后， 在关闭连接前， 会检测是否有用户发送的数据到达服务器， 如果超过lingering_timeout时间后还没有数据可读， 就直接关闭连接； 否则， 必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。#语法： lingering_timeout time;#默认： lingering_timeout <span class="hljs-number">5</span>s;#配置块： http、 server、 location##对某些浏览器禁用keepalive功能#语法： keepalive_disable[msie6|safari|none]...#默认： keepalive_disablemsie6 safari#配置块： http、 server、 location##keepalive超时时间#语法： keepalive_timeout time（默认单位： 秒） ;#默认： keepalive_timeout <span class="hljs-number">75</span>;#配置块： http、 server、 location##一个keepalive长连接上允许承载的请求最大数#语法： keepalive_requests n;#默认： keepalive_requests <span class="hljs-number">100</span>;#配置块： http、 server、 location##确定对keepalive连接是否使用TCP_NODELAY选项#语法： tcp_nodelay on|off;#默认： tcp_nodelay on;#配置块： http、 server、 location##在打开sendfile选项时， 确定是否开启FreeBSD系统上的TCP_NOPUSH或Linux系统上的TCP_CORK功能。 打开tcp_nopush后， 将会在发送响应时把整个响应包头放到一个TCP包中发送。#语法： tcp_nopush on|off;#默认： tcp_nopush off;#配置块： http、 server、 location##HTTP请求包体的最大值#语法： client_max_body_size size;#默认： client_max_body_size <span class="hljs-number">1</span>m;#配置块： http、 server、 location##对请求的限速#此配置是对客户端请求限制每秒传输的字节数。默认参数为<span class="hljs-number">0</span>， 表示不限速。#语法： limit_rate speed;#默认： limit_rate <span class="hljs-number">0</span>;#配置块： http、 server、 location、 <span class="hljs-keyword">if</span>##Nginx向客户端发送的响应长度超过limit_rate_after后才开始限速#语法： limit_rate_after time;#默认： limit_rate_after <span class="hljs-number">1</span>m;#配置块： http、 server、 location、 <span class="hljs-keyword">if</span>##sendfile系统调用#语法： sendfile on|off;#默认： sendfile off;#配置块： http、 server、 location##AIO系统调用        #语法： aio on|off;        #默认： aio off;        #配置块： http、 server、 location                ##此配置项在FreeBSD和Linux系统上使用O_DIRECT选项去读取文件， 缓冲区大小为size，通常对大文件的读取速度有优化作用。 #注意， 它与sendfile功能是互斥的。        #语法： directio size|off;        #默认： directio off;        #配置块： http、 server、 location##指定以directio方式读取文件时的对齐方式#它与directio配合使用        #语法： directio_alignment size;        #默认： directio_alignment <span class="hljs-number">512</span>;        #配置块： http、 server、 location##打开文件缓存        #语法： open_file_cache max=N[inactive=time]|off;        #默认： open_file_cache off;        #配置块： http、 server、 location                ##是否缓存打开文件错误的信息#语法： open_file_cache_errors on|off;#默认： open_file_cache_errors off;#配置块： http、 server、 location##不被淘汰的最小访问次数#它与open_file_cache中的inactive参数配合使用#语法： open_file_cache_min_uses number;#默认： open_file_cache_min_uses <span class="hljs-number">1</span>;#配置块： http、 server、 location##检验缓存中元素有效性的频率#默认为每<span class="hljs-number">60</span>秒检查一次缓存中的元素是否仍有效#语法： open_file_cache_valid time;#默认： open_file_cache_valid <span class="hljs-number">60</span>s;#配置块： http、 server、 location##忽略不合法的HTTP头部#语法： ignore_invalid_headers on|off;#默认： ignore_invalid_headers on;#配置块： http、 server##HTTP头部是否允许下划线#语法： underscores_in_headers on|off;#默认： underscores_in_headers off;#配置块： http、 server##对If-Modified-Since头部的处理策略        #语法： if_modified_since[off|exact|before];        #默认： if_modified_since exact;        #配置块： http、 server、 location                ##文件未找到时是否记录到error日志        #语法： log_not_found on|off;        #默认： log_not_found on;        #配置块： http、 server、 location                ##是否合并相邻的“”        #语法： merge_slashes on|off;        #默认： merge_slashes on;        #配置块： http、 server、 location##DNS解析地址        #语法： resolver address...;        #配置块： http、 server、 location                ##DNS解析的超时时间        #语法： resolver_timeout time;        #默认： resolver_timeout <span class="hljs-number">30</span>s;        #配置块： http、 server、 location                ##返回错误页面时是否在Server中注明Nginx版本        #语法： server_tokens on|off;        #默认： server_tokens on;        #配置块： http、 server、 location        --------------------负载均衡、反向代理----------------------------                        ##upstream块，定义一个上游服务器集群#语法： upstream name&#123;...&#125;#配置块： httpupstream backserver&#123;##上游服务名可以为域名、ip端口#参数说明：- weight=<span class="hljs-number">1</span> 权重；- max_fails=<span class="hljs-number">1</span>与fail_time=<span class="hljs-number">10</span>s配合使用，表示在<span class="hljs-number">10</span>s内，上游服务器失败次数超过<span class="hljs-number">1</span>次，则不可用- down：表示所在的上游服务器永久下线，只能使用ip_hash配置项时才能用- backup：在使用ip_hash配置项时它是无效的，指备份服务器，表示所有非备份服务器都失效，才会执行server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>:<span class="hljs-number">90</span>;##ip_hash 有效地管理集群中相同的缓存信息#ip_hash与weight配置不可同时使用ip_hash;&#125;##反向代理的基本配置#proxy_pass#语法： proxy_pass URL;#配置块： location、 <span class="hljs-keyword">if</span>location / &#123;proxy_pass http:<span class="hljs-comment">//backserver; #配置负载均衡</span>#proxy_pass http:<span class="hljs-comment">//localhost:8080/test</span>#注：默认情况，反向代理不会转发请求中的Host头部，如需，添加proxy_set_header Host $host;#proxy_method表示转发时的协议方法名。            #语法： proxy_method method;#配置块： http、 server、 locationproxy_method POST; #发来get请求，也会转化成POST#proxy_hide_header 指定HTTP头部字段哪些可以转发，默认不会转发#语法： proxy_hide_header the_header;#配置块： http、 server、 locationproxy_hide_header Cache-Control;proxy_hide_header MicrosoftOfficeWebServer;#proxy_pass_header：将原来禁止转发的header设置为允许转发#语法： proxy_pass_header the_header;#配置块： http、 server、 locationproxy_pass_header X-Accel-Redirect;#proxy_pass_request_body：确定是否向上游服务器发送HTTP包体部分#语法： proxy_pass_request_body on|off;#默认： proxy_pass_request_body on;#配置块： http、 server、 locationproxy_pass_request_body off;#proxy_pass_request_headers:确定是否转发HTTP头部#语法： proxy_pass_request_headers on|off;#默认： proxy_pass_request_headers on;#配置块： http、 server、 location#proxy_redirect:当上游服务器返回的响应是重定向或刷新请求（<span class="hljs-number">301</span>或者<span class="hljs-number">302</span>） 时，proxy_redirect可以重设HTTP头部的location或refresh字段。#语法： proxy_redirect[default|off|redirect replacement];#参数解释：off：使location或者refresh字段维持不变。#默认： proxy_redirect default;#配置块： http、 server、 locationproxy_redirect off;#proxy_next_upstream：当一台上游服务转发请求出现错误时，继续换一台上游服务器转发请求#语法：proxy_next_upstream[error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off];#默认： proxy_next_upstream error timeout;#配置块： http、 server、 locationproxy_next_upstream timeout;&#125;    &#125; &#125;</code></pre><p>server_name与Host的匹配优先级</p><table><thead><tr><th>server_name与Host的匹配优先级</th><th>案例</th></tr></thead><tbody><tr><td>首先选择所有字符串完全匹配的server_name</td><td>如：<a href="http://www.testwab.com" target="_blank" rel="noopener">www.testwab.com</a></td></tr><tr><td>其次选择通配符在前面的server_name</td><td>如：*.testwab.com</td></tr><tr><td>其次选择通配符在后面的server_name</td><td>如：<a href="http://www.testwab" target="_blank" rel="noopener">www.testwab</a>.*</td></tr><tr><td>最后选择使用正在表达式才匹配的server_name</td><td>最后选择使用正在表达式才匹配的server_name</td></tr></tbody></table><p>location的匹配规则  </p><table><thead><tr><th align="center">符号</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">表示把URI作为字符串， 以便与参数中的uri做完全匹配。</td></tr><tr><td align="center">~</td><td align="center">表示匹配URI时是字母大小写敏感的</td></tr><tr><td align="center">~*</td><td align="center">表示匹配URI时忽略字母大小写问题</td></tr><tr><td align="center">^~</td><td align="center">表示匹配URI时只需要其前半部分与uri参数匹配即可</td></tr><tr><td align="center">@</td><td align="center">仅用于Nginx服务内部请求之间的重定向， 带有@的location不直接处理用户请求</td></tr></tbody></table><p>root和alias区别</p><blockquote><p>如果有一个请求的URI是/conf/nginx.conf， 而用户实际想访问的文件<br>在usr/local/nginx/conf/nginx.conf。 </p><p>alias：</p><p>alias在实际文件路径的映射过程中，已经将location后配置的/conf这部分去掉了</p><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">conf</span> &#123;alias usr/local/nginx/conf/;&#125;</code></pre><p>root:</p><p>而root没有去掉，这也是root可以放置到其他http、server等中，而alias只能放置location中的原因</p><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">conf</span>&#123;root usr/local/nginx/;&#125;</code></pre><p>alias还可以添加正则表达式：</p><pre><code class="hljs elixir">location ~ ^<span class="hljs-regexp">/test/</span>(\w+)\.(\w+)<span class="hljs-variable">$ </span>&#123;<span class="hljs-keyword">alias</span> usrlocal/nginx/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$1</span>.<span class="hljs-variable">$2</span>;&#125;</code></pre><p>请求访问/test/nginx.conf时，返回usr/local/nginx/conf/nginx.conf</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Liunx</tag>
      
      <tag>Nginx</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>携程阿波罗分布式配置中心</title>
    <link href="/2020/05/31/04%20%E6%90%BA%E7%A8%8B%E9%98%BF%E6%B3%A2%E7%BD%97%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/05/31/04%20%E6%90%BA%E7%A8%8B%E9%98%BF%E6%B3%A2%E7%BD%97%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h4 id="1-为什么要使用分布式配置中心？"><a href="#1-为什么要使用分布式配置中心？" class="headerlink" title="1.为什么要使用分布式配置中心？"></a>1.为什么要使用分布式配置中心？</h4><blockquote><p>统一管理微服务配置文件，可以实现动态刷新配置文件。</p><p>SpringCloudConfig与阿波罗的区别：</p><p>前者是将配置存放到git和数据库（1.3.4以后版本）中，后者是将配置存放到数据库中。</p></blockquote><h4 id="2-搭建分布式配置中心阿波罗"><a href="#2-搭建分布式配置中心阿波罗" class="headerlink" title="2.搭建分布式配置中心阿波罗"></a>2.搭建分布式配置中心阿波罗</h4><blockquote><p>1.下载aplolo配置中心 </p><pre><code class="hljs url">https:&#x2F;&#x2F;github.com&#x2F;nobodyiam&#x2F;apollo-build-scripts</code></pre><p>2.上传到服务器中，并解压</p><pre><code class="hljs shell">unzip apollo-build-scripts-master.zip<span class="hljs-meta">#</span><span class="bash"> 若无unzip命令，需安装</span>yum -y install zip unzip</code></pre><p>3.创建数据库</p><p>执行sql目录中的两个sql文件</p><p>sql/apolloportaldb.sql<br>sql/apolloconfigdb.sql </p><p>4.配置demo.sh文件</p><pre><code class="hljs sh"><span class="hljs-comment">#apollo config db info</span>apollo_config_db_url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8apollo_config_db_username=用户名apollo_config_db_password=密码（如果没有密码，留空即可）<span class="hljs-comment"># apollo portal db info</span>apollo_portal_db_url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8apollo_portal_db_username=用户名apollo_portal_db_password=密码（如果没有密码，留空即可）</code></pre><p>5.修改服务器端口地址信息</p><pre><code class="hljs sh"><span class="hljs-comment">#将地址改为服务器IP地址 </span>config_server_url=http://10.168.16.125:8080admin_server_url=http://10.168.16.125:8090portal_url=http://10.168.16.125:8070</code></pre><p>5.启动执行脚本（在此之前，确保8080、8090、8070端口未被占用）</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入解压文件的根目录</span>./demo.sh start<span class="hljs-meta">#</span><span class="bash">若出现权限不足，需执行</span>chmod 777 ./demo.sh</code></pre></blockquote><h4 id="3-进入Apollo配置中心"><a href="#3-进入Apollo配置中心" class="headerlink" title="3.进入Apollo配置中心"></a>3.进入Apollo配置中心</h4><p><a href="http://ip:8070" target="_blank" rel="noopener">http://ip:8070</a></p><p>默认账号密码 Apollo  admin</p><h4 id="4-服务客户端集成配置文件"><a href="#4-服务客户端集成配置文件" class="headerlink" title="4.服务客户端集成配置文件"></a>4.服务客户端集成配置文件</h4><blockquote><p>1.将本地配置文件信息导入阿波罗配置中心</p><p>yml转换properties文件：<a href="http://www.toyaml.com/index.html" target="_blank" rel="noopener">http://www.toyaml.com/index.html</a></p><p>2.在项目中引入依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--阿波罗配置中心依赖--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apollo-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apollo-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>3.创建application.properties文件</p><pre><code class="hljs properties"><span class="hljs-meta">app.id</span>=<span class="hljs-string">app_test   ##阿波罗配置中心中与项目相对于AppId</span><span class="hljs-meta">apollo.meta</span>=<span class="hljs-string">http://ip:8080 ##阿波罗ip地址</span></code></pre><p>4.启动类中加入@EnableApolloConfig注解</p><p>5.运行测试</p></blockquote><h4 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h4><p>不是所有的配置文件都会在阿波罗平台修改后，就会立马生效，因为没有采用监听刷新配置文件。</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud Gateway</title>
    <link href="/2020/05/31/03%20SpringCloud%20Gateway/"/>
    <url>/2020/05/31/03%20SpringCloud%20Gateway/</url>
    
    <content type="html"><![CDATA[<h3 id="Nacos整合SpringCloud"><a href="#Nacos整合SpringCloud" class="headerlink" title="Nacos整合SpringCloud"></a>Nacos整合SpringCloud</h3><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/nacos-example" target="_blank" rel="noopener">https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/nacos-example</a></p><h4 id="1-什么是Nacos？"><a href="#1-什么是Nacos？" class="headerlink" title="1.什么是Nacos？"></a>1.什么是Nacos？</h4><blockquote><p><a href="https://github.com/alibaba/Nacos" target="_blank" rel="noopener">Nacos</a> 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p></blockquote><h4 id="2-Nacos-Config整合"><a href="#2-Nacos-Config整合" class="headerlink" title="2.Nacos Config整合"></a>2.Nacos Config整合</h4><blockquote><p>Nacos Config Starter实现Spring Cloud应用程序的外部化配置。</p></blockquote><h5 id="2-1-启动-Nacos-Server-并添加配置"><a href="#2-1-启动-Nacos-Server-并添加配置" class="headerlink" title="2.1 启动 Nacos Server 并添加配置"></a>2.1 启动 Nacos Server 并添加配置</h5><blockquote><p>1.下载地址：</p><ol><li>直接下载：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">Nacos Server 下载页</a></li><li>源码构建：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">Github 项目页面</a></li></ol><p>2.启动</p><ol><li>Linux/Unix/Mac 操作系统，执行命令 <code>sh startup.sh -m standalone</code></li><li>Windows 操作系统，执行命令 <code>cmd startup.cmd</code></li><li>默认账户密码：nacos</li></ol><p>3.在命令行执行如下命令，向 Nacos Server 中添加一条配置，也可在控制台中手动添加。</p><pre><code class="hljs shell">curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos-config-example.properties&amp;group=DEFAULT_GROUP&amp;content=user.id=1%0Auser.name=james%0Auser.age=17"</code></pre><p>添加的配置的详情如下</p><pre><code class="hljs properties"><span class="hljs-attr">dataId</span> <span class="hljs-string">为 nacos-config-example.properties</span><span class="hljs-attr">group</span> <span class="hljs-string">为 DEFAULT_GROUP</span><span class="hljs-attr">内容如下</span><span class="hljs-meta">user.id</span>=<span class="hljs-string">1</span><span class="hljs-meta">user.name</span>=<span class="hljs-string">james</span><span class="hljs-meta">user.age</span>=<span class="hljs-string">17</span></code></pre><p>访问：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p><img src="https://img-blog.csdnimg.cn/20190603110735458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-1-引入pom文件"><a href="#2-1-引入pom文件" class="headerlink" title="2.1 引入pom文件"></a>2.1 引入pom文件</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="2-2-添加bootstrap-properties"><a href="#2-2-添加bootstrap-properties" class="headerlink" title="2.2 添加bootstrap.properties"></a>2.2 添加bootstrap.properties</h5><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">nacos-config-example</span><span class="hljs-meta">spring.cloud.nacos.config.server-addr</span>=<span class="hljs-string">ip:8848 #服务器ip或本地ip</span></code></pre><h5 id="2-3-获取相应的配置"><a href="#2-3-获取相应的配置" class="headerlink" title="2.3 获取相应的配置"></a>2.3 获取相应的配置</h5><pre><code class="hljs java"><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">//打开动态刷新功能</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleController</span> </span>&#123; <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.name&#125;"</span>) String userName; <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.age&#125;"</span>) <span class="hljs-keyword">int</span> age; &#125;</code></pre><h5 id="2-4-应用启动"><a href="#2-4-应用启动" class="headerlink" title="2.4 应用启动"></a>2.4 应用启动</h5><blockquote><p>1.添加/application.properties </p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">18084</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>2.App启动<br><img src="https://img-blog.csdnimg.cn/20190603120015889.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-5-原理"><a href="#2-5-原理" class="headerlink" title="2.5 原理"></a>2.5 原理</h5><blockquote><h4 id="1-Nacos-Config-数据结构"><a href="#1-Nacos-Config-数据结构" class="headerlink" title="1.Nacos Config 数据结构"></a>1.Nacos Config 数据结构</h4><p>Nacos Config 主要通过 dataId 和 group 来唯一确定一条配置.</p><p>Nacos Client 从 Nacos Server 端获取数据时，调用的是此接口 <code>ConfigService.getConfig(String dataId, String group, long timeoutMs)</code>。</p><h4 id="2-Spring-Cloud-应用获取数据"><a href="#2-Spring-Cloud-应用获取数据" class="headerlink" title="2.Spring Cloud 应用获取数据"></a>2.Spring Cloud 应用获取数据</h4><h5 id="dataId"><a href="#dataId" class="headerlink" title="dataId"></a>dataId</h5><p>在 Nacos Config Starter 中，dataId 的拼接格式如下</p><pre><code class="hljs properties"><span class="hljs-meta">$&#123;prefix&#125;</span> <span class="hljs-string">- $&#123;spring.profiles.active&#125; . $&#123;file-extension&#125;</span></code></pre><ul><li><p><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</p></li><li><p><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" target="_blank" rel="noopener">Spring Boot文档</a></p><p><strong>注意，当 activeprofile 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</strong></p></li><li><p><code>file-extension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code>来配置。 目前只支持 <code>properties</code> 类型。</p></li></ul><h5 id="group"><a href="#group" class="headerlink" title="group"></a>group</h5><ul><li><code>group</code> 默认为 <code>DEFAULT_GROUP</code>，可以通过 <code>spring.cloud.nacos.config.group</code> 配置。</li></ul><h4 id="3-自动注入"><a href="#3-自动注入" class="headerlink" title="3.自动注入"></a>3.自动注入</h4><p>Nacos Config Starter 实现了 <code>org.springframework.cloud.bootstrap.config.PropertySourceLocator</code>接口，并将优先级设置成了最高。</p><p>在 Spring Cloud 应用启动阶段，会主动从 Nacos Server 端获取对应的数据，并将获取到的数据转换成 PropertySource 且注入到 Environment 的 PropertySources 属性中，所以使用 @Value 注解也能直接获取 Nacos Server 端配置的内容。</p><h4 id="4-动态刷新"><a href="#4-动态刷新" class="headerlink" title="4.动态刷新"></a>4.动态刷新</h4><p>Nacos Config Starter 默认为所有获取数据成功的 Nacos 的配置项添加了监听功能，在监听到服务端配置发生变化时会实时触发 <code>org.springframework.cloud.context.refresh.ContextRefresher</code> 的 refresh 方法 。</p><p>如果需要对 Bean 进行动态刷新，给类添加 <code>@RefreshScope</code> 或 <code>@ConfigurationProperties</code>注解。</p><h4 id="5-Endpoint-信息查看"><a href="#5-Endpoint-信息查看" class="headerlink" title="5.Endpoint 信息查看"></a>5.Endpoint 信息查看</h4><p>Springboot支持这一点，Nacos Config也同时可以使用Endpoint来暴露信息。</p><p>在maven 中添加 <code>spring-boot-starter-actuator</code>依赖，并在配置中允许 Endpoints 的访问。</p><ul><li>Spring Boot 1.x 中添加配置 management.security.enabled=false</li><li>Spring Boot 2.x 中添加配置 management.endpoints.web.exposure.include=*</li></ul><p>Spring Boot 1.x 可以通过访问 <a href="http://127.0.0.1:18084/nacos_config" target="_blank" rel="noopener">http://127.0.0.1:18084/nacos_config</a> 来查看 Nacos Endpoint 的信息。</p><p>Spring Boot 2.x 可以通过访问 <a href="http://127.0.0.1:18084/actuator/nacos-config" target="_blank" rel="noopener">http://127.0.0.1:18084/actuator/nacos-config</a> 来访问。<br><img src="https://img-blog.csdnimg.cn/20190603121130239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-6-更多"><a href="#2-6-更多" class="headerlink" title="2.6 更多"></a>2.6 更多</h5><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>key</td><td>默认值</td><td>说明</td></tr><tr><td>服务端地址</td><td>spring.cloud.nacos.config.server-addr</td><td></td><td></td></tr><tr><td>DataId前缀</td><td>spring.cloud.nacos.config.prefix</td><td></td><td>spring.application.name</td></tr><tr><td>Group</td><td>spring.cloud.nacos.config.group</td><td>DEFAULT_GROUP</td><td></td></tr><tr><td>dataID后缀及内容文件格式</td><td>spring.cloud.nacos.config.file-extension</td><td>properties</td><td>dataId的后缀，同时也是配置内容的文件格式，目前只支持 properties</td></tr><tr><td>配置内容的编码方式</td><td>spring.cloud.nacos.config.encode</td><td>UTF-8</td><td>配置的编码</td></tr><tr><td>获取配置的超时时间</td><td>spring.cloud.nacos.config.timeout</td><td>3000</td><td>单位为 ms</td></tr><tr><td>配置的命名空间</td><td>spring.cloud.nacos.config.namespace</td><td></td><td>常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。</td></tr><tr><td>AccessKey</td><td>spring.cloud.nacos.config.access-key</td><td></td><td></td></tr><tr><td>SecretKey</td><td>spring.cloud.nacos.config.secret-key</td><td></td><td></td></tr><tr><td>相对路径</td><td>spring.cloud.nacos.config.context-path</td><td></td><td>服务端 API 的相对路径</td></tr><tr><td>接入点</td><td>spring.cloud.nacos.config.endpoint</td><td>UTF-8</td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td>是否开启监听和自动刷新</td><td>spring.cloud.nacos.config.refresh.enabled</td><td>true</td><td></td></tr></tbody></table><h4 id="3-Nacos-Discovery-整合"><a href="#3-Nacos-Discovery-整合" class="headerlink" title="3.Nacos Discovery 整合"></a>3.Nacos Discovery 整合</h4><blockquote><p>Nacos Discovery Starter 完成 Spring Cloud 应用的服务注册与发现。</p></blockquote><h5 id="3-1-添加依赖"><a href="#3-1-添加依赖" class="headerlink" title="3.1 添加依赖"></a>3.1 添加依赖</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="3-2-application-properties"><a href="#3-2-application-properties" class="headerlink" title="3.2 application.properties"></a>3.2 application.properties</h5><pre><code class="hljs properties"><span class="hljs-meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span></code></pre><h5 id="3-3-服务注册和发现"><a href="#3-3-服务注册和发现" class="headerlink" title="3.3 服务注册和发现"></a>3.3 服务注册和发现</h5><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>; &#125; <span class="hljs-meta">@RestController</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoController</span> </span>&#123; <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo/&#123;string&#125;"</span>, method = RequestMethod.GET) <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(@PathVariable String string)</span> </span>&#123; <span class="hljs-keyword">return</span> string; &#125; &#125; &#125;</code></pre><h5 id="3-4-启动Nacos服务端"><a href="#3-4-启动Nacos服务端" class="headerlink" title="3.4 启动Nacos服务端"></a>3.4 启动Nacos服务端</h5><blockquote><ol><li>通过从源代码下载或构建来安装Nacos Server。<strong>推荐的最新版本Nacos Server</strong><ol><li>下载Nacos Server <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">下载页面</a></li><li>从源代码构建：通过git clone <a href="mailto:git@github.com">git@github.com</a>获取源代码：来自Github Nacos的alibaba / Nacos.git并构建您的代码。有关详细信息，请参阅<a href="https://nacos.io/en-us/docs/quick-start.html" target="_blank" rel="noopener">构建</a></li></ol></li><li>运行<ol><li>Linux / Unix / Mac，执行 <code>sh startup.sh -m standalone</code></li><li>Windows，执行 <code>cmd startup.cmd</code></li></ol></li></ol></blockquote><h5 id="3-5-启动客户端"><a href="#3-5-启动客户端" class="headerlink" title="3.5 启动客户端"></a>3.5 启动客户端</h5><blockquote><p>1.添加application.properties配置</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">service-provider</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">18082</span></code></pre></blockquote><h5 id="3-6-查询服务"><a href="#3-6-查询服务" class="headerlink" title="3.6 查询服务"></a>3.6 查询服务</h5><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8848</span><span class="hljs-regexp">/nacos/</span>v1<span class="hljs-regexp">/ns/i</span>nstances?serviceName=service-provider</code></pre><p><img src="https://img-blog.csdnimg.cn/20190603122655648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="3-7-服务发现"><a href="#3-7-服务发现" class="headerlink" title="3.7 服务发现"></a>3.7 服务发现</h5><p>Nacos Discovery Starter默认集成了Ribbon，因此对于使用Ribbon进行负载平衡的组件，您可以直接使用Nacos服务发现。</p><p>NacosServerList实现com.netflix.loadbalancer.ServerList接口并在@ConditionOnMissingBean下自动注入它。</p><blockquote><h4 id="使用RestTemplate和FeignClient"><a href="#使用RestTemplate和FeignClient" class="headerlink" title="使用RestTemplate和FeignClient"></a>使用RestTemplate和FeignClient</h4><ol><li><p>添加@LoadBlanced注释以使Ribbon可以访问RestTemplate</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre></li><li><p>FeignClient默认集成了功能区，显示了如何配置FeignClient。</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"service-provider"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EchoService</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function">String <span class="hljs-title">echo</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"str"</span>)</span> String str)</span>;&#125;</code></pre><p>使用@FeignClient批注将<code>EchoService</code>接口包装为FeignClient，其属性名称对应于服务名称<code>service-provider</code>。</p><p>方法的<code>@RequestMapping</code>注释<code>echo</code>将echo方法与URL对应<code>/echo/{str}</code>，<code>@PathVariable</code>注释映射<code>{str}</code>到<code>str</code>echo方法的参数的URL路径中。</p></li><li><p>完成上述配置后，将它们注入TestController。</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> EchoService echoService;       <span class="hljs-comment">//RestTemplate</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo-rest/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rest</span><span class="hljs-params">(@PathVariable String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://service-provider/echo/"</span> + str, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-comment">//FeignClient</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo-feign/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">feign</span><span class="hljs-params">(@PathVariable String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> echoService.echo(str);    &#125;&#125;</code></pre></li><li><p>添加application.properties配置</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">service-consumer</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">18083</span></code></pre></li><li><p>运行</p></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><code>http://127.0.0.1:18083/echo-rest/1234</code>在浏览器地址栏中输入并单击转到，我们可以看到浏览器显示nacos-discovery-provider-example返回的消息“hello Nacos Discovery 1234”，以证明服务发现有效。</li></ol><p><a href="https://camo.githubusercontent.com/0806773157ca6926e08a5e664ee493fc016ba003/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363330323132342d65653237363730642d626463632d343231302d396635642d3837356163656336643365612e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0806773157ca6926e08a5e664ee493fc016ba003/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363330323132342d65653237363730642d626463632d343231302d396635642d3837356163656336643365612e706e67" srcset="/img/loading.gif" alt="休息"></a></p><ol><li><code>http://127.0.0.1:18083/echo-feign/12345</code>在浏览器地址栏中输入并单击转到，我们可以看到浏览器显示nacos-discovery-provider-example返回的消息“hello Nacos Discovery 12345”，以证明服务发现有效。</li></ol><p><a href="https://camo.githubusercontent.com/652b6b245a939372c1950a655a07acb994c55f26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331313638352d36643063316639622d613435332d346563332d383861622d6637393232643231306636352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/652b6b245a939372c1950a655a07acb994c55f26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331313638352d36643063316639622d613435332d346563332d383861622d6637393232643231306636352e706e67" srcset="/img/loading.gif" alt="假装"></a></p></blockquote><h5 id="3-8-原理"><a href="#3-8-原理" class="headerlink" title="3.8 原理"></a>3.8 原理</h5><blockquote><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在Spring云应用程序的启动阶段，将监视WebServerInitializedEvent事件。在初始化Web容器后收到WebServerInitializedEvent事件时，将触发注册操作，并调用ServiceRegistry注册方法以将服务注册到Nacos Server。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>NacosServerList实现com.netflix.loadbalancer.ServerList接口并在@ConditionOnMissingBean下自动注入它。功能区默认为集成。</p><h2 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h2><p>Nacos Discovery Starter还支持Spring Boot执行器端点的实现。</p><p><strong>先决条件：</strong></p><p>将依赖spring-boot-starter-actuator添加到pom.xml文件中，并配置端点安全策略。</p><p>Spring Boot 1.x：添加配置management.security.enabled = false</p><p> Spring Boot 2.x：添加配置management.endpoints.web.exposure.include = *</p><p>要查看端点信息，请访问以下URL：</p><p>Spring Boot1.x：Nacos Discovery端点URL是<a href="http://127.0.0.1:18083/nacos_discovery" target="_blank" rel="noopener">http://127.0.0.1:18083/nacos_discovery</a>。</p><p>Spring Boot2.x：Nacos Discovery端点URL是<a href="http://127.0.0.1:18083/actuator/nacos-discovery" target="_blank" rel="noopener">http://127.0.0.1:18083/actuator/nacos-discovery</a>。</p><p><a href="https://camo.githubusercontent.com/9d820d357cbc8e17c1b680b2a107f981870ffd2d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331393238352d64353432646335662d356466662d343632612d396635322d3732353437373662636439392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9d820d357cbc8e17c1b680b2a107f981870ffd2d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331393238352d64353432646335662d356466662d343632612d396635322d3732353437373662636439392e706e67" srcset="/img/loading.gif" alt="执行器"></a></p></blockquote><h5 id="3-9-更多"><a href="#3-9-更多" class="headerlink" title="3.9 更多"></a>3.9 更多</h5><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>键</td><td>默认值</td><td>描述</td></tr><tr><td>服务器地址</td><td>spring.cloud.nacos.discovery.server-addr</td><td></td><td>nacos注册中心地址</td></tr><tr><td>服务名</td><td>spring.cloud.nacos.discovery.service</td><td>spring.application.name</td><td>服务名</td></tr><tr><td>权重</td><td>spring.cloud.nacos.discovery.weight</td><td>1</td><td>值从1到100，值越大，重量越大</td></tr><tr><td>IP</td><td>spring.cloud.nacos.discovery.ip</td><td></td><td>ip address to registry，最高优先级</td></tr><tr><td>网络接口</td><td>spring.cloud.nacos.discovery.network-interface</td><td></td><td>未配置IP时，注册的IP地址为网络接口对应的IP地址。如果未配置此项，则默认采用第一个网络接口的地址。</td></tr><tr><td>端口</td><td>spring.cloud.nacos.discovery.port</td><td>-1</td><td>注册端口，无需配置即可自动检测</td></tr><tr><td>namesapce</td><td>spring.cloud.nacos.discovery.namespace</td><td></td><td>开发环境（dev、pro等）</td></tr><tr><td>accesskey</td><td>spring.cloud.nacos.discovery.access-key</td><td></td><td></td></tr><tr><td>secretkey</td><td>spring.cloud.nacos.discovery.secret-key</td><td></td><td></td></tr><tr><td>元数据</td><td>spring.cloud.nacos.discovery.metadata</td><td></td><td>扩展数据，使用Map格式配置</td></tr><tr><td>日志名称</td><td>spring.cloud.nacos.discovery.log-name</td><td></td><td></td></tr><tr><td>端点</td><td>spring.cloud.nacos.discovery.endpoint</td><td></td><td>服务的域名，通过该域名可以动态获取服务器地址。</td></tr><tr><td>集成功能区</td><td>ribbon.nacos.enabled</td><td>true</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos配置中心及注册中心</title>
    <link href="/2020/05/31/02%20Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8F%8A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/05/31/02%20Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8F%8A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h3 id="Nacos整合SpringCloud"><a href="#Nacos整合SpringCloud" class="headerlink" title="Nacos整合SpringCloud"></a>Nacos整合SpringCloud</h3><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/nacos-example" target="_blank" rel="noopener">https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/nacos-example</a></p><h4 id="1-什么是Nacos？"><a href="#1-什么是Nacos？" class="headerlink" title="1.什么是Nacos？"></a>1.什么是Nacos？</h4><blockquote><p><a href="https://github.com/alibaba/Nacos" target="_blank" rel="noopener">Nacos</a> 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p></blockquote><h4 id="2-Nacos-Config整合"><a href="#2-Nacos-Config整合" class="headerlink" title="2.Nacos Config整合"></a>2.Nacos Config整合</h4><blockquote><p>Nacos Config Starter实现Spring Cloud应用程序的外部化配置。</p></blockquote><h5 id="2-1-启动-Nacos-Server-并添加配置"><a href="#2-1-启动-Nacos-Server-并添加配置" class="headerlink" title="2.1 启动 Nacos Server 并添加配置"></a>2.1 启动 Nacos Server 并添加配置</h5><blockquote><p>1.下载地址：</p><ol><li>直接下载：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">Nacos Server 下载页</a></li><li>源码构建：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">Github 项目页面</a></li></ol><p>2.启动</p><ol><li>Linux/Unix/Mac 操作系统，执行命令 <code>sh startup.sh -m standalone</code></li><li>Windows 操作系统，执行命令 <code>cmd startup.cmd</code></li><li>默认账户密码：nacos</li></ol><p>3.在命令行执行如下命令，向 Nacos Server 中添加一条配置，也可在控制台中手动添加。</p><pre><code class="hljs shell">curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos-config-example.properties&amp;group=DEFAULT_GROUP&amp;content=user.id=1%0Auser.name=james%0Auser.age=17"</code></pre><p>添加的配置的详情如下</p><pre><code class="hljs properties"><span class="hljs-attr">dataId</span> <span class="hljs-string">为 nacos-config-example.properties</span><span class="hljs-attr">group</span> <span class="hljs-string">为 DEFAULT_GROUP</span><span class="hljs-attr">内容如下</span><span class="hljs-meta">user.id</span>=<span class="hljs-string">1</span><span class="hljs-meta">user.name</span>=<span class="hljs-string">james</span><span class="hljs-meta">user.age</span>=<span class="hljs-string">17</span></code></pre><p>访问：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p><img src="https://img-blog.csdnimg.cn/20190603110735458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-1-引入pom文件"><a href="#2-1-引入pom文件" class="headerlink" title="2.1 引入pom文件"></a>2.1 引入pom文件</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="2-2-添加bootstrap-properties"><a href="#2-2-添加bootstrap-properties" class="headerlink" title="2.2 添加bootstrap.properties"></a>2.2 添加bootstrap.properties</h5><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">nacos-config-example</span><span class="hljs-meta">spring.cloud.nacos.config.server-addr</span>=<span class="hljs-string">ip:8848 #服务器ip或本地ip</span></code></pre><h5 id="2-3-获取相应的配置"><a href="#2-3-获取相应的配置" class="headerlink" title="2.3 获取相应的配置"></a>2.3 获取相应的配置</h5><pre><code class="hljs java"><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">//打开动态刷新功能</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleController</span> </span>&#123; <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.name&#125;"</span>) String userName; <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.age&#125;"</span>) <span class="hljs-keyword">int</span> age; &#125;</code></pre><h5 id="2-4-应用启动"><a href="#2-4-应用启动" class="headerlink" title="2.4 应用启动"></a>2.4 应用启动</h5><blockquote><p>1.添加/application.properties </p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">18084</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>2.App启动<br><img src="https://img-blog.csdnimg.cn/20190603120015889.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-5-原理"><a href="#2-5-原理" class="headerlink" title="2.5 原理"></a>2.5 原理</h5><blockquote><h4 id="1-Nacos-Config-数据结构"><a href="#1-Nacos-Config-数据结构" class="headerlink" title="1.Nacos Config 数据结构"></a>1.Nacos Config 数据结构</h4><p>Nacos Config 主要通过 dataId 和 group 来唯一确定一条配置.</p><p>Nacos Client 从 Nacos Server 端获取数据时，调用的是此接口 <code>ConfigService.getConfig(String dataId, String group, long timeoutMs)</code>。</p><h4 id="2-Spring-Cloud-应用获取数据"><a href="#2-Spring-Cloud-应用获取数据" class="headerlink" title="2.Spring Cloud 应用获取数据"></a>2.Spring Cloud 应用获取数据</h4><h5 id="dataId"><a href="#dataId" class="headerlink" title="dataId"></a>dataId</h5><p>在 Nacos Config Starter 中，dataId 的拼接格式如下</p><pre><code class="hljs properties"><span class="hljs-meta">$&#123;prefix&#125;</span> <span class="hljs-string">- $&#123;spring.profiles.active&#125; . $&#123;file-extension&#125;</span></code></pre><ul><li><p><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</p></li><li><p><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" target="_blank" rel="noopener">Spring Boot文档</a></p><p><strong>注意，当 activeprofile 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</strong></p></li><li><p><code>file-extension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code>来配置。 目前只支持 <code>properties</code> 类型。</p></li></ul><h5 id="group"><a href="#group" class="headerlink" title="group"></a>group</h5><ul><li><code>group</code> 默认为 <code>DEFAULT_GROUP</code>，可以通过 <code>spring.cloud.nacos.config.group</code> 配置。</li></ul><h4 id="3-自动注入"><a href="#3-自动注入" class="headerlink" title="3.自动注入"></a>3.自动注入</h4><p>Nacos Config Starter 实现了 <code>org.springframework.cloud.bootstrap.config.PropertySourceLocator</code>接口，并将优先级设置成了最高。</p><p>在 Spring Cloud 应用启动阶段，会主动从 Nacos Server 端获取对应的数据，并将获取到的数据转换成 PropertySource 且注入到 Environment 的 PropertySources 属性中，所以使用 @Value 注解也能直接获取 Nacos Server 端配置的内容。</p><h4 id="4-动态刷新"><a href="#4-动态刷新" class="headerlink" title="4.动态刷新"></a>4.动态刷新</h4><p>Nacos Config Starter 默认为所有获取数据成功的 Nacos 的配置项添加了监听功能，在监听到服务端配置发生变化时会实时触发 <code>org.springframework.cloud.context.refresh.ContextRefresher</code> 的 refresh 方法 。</p><p>如果需要对 Bean 进行动态刷新，给类添加 <code>@RefreshScope</code> 或 <code>@ConfigurationProperties</code>注解。</p><h4 id="5-Endpoint-信息查看"><a href="#5-Endpoint-信息查看" class="headerlink" title="5.Endpoint 信息查看"></a>5.Endpoint 信息查看</h4><p>Springboot支持这一点，Nacos Config也同时可以使用Endpoint来暴露信息。</p><p>在maven 中添加 <code>spring-boot-starter-actuator</code>依赖，并在配置中允许 Endpoints 的访问。</p><ul><li>Spring Boot 1.x 中添加配置 management.security.enabled=false</li><li>Spring Boot 2.x 中添加配置 management.endpoints.web.exposure.include=*</li></ul><p>Spring Boot 1.x 可以通过访问 <a href="http://127.0.0.1:18084/nacos_config" target="_blank" rel="noopener">http://127.0.0.1:18084/nacos_config</a> 来查看 Nacos Endpoint 的信息。</p><p>Spring Boot 2.x 可以通过访问 <a href="http://127.0.0.1:18084/actuator/nacos-config" target="_blank" rel="noopener">http://127.0.0.1:18084/actuator/nacos-config</a> 来访问。<br><img src="https://img-blog.csdnimg.cn/20190603121130239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><h5 id="2-6-更多"><a href="#2-6-更多" class="headerlink" title="2.6 更多"></a>2.6 更多</h5><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>key</td><td>默认值</td><td>说明</td></tr><tr><td>服务端地址</td><td>spring.cloud.nacos.config.server-addr</td><td></td><td></td></tr><tr><td>DataId前缀</td><td>spring.cloud.nacos.config.prefix</td><td></td><td>spring.application.name</td></tr><tr><td>Group</td><td>spring.cloud.nacos.config.group</td><td>DEFAULT_GROUP</td><td></td></tr><tr><td>dataID后缀及内容文件格式</td><td>spring.cloud.nacos.config.file-extension</td><td>properties</td><td>dataId的后缀，同时也是配置内容的文件格式，目前只支持 properties</td></tr><tr><td>配置内容的编码方式</td><td>spring.cloud.nacos.config.encode</td><td>UTF-8</td><td>配置的编码</td></tr><tr><td>获取配置的超时时间</td><td>spring.cloud.nacos.config.timeout</td><td>3000</td><td>单位为 ms</td></tr><tr><td>配置的命名空间</td><td>spring.cloud.nacos.config.namespace</td><td></td><td>常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。</td></tr><tr><td>AccessKey</td><td>spring.cloud.nacos.config.access-key</td><td></td><td></td></tr><tr><td>SecretKey</td><td>spring.cloud.nacos.config.secret-key</td><td></td><td></td></tr><tr><td>相对路径</td><td>spring.cloud.nacos.config.context-path</td><td></td><td>服务端 API 的相对路径</td></tr><tr><td>接入点</td><td>spring.cloud.nacos.config.endpoint</td><td>UTF-8</td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td>是否开启监听和自动刷新</td><td>spring.cloud.nacos.config.refresh.enabled</td><td>true</td><td></td></tr></tbody></table><h4 id="3-Nacos-Discovery-整合"><a href="#3-Nacos-Discovery-整合" class="headerlink" title="3.Nacos Discovery 整合"></a>3.Nacos Discovery 整合</h4><blockquote><p>Nacos Discovery Starter 完成 Spring Cloud 应用的服务注册与发现。</p></blockquote><h5 id="3-1-添加依赖"><a href="#3-1-添加依赖" class="headerlink" title="3.1 添加依赖"></a>3.1 添加依赖</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="3-2-application-properties"><a href="#3-2-application-properties" class="headerlink" title="3.2 application.properties"></a>3.2 application.properties</h5><pre><code class="hljs properties"><span class="hljs-meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span></code></pre><h5 id="3-3-服务注册和发现"><a href="#3-3-服务注册和发现" class="headerlink" title="3.3 服务注册和发现"></a>3.3 服务注册和发现</h5><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>; &#125; <span class="hljs-meta">@RestController</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoController</span> </span>&#123; <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo/&#123;string&#125;"</span>, method = RequestMethod.GET) <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(@PathVariable String string)</span> </span>&#123; <span class="hljs-keyword">return</span> string; &#125; &#125; &#125;</code></pre><h5 id="3-4-启动Nacos服务端"><a href="#3-4-启动Nacos服务端" class="headerlink" title="3.4 启动Nacos服务端"></a>3.4 启动Nacos服务端</h5><blockquote><ol><li>通过从源代码下载或构建来安装Nacos Server。<strong>推荐的最新版本Nacos Server</strong><ol><li>下载Nacos Server <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">下载页面</a></li><li>从源代码构建：通过git clone <a href="mailto:git@github.com">git@github.com</a>获取源代码：来自Github Nacos的alibaba / Nacos.git并构建您的代码。有关详细信息，请参阅<a href="https://nacos.io/en-us/docs/quick-start.html" target="_blank" rel="noopener">构建</a></li></ol></li><li>运行<ol><li>Linux / Unix / Mac，执行 <code>sh startup.sh -m standalone</code></li><li>Windows，执行 <code>cmd startup.cmd</code></li></ol></li></ol></blockquote><h5 id="3-5-启动客户端"><a href="#3-5-启动客户端" class="headerlink" title="3.5 启动客户端"></a>3.5 启动客户端</h5><blockquote><p>1.添加application.properties配置</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">service-provider</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">18082</span></code></pre></blockquote><h5 id="3-6-查询服务"><a href="#3-6-查询服务" class="headerlink" title="3.6 查询服务"></a>3.6 查询服务</h5><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8848</span><span class="hljs-regexp">/nacos/</span>v1<span class="hljs-regexp">/ns/i</span>nstances?serviceName=service-provider</code></pre><p><img src="https://img-blog.csdnimg.cn/20190603122655648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="3-7-服务发现"><a href="#3-7-服务发现" class="headerlink" title="3.7 服务发现"></a>3.7 服务发现</h5><p>Nacos Discovery Starter默认集成了Ribbon，因此对于使用Ribbon进行负载平衡的组件，您可以直接使用Nacos服务发现。</p><p>NacosServerList实现com.netflix.loadbalancer.ServerList接口并在@ConditionOnMissingBean下自动注入它。</p><blockquote><h4 id="使用RestTemplate和FeignClient"><a href="#使用RestTemplate和FeignClient" class="headerlink" title="使用RestTemplate和FeignClient"></a>使用RestTemplate和FeignClient</h4><ol><li><p>添加@LoadBlanced注释以使Ribbon可以访问RestTemplate</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre></li><li><p>FeignClient默认集成了功能区，显示了如何配置FeignClient。</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"service-provider"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EchoService</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function">String <span class="hljs-title">echo</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"str"</span>)</span> String str)</span>;&#125;</code></pre><p>使用@FeignClient批注将<code>EchoService</code>接口包装为FeignClient，其属性名称对应于服务名称<code>service-provider</code>。</p><p>方法的<code>@RequestMapping</code>注释<code>echo</code>将echo方法与URL对应<code>/echo/{str}</code>，<code>@PathVariable</code>注释映射<code>{str}</code>到<code>str</code>echo方法的参数的URL路径中。</p></li><li><p>完成上述配置后，将它们注入TestController。</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> EchoService echoService;       <span class="hljs-comment">//RestTemplate</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo-rest/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rest</span><span class="hljs-params">(@PathVariable String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://service-provider/echo/"</span> + str, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-comment">//FeignClient</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/echo-feign/&#123;str&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">feign</span><span class="hljs-params">(@PathVariable String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> echoService.echo(str);    &#125;&#125;</code></pre></li><li><p>添加application.properties配置</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">service-consumer</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">18083</span></code></pre></li><li><p>运行</p></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><code>http://127.0.0.1:18083/echo-rest/1234</code>在浏览器地址栏中输入并单击转到，我们可以看到浏览器显示nacos-discovery-provider-example返回的消息“hello Nacos Discovery 1234”，以证明服务发现有效。</li></ol><p><a href="https://camo.githubusercontent.com/0806773157ca6926e08a5e664ee493fc016ba003/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363330323132342d65653237363730642d626463632d343231302d396635642d3837356163656336643365612e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0806773157ca6926e08a5e664ee493fc016ba003/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363330323132342d65653237363730642d626463632d343231302d396635642d3837356163656336643365612e706e67" srcset="/img/loading.gif" alt="休息"></a></p><ol><li><code>http://127.0.0.1:18083/echo-feign/12345</code>在浏览器地址栏中输入并单击转到，我们可以看到浏览器显示nacos-discovery-provider-example返回的消息“hello Nacos Discovery 12345”，以证明服务发现有效。</li></ol><p><a href="https://camo.githubusercontent.com/652b6b245a939372c1950a655a07acb994c55f26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331313638352d36643063316639622d613435332d346563332d383861622d6637393232643231306636352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/652b6b245a939372c1950a655a07acb994c55f26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331313638352d36643063316639622d613435332d346563332d383861622d6637393232643231306636352e706e67" srcset="/img/loading.gif" alt="假装"></a></p></blockquote><h5 id="3-8-原理"><a href="#3-8-原理" class="headerlink" title="3.8 原理"></a>3.8 原理</h5><blockquote><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在Spring云应用程序的启动阶段，将监视WebServerInitializedEvent事件。在初始化Web容器后收到WebServerInitializedEvent事件时，将触发注册操作，并调用ServiceRegistry注册方法以将服务注册到Nacos Server。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>NacosServerList实现com.netflix.loadbalancer.ServerList接口并在@ConditionOnMissingBean下自动注入它。功能区默认为集成。</p><h2 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h2><p>Nacos Discovery Starter还支持Spring Boot执行器端点的实现。</p><p><strong>先决条件：</strong></p><p>将依赖spring-boot-starter-actuator添加到pom.xml文件中，并配置端点安全策略。</p><p>Spring Boot 1.x：添加配置management.security.enabled = false</p><p> Spring Boot 2.x：添加配置management.endpoints.web.exposure.include = *</p><p>要查看端点信息，请访问以下URL：</p><p>Spring Boot1.x：Nacos Discovery端点URL是<a href="http://127.0.0.1:18083/nacos_discovery" target="_blank" rel="noopener">http://127.0.0.1:18083/nacos_discovery</a>。</p><p>Spring Boot2.x：Nacos Discovery端点URL是<a href="http://127.0.0.1:18083/actuator/nacos-discovery" target="_blank" rel="noopener">http://127.0.0.1:18083/actuator/nacos-discovery</a>。</p><p><a href="https://camo.githubusercontent.com/9d820d357cbc8e17c1b680b2a107f981870ffd2d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331393238352d64353432646335662d356466662d343632612d396635322d3732353437373662636439392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9d820d357cbc8e17c1b680b2a107f981870ffd2d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f35343331392f313533363938363331393238352d64353432646335662d356466662d343632612d396635322d3732353437373662636439392e706e67" srcset="/img/loading.gif" alt="执行器"></a></p></blockquote><h5 id="3-9-更多"><a href="#3-9-更多" class="headerlink" title="3.9 更多"></a>3.9 更多</h5><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>键</td><td>默认值</td><td>描述</td></tr><tr><td>服务器地址</td><td>spring.cloud.nacos.discovery.server-addr</td><td></td><td>nacos注册中心地址</td></tr><tr><td>服务名</td><td>spring.cloud.nacos.discovery.service</td><td>spring.application.name</td><td>服务名</td></tr><tr><td>权重</td><td>spring.cloud.nacos.discovery.weight</td><td>1</td><td>值从1到100，值越大，重量越大</td></tr><tr><td>IP</td><td>spring.cloud.nacos.discovery.ip</td><td></td><td>ip address to registry，最高优先级</td></tr><tr><td>网络接口</td><td>spring.cloud.nacos.discovery.network-interface</td><td></td><td>未配置IP时，注册的IP地址为网络接口对应的IP地址。如果未配置此项，则默认采用第一个网络接口的地址。</td></tr><tr><td>端口</td><td>spring.cloud.nacos.discovery.port</td><td>-1</td><td>注册端口，无需配置即可自动检测</td></tr><tr><td>namesapce</td><td>spring.cloud.nacos.discovery.namespace</td><td></td><td>开发环境（dev、pro等）</td></tr><tr><td>accesskey</td><td>spring.cloud.nacos.discovery.access-key</td><td></td><td></td></tr><tr><td>secretkey</td><td>spring.cloud.nacos.discovery.secret-key</td><td></td><td></td></tr><tr><td>元数据</td><td>spring.cloud.nacos.discovery.metadata</td><td></td><td>扩展数据，使用Map格式配置</td></tr><tr><td>日志名称</td><td>spring.cloud.nacos.discovery.log-name</td><td></td><td></td></tr><tr><td>端点</td><td>spring.cloud.nacos.discovery.endpoint</td><td></td><td>服务的域名，通过该域名可以动态获取服务器地址。</td></tr><tr><td>集成功能区</td><td>ribbon.nacos.enabled</td><td>true</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel服务保护</title>
    <link href="/2020/05/31/01%20Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
    <url>/2020/05/31/01%20Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Sentinel-介绍"><a href="#一、Sentinel-介绍" class="headerlink" title="一、Sentinel 介绍"></a>一、Sentinel 介绍</h3><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。 <a href="https://github.com/alibaba/Sentinel[Sentinel]" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel[Sentinel]</a> 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p><a href="https://github.com/alibaba/Sentinel[Sentinel]" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel[Sentinel]</a> 具有以下特征:</p><ul><li><em>丰富的应用场景</em>： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。</li><li><em>完备的实时监控</em>： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><em>广泛的开源生态</em>： Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><em>完善的 SPI 扩展点</em>： Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等。</li></ul><h4 id="服务保护的基本概念"><a href="#服务保护的基本概念" class="headerlink" title="服务保护的基本概念"></a>服务保护的基本概念</h4><p>服务限流/熔断</p><blockquote><p>在高并发情况下，客户端请求达到了一定的极限，也就是我们所设定的阈值，服务就会自动开启自我保护机制，直接走我们的服务降级fallback方法，给客户端一个友好提示。</p></blockquote><p>服务降级</p><blockquote><p>在高并发情况下，为了防止用户一直等待，给用户一个友好提示。</p></blockquote><p>服务的雪崩效应</p><blockquote><p>默认情况下，tomcat/jetty服务器只有一个线程池去处理用户请求。在高并发情况下，如果客户端的所有请求都堆积在同一个接口上，线程池中的所有线程都用来处理这些请求，就会导致其他接口无法访问。</p></blockquote><p>服务隔离机制</p><blockquote><p>服务隔离机制分为两种：信号量隔离和线程池隔离</p><p>信号量隔离：最多只能有一定的阈值的线程数来处理我们的请求，超过阈值就会拒绝请求</p><p>线程池隔离：每个服务接口都有独立的线程池来处理请求，接口之间互不影响，缺点：占用CPU资源较大</p></blockquote><p>Sentinel和Hytrix区别</p><p><img src="https://img-blog.csdnimg.cn/20200206160035900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="二、Sentinel-环境快速搭建"><a href="#二、Sentinel-环境快速搭建" class="headerlink" title="二、Sentinel 环境快速搭建"></a>二、Sentinel 环境快速搭建</h3><p>下载对应Sentinel-Dashboard</p><p><a href="https://github.com/alibaba/Sentinel/releases/tag/1.7.1" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases/tag/1.7.1</a> 运行即可。</p><p>默认账号密码：sentinel/sentinel</p><p>运行执行命令</p><pre><code class="hljs shell">java -Dserver.port=8718 -Dcsp.sentinel.dashboard.server=localhost:8718 -Dproject.name=sentinel-dashboard -Dcsp.sentinel.api.port=8719 -jar sentinel-dashboard-1.7.1.jar</code></pre><h3 id="三、Sentinel实现API动态限流"><a href="#三、Sentinel实现API动态限流" class="headerlink" title="三、Sentinel实现API动态限流"></a>三、Sentinel实现API动态限流</h3><p>maven依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="1-手动配置管理API限流接口"><a href="#1-手动配置管理API限流接口" class="headerlink" title="1.手动配置管理API限流接口"></a>1.手动配置管理API限流接口</h4><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getOrder"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrders</span><span class="hljs-params">()</span> </span>&#123;    Entry entry = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        entry = SphU.entry(GETORDER_KEY);        <span class="hljs-comment">// 执行我们服务需要保护的业务逻辑</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"getOrder接口"</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-string">"该服务接口已经达到上线!"</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// SphU.entry(xxx) 需要与 entry.exit() 成对出现,否则会导致调用链记录异常</span>        <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) &#123;            entry.exit();        &#125;    &#125;&#125;</code></pre><p>限流配置放到项目自动加载</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;FlowRule&gt;();        FlowRule rule1 = <span class="hljs-keyword">new</span> FlowRule();        rule1.setResource(GETORDER_KEY);        <span class="hljs-comment">// QPS控制在2以内</span>        rule1.setCount(<span class="hljs-number">1</span>);        <span class="hljs-comment">// QPS限流</span>        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);        rule1.setLimitApp(<span class="hljs-string">"default"</span>);        rules.add(rule1);        FlowRuleManager.loadRules(rules);        log.info(<span class="hljs-string">"&gt;&gt;&gt;限流服务接口配置加载成功&gt;&gt;&gt;"</span>);    &#125;&#125;</code></pre><h4 id="2-注解形式配置管理Api限流"><a href="#2-注解形式配置管理Api限流" class="headerlink" title="2.注解形式配置管理Api限流"></a>2.注解形式配置管理Api限流</h4><h5 id="2-1-基于QPS限流"><a href="#2-1-基于QPS限流" class="headerlink" title="2.1 基于QPS限流"></a>2.1 基于QPS限流</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * <span class="hljs-doctag">@SentinelResource</span> 流量规则资源名</span><span class="hljs-comment">     * - blockHandler 限流/熔断 出现异常 执行的方法</span><span class="hljs-comment">     * - fallback 服务降级执行的方法</span><span class="hljs-comment">     * -QPS=并发数/平均响应时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SentinelResource</span>(value = GETORDER_KEY,blockHandler = <span class="hljs-string">"getOrderQpsException"</span>)    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrders</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"getOrder接口"</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 被限流后返回的提示</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderQpsException</span><span class="hljs-params">(BlockException e)</span> </span>&#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-string">"该接口已经被限流啦!"</span>;    &#125;</code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.137</span><span class="hljs-string">:8718</span>      <span class="hljs-attr">eager:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Sentinel-02</span></code></pre><p>Sentinel控制台中添加限流规则</p><p><img src="https://img-blog.csdnimg.cn/20200206160057275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="2-2-基于并发数限流"><a href="#2-2-基于并发数限流" class="headerlink" title="2.2 基于并发数限流"></a>2.2 基于并发数限流</h5><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 基于并发数量处理限流</span><span class="hljs-comment"> * 并发数 = QPS*平均响应时间</span><span class="hljs-comment"> * 每次最多只会有一个线程处理该业务逻辑，超出该阈值的情况下，直接拒绝访问。</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"getOrderThrad"</span>, blockHandler = <span class="hljs-string">"getOrderQpsException"</span>)<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getOrderThrad"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getgetOrderThread</span><span class="hljs-params">()</span></span>&#123;    System.out.println(Thread.currentThread().getName());    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"getOrderThrad"</span>;&#125;</code></pre><p>Sentinel控制台中添加限流规则</p><p><img src="https://img-blog.csdnimg.cn/20200206160105139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如果要在您的项目中引入 Sentinel，使用 group ID 为 <code>com.alibaba.cloud</code> 和 artifact ID 为 <code>spring-cloud-starter-alibaba-sentinel</code> 的 starter。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>下面这个例子就是一个最简单的使用 Sentinel 的例子:</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/hello"</span>)    <span class="hljs-meta">@SentinelResource</span>(<span class="hljs-string">"hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Sentinel"</span>;    &#125;&#125;</code></pre><p>@SentinelResource 注解用来标识资源是否被限流、降级。上述例子上该注解的属性 ‘hello’ 表示资源名。</p><p>@SentinelResource 还提供了其它额外的属性如 <code>blockHandler</code>，<code>blockHandlerClass</code>，<code>fallback</code> 用于表示限流或降级的操作，更多内容可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81[Sentinel注解支持]。" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81[Sentinel注解支持]。</a></p><p>以上例子都是在 WebServlet 环境下使用的，Sentinel 目前已经支持 WebFlux，需要配合 <code>spring-boot-starter-webflux</code> 依赖触发 sentinel-starter 中 WebFlux 相关的自动化配置。</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/mono"</span>)    <span class="hljs-meta">@SentinelResource</span>(<span class="hljs-string">"hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">mono</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">"simple string"</span>).transform(<span class="hljs-keyword">new</span> SentinelReactorTransformer&lt;&gt;(<span class="hljs-string">"otherResourceName"</span>));    &#125;&#125;</code></pre><h4 id="3-基于热点参数手动实现限流"><a href="#3-基于热点参数手动实现限流" class="headerlink" title="3. 基于热点参数手动实现限流"></a>3. 基于热点参数手动实现限流</h4><p>添加maven依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-parameter-flow-control<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>将限流规则，手动放入到项目启动自动加载:</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 定义热点限流的规则，对第一个参数设置 qps 限流模式，阈值为5</span>        ParamFlowRule rule = <span class="hljs-keyword">new</span> ParamFlowRule(GETORDER_KEY)                <span class="hljs-comment">//热点参数的索引</span>                .setParamIdx(<span class="hljs-number">0</span>)                <span class="hljs-comment">//限流模式</span>                .setGrade(RuleConstant.FLOW_GRADE_QPS)                <span class="hljs-comment">//阈值</span>                .setCount(<span class="hljs-number">2</span>);        ParamFlowRuleManager.loadRules(Collections.singletonList(rule));    &#125;&#125;</code></pre><p>controller层：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"getOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;        Entry entry = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//参数1：资源名称，参数三：计数，参数四：限流参数</span>            entry = SphU.entry(GETORDER_KEY, EntryType.IN, <span class="hljs-number">1</span>, id);            <span class="hljs-comment">// Your logic here.</span>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"该用户服务已经限流，id="</span>+id;        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) &#123;                entry.exit();            &#125;        &#125;        <span class="hljs-keyword">return</span> GETORDER_KEY+<span class="hljs-string">",id="</span>+id;    &#125;&#125;</code></pre><h4 id="4-基于热点参数控制台实现限流"><a href="#4-基于热点参数控制台实现限流" class="headerlink" title="4. 基于热点参数控制台实现限流"></a>4. 基于热点参数控制台实现限流</h4><p>java代码：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GETORDER_KEY = <span class="hljs-string">"getOrder"</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"getOrder"</span>)    <span class="hljs-meta">@SentinelResource</span>(GETORDER_KEY)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">return</span> GETORDER_KEY + <span class="hljs-string">".id="</span> + id;    &#125;&#125;</code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.137</span><span class="hljs-string">:8718</span>      <span class="hljs-attr">eager:</span> <span class="hljs-literal">true</span></code></pre><p>Sentinel控制台中添加热点参数限流规则：<br><img src="https://img-blog.csdnimg.cn/20200212213200263.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="四、Sentinel实现API熔断降级"><a href="#四、Sentinel实现API熔断降级" class="headerlink" title="四、Sentinel实现API熔断降级"></a>四、Sentinel实现API熔断降级</h3><h4 id="4-1-基于平均响应时间"><a href="#4-1-基于平均响应时间" class="headerlink" title="4.1 基于平均响应时间"></a>4.1 基于平均响应时间</h4><p>java代码：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 基于平均响应时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"getERFallBack"</span>,fallback = <span class="hljs-string">"getException"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"getERFallBack"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getERFallBack</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">300</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"getERFallBack"</span>;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 基于平均响应时间 的降级方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getException</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"服务降级啦，当前服务器请求次数过多，请稍后重试!"</span>;&#125;</code></pre><p>Sentinel控制台：</p><p>每秒平均响应时间超过阈值200ms，走服务降级，并且5秒内无法访问服务，继续走服务降级方法。</p><p><img src="https://img-blog.csdnimg.cn/20200209154703230.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="4-2-基于异常比例"><a href="#4-2-基于异常比例" class="headerlink" title="4.2 基于异常比例"></a>4.2 基于异常比例</h4><p>java代码：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 基于异常比例</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"getErroPer"</span>,fallback = <span class="hljs-string">"getException"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getErroPer"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErroPer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>/i;    <span class="hljs-keyword">return</span> <span class="hljs-string">"getErroPer"</span>;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 参数必须与被降级的方法中的参数一致，才能实现降级</span><span class="hljs-comment"> * 异常比例和异常次数 的降级方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getException</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"服务降级啦，请稍后重试!"</span>;&#125;</code></pre><p>Sentinel控制台：</p><p><img src="https://img-blog.csdnimg.cn/20200209154647543.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="4-3-基于异常次数"><a href="#4-3-基于异常次数" class="headerlink" title="4.3 基于异常次数"></a>4.3 基于异常次数</h4><p>java代码：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 基于异常次数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"getErroCout"</span>,fallback = <span class="hljs-string">"getException"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getErroCout"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErroCout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>/i;    <span class="hljs-keyword">return</span> <span class="hljs-string">"getErroCout"</span>;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 参数必须与被降级的方法中的参数一致，才能实现降级</span><span class="hljs-comment"> * 异常比例和异常次数 的降级方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getException</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"服务降级啦，请稍后重试!"</span>;&#125;</code></pre><p>Sentinel控制台：</p><p><img src="https://img-blog.csdnimg.cn/20200209154629685.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="五、RestTemplate-支持"><a href="#五、RestTemplate-支持" class="headerlink" title="五、RestTemplate 支持"></a>五、RestTemplate 支持</h3><p>Spring Cloud Alibaba Sentinel 支持对 <code>RestTemplate</code> 的服务调用使用 Sentinel 进行保护，在构造 <code>RestTemplate</code> bean的时候需要加上 <code>@SentinelRestTemplate</code> 注解。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@SentinelRestTemplate</span>(blockHandler = <span class="hljs-string">"handleException"</span>, blockHandlerClass = ExceptionUtil<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">RestTemplate</span> <span class="hljs-title">restTemplate</span>() </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre><p><code>@SentinelRestTemplate</code> 注解的属性支持限流(<code>blockHandler</code>, <code>blockHandlerClass</code>)和降级(<code>fallback</code>, <code>fallbackClass</code>)的处理。</p><p>其中 <code>blockHandler</code> 或 <code>fallback</code> 属性对应的方法必须是对应 <code>blockHandlerClass</code> 或 <code>fallbackClass</code> 属性中的静态方法。</p><p>该方法的参数跟返回值跟 <code>org.springframework.http.client.ClientHttpRequestInterceptor#interceptor</code> 方法一致，其中参数多出了一个 <code>BlockException</code> 参数用于获取 Sentinel 捕获的异常。</p><p>比如上述 <code>@SentinelRestTemplate</code> 注解中 <code>ExceptionUtil</code> 的 <code>handleException</code> 属性对应的方法声明如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientHttpResponse <span class="hljs-title">handleException</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body, ClientHttpRequestExecution execution, BlockException exception)</span> </span>&#123;        ...    &#125;&#125;</code></pre><p>NOTE: 应用启动的时候会检查 <code>@SentinelRestTemplate</code> 注解对应的限流或降级方法是否存在，如不存在会抛出异常</p><p><code>@SentinelRestTemplate</code> 注解的限流(<code>blockHandler</code>, <code>blockHandlerClass</code>)和降级(<code>fallback</code>, <code>fallbackClass</code>)属性不强制填写。</p><p>当使用 <code>RestTemplate</code> 调用被 Sentinel 熔断后，会返回 <code>RestTemplate request block by sentinel</code> 信息，或者也可以编写对应的方法自行处理返回信息。这里提供了 <code>SentinelClientHttpResponse</code> 用于构造返回信息。</p><p>Sentinel RestTemplate 限流的资源规则提供两种粒度：</p><ul><li><p><code>httpmethod:schema://host:port/path</code>：协议、主机、端口和路径</p></li><li><p><code>httpmethod:schema://host:port</code>：协议、主机和端口</p></li></ul><p>NOTE: 以 <code>https://www.taobao.com/test</code> 这个 url 并使用 GET 方法为例。对应的资源名有两种粒度，分别是 <code>GET:https://www.taobao.com</code> 以及 <code>GET:https://www.taobao.com/test</code></p><h3 id="六、动态数据源支持（数据持久化）"><a href="#六、动态数据源支持（数据持久化）" class="headerlink" title="六、动态数据源支持（数据持久化）"></a>六、动态数据源支持（数据持久化）</h3><p>Sentinel中提供四种数据源实现数据持久化：File、Nacos、Zookeeper、Apolle</p><p>配置案例：</p><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.file=classpath: degraderule.jsonspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.rule-type=flow<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.file=classpath: flowrule.json<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.data-type=custom<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.converter-class=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.examples</span>.JsonFlowRuleListConverter<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds1</span><span class="hljs-selector-class">.file</span>.rule-type=flowspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds2</span><span class="hljs-selector-class">.nacos</span>.server-addr=localhost:<span class="hljs-number">8848</span>spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds2</span><span class="hljs-selector-class">.nacos</span>.data-id=sentinelspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds2</span><span class="hljs-selector-class">.nacos</span>.group-id=DEFAULT_GROUPspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds2</span><span class="hljs-selector-class">.nacos</span>.data-type=jsonspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds2</span><span class="hljs-selector-class">.nacos</span>.rule-type=degradespring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds3</span><span class="hljs-selector-class">.zk</span><span class="hljs-selector-class">.path</span> = /Sentinel-Demo/SYSTEM-CODE-DEMO-FLOWspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds3</span><span class="hljs-selector-class">.zk</span><span class="hljs-selector-class">.server-addr</span> = localhost:<span class="hljs-number">2181</span>spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds3</span><span class="hljs-selector-class">.zk</span>.rule-type=authorityspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds4</span><span class="hljs-selector-class">.apollo</span><span class="hljs-selector-class">.namespace-name</span> = applicationspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds4</span><span class="hljs-selector-class">.apollo</span><span class="hljs-selector-class">.flow-rules-key</span> = sentinelspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds4</span><span class="hljs-selector-class">.apollo</span><span class="hljs-selector-class">.default-flow-rule-value</span> = testspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.ds4</span><span class="hljs-selector-class">.apollo</span>.rule-type=param-flow</code></pre><p>每种数据源都有两个共同的配置项： <code>data-type</code>、 <code>converter-class</code> 以及 <code>rule-type</code>。</p><p><code>data-type</code> ：表示数据类型，Sentinel 默认提供两种内置的值，分别是 <code>json</code> 和 <code>xml</code> (默认是json)。 若不想使用这两种，可以添加 <code>custom</code> 自定义数据类型，再配置 <code>converter-class</code> 配置项，该配置项需要写类的全路径名(比如 <code>spring.cloud.sentinel.datasource.ds1.file.converter-class=org.springframework.cloud.alibaba.cloud.examples.JsonFlowRuleListConverter</code>)。</p><p><code>rule-type</code> ：表示数据规则，(<code>flow</code>，<code>degrade</code>，<code>authority</code>，<code>system</code>, <code>param-flow</code>, <code>gw-flow</code>, <code>gw-api-group</code>)。</p><h4 id="6-1-基于Nacos实现数据持久化"><a href="#6-1-基于Nacos实现数据持久化" class="headerlink" title="6.1 基于Nacos实现数据持久化"></a>6.1 基于Nacos实现数据持久化</h4><p>添加maven依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.137</span><span class="hljs-string">:8718</span>      <span class="hljs-attr">eager:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">datasource:</span>        <span class="hljs-attr">ds:</span>          <span class="hljs-attr">nacos:</span>            <span class="hljs-comment">### nacos连接地址</span>            <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.137</span><span class="hljs-string">:8848</span>            <span class="hljs-comment">## nacos连接的分组</span>            <span class="hljs-attr">group-id:</span> <span class="hljs-string">DEFAULT_GROUP</span>            <span class="hljs-comment">###路由存储规则</span>            <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span>            <span class="hljs-comment">### 读取配置文件的 data-id</span>            <span class="hljs-attr">data-id:</span> <span class="hljs-string">Sentinel-03</span>            <span class="hljs-comment">###  读取培训文件类型为json</span>            <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span>      <span class="hljs-attr">log:</span>        <span class="hljs-attr">dir:</span> <span class="hljs-string">D:\Code\study\Java_Learning\01</span> <span class="hljs-string">Sentinel\03</span> <span class="hljs-string">基于Nacos实现数据持久化\logs\</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Sentinel-03</span></code></pre><p>java代码：</p><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"getNacosInfo"</span>,blockHandler = <span class="hljs-string">"getQpsException"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getNacosInfo"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNacosInfo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"getNacosInfo"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getQpsException</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"该接口已被限流，请稍后再试"</span>;&#125;</code></pre><p>Nacos控制台：</p><p><img src="https://img-blog.csdnimg.cn/20200209154810111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>resource：资源名，即限流规则的作用对象</p><p>limitApp：流控针对的调用来源，若为 default 则不区分调用来源</p><p>grade：限流阈值类型（QPS 或并发线程数）；0代表根据并发数量来限流，1代表根据QPS来进行流量控制</p><p>count：限流阈值</p><p>strategy：调用关系限流策略</p></blockquote><h3 id="七、网关限流"><a href="#七、网关限流" class="headerlink" title="七、网关限流"></a>七、网关限流</h3><p> <a href="https://github.com/alibaba/Sentinel/wiki/网关限流" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81</a> [参考 Sentinel 网关限流]</p><p>注：<a href="https://github.com/karma521/Java_Learning/tree/SpringCloudAlibaba/01%20Sentinel" target="_blank" rel="noopener">github源码</a></p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabitMQ消息中间件</title>
    <link href="/2020/05/31/10%20RabitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2020/05/31/10%20RabitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="RabitMQ消息中间件"><a href="#RabitMQ消息中间件" class="headerlink" title="RabitMQ消息中间件"></a>RabitMQ消息中间件</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），RabbitMQ服务器是用Erlang语言编写的。 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabitMQ官方网站</a></p><p><img src="https://img-blog.csdnimg.cn/20191204112346312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>1.点对点模式（简单）</p><p>2.工作模式  （能者多劳）</p><p>3.发布订阅</p><p>4.路由模式</p><p>5.topic模式（通配符）</p><p>6.RPC模式</p><p>7.发布者确定模式</p><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><blockquote><p>1.下载并安装erlang,下载地址：<a href="http://www.erlang.org/download" target="_blank" rel="noopener">http://www.erlang.org/download</a></p><p>2.配置erlang环境变量信息</p><p>新增环境变量ERLANG_HOME=erlang的安装地址</p><p>将%ERLANG_HOME%\bin加入到path中</p><p>3.下载并安装RabbitMQ，下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p><p>注意: RabbitMQ 它依赖于Erlang,需要先安装Erlang。</p></blockquote><h4 id="三、管理平台"><a href="#三、管理平台" class="headerlink" title="三、管理平台"></a>三、管理平台</h4><blockquote><p>管理平台地址 <a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p><p>默认账号:guest/guest</p><p>Virtual Hosts：虚拟消息服务器，exchange、queue、message不能互通。像mysql有数据库的概念并且可以指定用户对库和表等操作的权限。</p><p>默认的端口15672：rabbitmq管理平台端口号</p><p>默认的端口5672： rabbitmq消息中间内部通讯的端口</p><p>默认的端口号25672 rabbitmq集群的端口号</p></blockquote><h4 id="四、快速入门"><a href="#四、快速入门" class="headerlink" title="四、快速入门"></a>四、快速入门</h4><h5 id="1-一对一（简单队列）"><a href="#1-一对一（简单队列）" class="headerlink" title="1.一对一（简单队列）"></a>1.一对一（简单队列）</h5><p>maven依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>连接工具类：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: create by wangmh</span><span class="hljs-comment"> * <span class="hljs-doctag">@name</span>: RabitMQConnection.java</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 获取连接</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2019/12/4</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabitMQConnection</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接</span>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//2.设置连接地址</span>        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        <span class="hljs-comment">//3.设置端口</span>        factory.setPort(<span class="hljs-number">5672</span>);        <span class="hljs-comment">//4.设置账号密码</span>        factory.setUsername(<span class="hljs-string">"karma"</span>);        factory.setPassword(<span class="hljs-string">"karma"</span>);        <span class="hljs-comment">//5.设置VirtualHost</span>        factory.setVirtualHost(<span class="hljs-string">"/wmh"</span>);        <span class="hljs-keyword">return</span> factory.newConnection();    &#125;&#125;</code></pre><p>生产者：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.simple;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: create by wangmh</span><span class="hljs-comment"> * <span class="hljs-doctag">@name</span>: Producer.java</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 生产者</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2019/12/4</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"karma"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//3.设置消息</span>        String msg = <span class="hljs-string">"RabbitMq 简单队列测试消息！！！"</span>;        System.out.println(<span class="hljs-string">"msg:"</span> + msg);        channel.basicPublish(<span class="hljs-string">""</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, msg.getBytes());        channel.close();        connection.close();    &#125;&#125;</code></pre><p>消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: create by wangmh</span><span class="hljs-comment"> * <span class="hljs-doctag">@name</span>: Consumer.java</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 消费者</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2019/12/4</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"karma"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        Channel channel = connection.createChannel();        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"msg:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">//3.监听队列 true为自动获取</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><p><strong><em>RabbitMQ如何保证消息不丢失</em></strong></p><blockquote><p>1.使用消息确定机制+持久化机制</p><p>a.消息确定收到消息机制</p><pre><code class="hljs java">channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">false</span>, defaultConsumer);</code></pre><p>注：第二个参数值为false代表关闭RabbitMQ的自动应答机制，改为手动应答。</p><p>在处理完消息时，返回应答状态，true表示为自动应答模式。</p><pre><code class="hljs shell">channel.basicAck(envelope.getDeliveryTag(), false);</code></pre><p>b.生产者确认投递消息成功 使用Confirm机制</p><pre><code class="hljs java"><span class="hljs-comment">//3.开启消息确定机制</span>channel.confirmSelect();<span class="hljs-comment">//4.设置消息</span>String msg = <span class="hljs-string">"RabbitMq 简单队列测试消息！！！"</span>;System.out.println(<span class="hljs-string">"msg:"</span> + msg);channel.basicPublish(<span class="hljs-string">""</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, msg.getBytes());<span class="hljs-keyword">if</span> (channel.waitForConfirms())&#123;System.out.println(<span class="hljs-string">"消息发送成功！"</span>);&#125;<span class="hljs-keyword">else</span>&#123;System.out.println(<span class="hljs-string">"消息发送失败！"</span>);&#125;</code></pre><p>2.RabbitMQ默认创建是持久化的<br><img src="https://img-blog.csdnimg.cn/20191206141638965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>Durability是否持久化：durable为持久化、 Transient 不持久化</p><p>autoDelete 是否自动删除：当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除</p></blockquote><h6 id="1-1-生成者确认消息投递到MQ"><a href="#1-1-生成者确认消息投递到MQ" class="headerlink" title="1.1 生成者确认消息投递到MQ"></a>1.1 生成者确认消息投递到MQ</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"karma"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//3.开启消息确定机制</span>        channel.confirmSelect();        <span class="hljs-comment">//4.设置消息</span>        String msg = <span class="hljs-string">"RabbitMq 简单队列测试消息！！！"</span>;        System.out.println(<span class="hljs-string">"msg:"</span> + msg);        channel.basicPublish(<span class="hljs-string">""</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, msg.getBytes());        <span class="hljs-keyword">if</span> (channel.waitForConfirms())&#123;            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            System.out.println(<span class="hljs-string">"消息发送失败！"</span>);        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><h6 id="1-2-消费者确定消息消费成功"><a href="#1-2-消费者确定消息消费成功" class="headerlink" title="1.2 消费者确定消息消费成功"></a>1.2 消费者确定消息消费成功</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"karma"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> serviceTimeOut = <span class="hljs-number">1000</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"消费消息msg:"</span> + msg);                <span class="hljs-comment">//手动ack应答模式</span>                channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(serviceTimeOut);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;;        <span class="hljs-comment">//3.监听队列 true为自动获取 f</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">false</span>, defaultConsumer);    &#125;&#125;</code></pre><h5 id="2-工作队列"><a href="#2-工作队列" class="headerlink" title="2.工作队列"></a>2.工作队列</h5><blockquote><p>默认的传统队列是为均摊消费的，存在不公平性；如果每个消费者消费的速度不一样的话，均摊消费是不公平的，应该为能者多劳。</p><p>只需在通道中设置basicQos为1即可，表示MQ服务器每次会给消费者推送一条消息，必须手动ack确定之后才回继续发送。</p><p>channel.basicQos(1);</p></blockquote><h5 id="3-发布订阅"><a href="#3-发布订阅" class="headerlink" title="3.发布订阅"></a>3.发布订阅</h5><blockquote><p>生产者发送一条消息，经过交换机转发到多个不同的队列，多个不同的队列就多个不同的消费者。<br><img src="https://img-blog.csdnimg.cn/20191206145207609.jpg" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><p>生产者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerFanout</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        Connection connection = RabitMQConnection.getConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//通道关联交换机</span>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);        String msg = <span class="hljs-string">"发布订阅测试消息！！！！！！！"</span>;        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">""</span>, <span class="hljs-keyword">null</span>, msg.getBytes());        channel.close();        connection.close();    &#125;&#125;</code></pre><p>短信消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsConsumer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义短信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"consumerFanout_sms"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"短信消费者..."</span>);        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">""</span>);        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"短信消费消息msg:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">//3.监听队列 true为自动获取 false手动应答</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><p>邮件消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailConsumer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义短信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"consumerFanout_email"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"邮件消费者..."</span>);        <span class="hljs-comment">//1.创建连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">//2.设置通道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">""</span>);        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"邮件消费消息msg:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">//3.监听队列 true为自动获取 false手动应答</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><p><strong><em>RabbitMQ交换机类型</em></strong></p><p>Direct exchange（直连交换机）</p><p>Fanout exchange（扇型交换机）</p><p>Topic exchange（主题交换机）</p><p>Headers exchange（头交换机）</p><h5 id="4-Direct路由模式"><a href="#4-Direct路由模式" class="headerlink" title="4.Direct路由模式"></a>4.Direct路由模式</h5><blockquote><p>当交换机类型为Direct类型时，根据队列绑定的路由键将消息转发到具体的队列。</p><p><img src="https://img-blog.csdnimg.cn/20191215162258810.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><p>生产者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerDirect</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"生产者启动成功.."</span>);        Connection connection = RabitMQConnection.getConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//通道关联交换机</span>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);        String msg = <span class="hljs-string">"生产者发送消息内容"</span> + System.currentTimeMillis();        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">"sms"</span>, <span class="hljs-keyword">null</span>, msg.getBytes());        channel.close();        connection.close();    &#125;&#125;</code></pre><p>邮件消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailConsumer</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 定义邮件队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"direct_email"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"邮件消费者..."</span>);        <span class="hljs-comment">// 创建我们的连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">// 创建我们通道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        <span class="hljs-comment">// 关联队列消费者关联队列</span>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"email"</span>); <span class="hljs-comment">//参数3为队列所绑定的路由键</span>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"邮件消费者获取消息:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">// 开始监听消息 自动签收</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><p>短信消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsConsumer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义短信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"direct_sms"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机的名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"短信消费者..."</span>);        <span class="hljs-comment">// 创建我们的连接</span>        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-comment">// 创建我们通道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        <span class="hljs-comment">// 关联队列消费者关联队列</span>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"sms"</span>);        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"短信消费者获取消息:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">// 开始监听消息 自动签收</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><h5 id="5-Topic主题模式"><a href="#5-Topic主题模式" class="headerlink" title="5.Topic主题模式"></a>5.Topic主题模式</h5><blockquote><p>当交换机类型为topic类型时，根据队列绑定的路由键模糊转发到具体的队列中存放</p><p>#表示支持匹配多个词</p><p>*表示只能匹配一个词</p><p><img src="https://img-blog.csdnimg.cn/20191215165731280.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><p>生产者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerTopic</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"生产者启动成功.."</span>);        Connection connection = RabitMQConnection.getConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//通道关联交换机</span>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"topic"</span>, <span class="hljs-keyword">true</span>);        String msg = <span class="hljs-string">"生产者发送消息内容"</span> + System.currentTimeMillis();        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">"wmh.email"</span>, <span class="hljs-keyword">null</span>, msg.getBytes());<span class="hljs-comment">//参数2为路由键</span>        channel.close();        connection.close();    &#125;&#125;</code></pre><p>消费者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">"topic_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_exchange"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        System.out.println(<span class="hljs-string">"邮件消费者..."</span>);        Connection connection = RabitMQConnection.getConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        <span class="hljs-comment">// 关联队列消费者关联队列</span>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"wmh.*"</span>);<span class="hljs-comment">//参数3为队列所绑定的路由键</span>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"邮件消费者获取消息:"</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">// 开始监听消息 自动签收</span>        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre><h4 id="五、SpringBoot整合"><a href="#五、SpringBoot整合" class="headerlink" title="五、SpringBoot整合"></a>五、SpringBoot整合</h4><p>Maven依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- springboot-web组件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 添加springboot对amqp的支持 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!--fastjson --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-comment">####连接地址</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>    <span class="hljs-comment">####端口号</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-comment">####账号</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">####密码</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">### 地址</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/wmh</span></code></pre><p>配置类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义交换机</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String EXCHANGE_SPRINGBOOT_NAME = <span class="hljs-string">"springboot_exchange"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 短信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String FANOUT_SMS_QUEUE = <span class="hljs-string">"fanout_sms_queue"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 邮件队列</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String FANOUT_EMAIL_QUEUE = <span class="hljs-string">"fanout_email_queue"</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 创建短信队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">smsQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(FANOUT_SMS_QUEUE);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 创建邮件队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">emailQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(FANOUT_EMAIL_QUEUE);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 创建交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(EXCHANGE_SPRINGBOOT_NAME);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 定义短信队列绑定交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> smsQueue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fanoutExchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">smsBindingExchange</span><span class="hljs-params">(Queue smsQueue,FanoutExchange fanoutExchange)</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(smsQueue).to(fanoutExchange);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 定义邮件队列绑定交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> emailQueue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fanoutExchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">emailBindingExchange</span><span class="hljs-params">(Queue emailQueue,FanoutExchange fanoutExchange)</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(emailQueue).to(fanoutExchange);    &#125;&#125;</code></pre><p>Controller层：（消费生产）</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutProducerController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 向rabbitmq中发送消息（发布订阅模式）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sendMsg"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-comment">//参数1 交换机名称 、参数2路由key  参数3 消息</span>        amqpTemplate.convertAndSend(<span class="hljs-string">"springboot_exchange"</span>, <span class="hljs-string">""</span>, msg);        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sendMsg2"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMsg</span><span class="hljs-params">(Integer msg)</span> </span>&#123;        amqpTemplate.convertAndSend(<span class="hljs-string">"springboot_exchange"</span>, <span class="hljs-string">""</span>, msg);        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 手动消费短信消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/receiveMsg2"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">receiveMsg</span><span class="hljs-params">()</span> </span>&#123;        String fanout_sms_queue = amqpTemplate.receiveAndConvert(<span class="hljs-string">"fanout_sms_queue"</span>).toString();        <span class="hljs-keyword">return</span> <span class="hljs-string">"接收到消息："</span>+fanout_sms_queue;    &#125;&#125;</code></pre><p>消息监听，有消息时则会进行接收并处理</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">"fanout_email_queue"</span>&#125;)<span class="hljs-comment">//队列中有消息时则会进行接收并处理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutEmailConsumer</span> </span>&#123;    <span class="hljs-comment">//@RabbitListener 标注在类上面表示当有收到消息的时候，</span>    <span class="hljs-comment">// 就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，</span>    <span class="hljs-comment">// 根据 MessageConverter 转换后的参数类型</span>    <span class="hljs-meta">@RabbitHandler</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">"邮件消费者消息String类型msg:"</span> + msg);    &#125;    <span class="hljs-meta">@RabbitHandler</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(Integer msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">"邮件消费者消息Integer类型msg:"</span> + msg);    &#125;&#125;</code></pre><p>``</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ实战解决方案</title>
    <link href="/2020/05/30/11%20RabbitMQ%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/05/30/11%20RabbitMQ%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="RabbitMQ实战解决方案"><a href="#RabbitMQ实战解决方案" class="headerlink" title="RabbitMQ实战解决方案"></a>RabbitMQ实战解决方案</h3><h4 id="一、RabbitMQ死信队列"><a href="#一、RabbitMQ死信队列" class="headerlink" title="一、RabbitMQ死信队列"></a>一、RabbitMQ死信队列</h4><blockquote><p>RabbitMQ死信队列俗称，备胎队列；消息中间件因为某种原因拒收该消息后，可以转移到死信队列中存放，死信队列也可以有交换机和路由key等。</p></blockquote><p>产生的原因：</p><blockquote><ol><li><p>消息投递到MQ中存放 消息已经过期</p></li><li><p>队列达到最大的长度 （队列容器已经满了）MQ拒绝接受消息</p></li><li><p>消费者消费多次消息失败，就会转移存放到死信队列中</p></li></ol></blockquote><h5 id="1-SpringBoot整合死信队列"><a href="#1-SpringBoot整合死信队列" class="headerlink" title="1.SpringBoot整合死信队列"></a>1.SpringBoot整合死信队列</h5><p>mave依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- springboot-web组件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 添加springboot对amqp的支持 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--fastjson --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-comment">####连接地址</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>    <span class="hljs-comment">####端口号</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-comment">####账号</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">####密码</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">### 地址</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/wmh</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-comment">###模拟演示死信队列</span><span class="hljs-comment">#死信队列</span><span class="hljs-attr">dlx:</span>  <span class="hljs-attr">exchange:</span> <span class="hljs-string">dlx_exchange</span>  <span class="hljs-attr">queue:</span> <span class="hljs-string">order_dlx_queue</span>  <span class="hljs-attr">routingKey:</span> <span class="hljs-string">dlx</span><span class="hljs-comment">#订单队列</span><span class="hljs-attr">order:</span>  <span class="hljs-attr">exchange:</span> <span class="hljs-string">order_exchange</span>  <span class="hljs-attr">queue:</span> <span class="hljs-string">order_queue</span>  <span class="hljs-attr">routingKey:</span> <span class="hljs-string">order</span></code></pre><p>正常队列及死信队列配置：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLetterMQConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单交换机</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.exchange&#125;"</span>)    <span class="hljs-keyword">private</span> String orderExchange;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单队列</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.queue&#125;"</span>)    <span class="hljs-keyword">private</span> String orderQueue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单路由key</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.routingKey&#125;"</span>)    <span class="hljs-keyword">private</span> String orderRoutingKey;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 死信交换机</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;dlx.exchange&#125;"</span>)    <span class="hljs-keyword">private</span> String dlxExchange;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 死信队列</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;dlx.queue&#125;"</span>)    <span class="hljs-keyword">private</span> String dlxQueue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 死信路由</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;dlx.routingKey&#125;"</span>)    <span class="hljs-keyword">private</span> String dlxRoutingKey;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明死信交换机</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DirectExchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">dlxExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(dlxExchange);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明死信队列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">dlxQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(dlxQueue);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明订单业务交换机</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DirectExchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">orderExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(orderExchange);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定死信队列到死信交换机</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Binding</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(dlxQueue())                .to(dlxExchange())                .with(dlxRoutingKey);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明订单队列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">orderQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 订单队列绑定我们的死信交换机</span>        Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);        arguments.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, dlxExchange);        arguments.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, dlxRoutingKey);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(orderQueue, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, arguments);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定订单队列到订单交换机</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Binding</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">orderBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(orderQueue())                .to(orderExchange())                .with(orderRoutingKey);    &#125;&#125;</code></pre><p>订单消费者：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderConsumer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 监听队列回调的方法</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order_queue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orderConsumer</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">"正常订单消费者消息msg:"</span> + msg);    &#125;&#125;</code></pre><p>死信消费者：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDlxConsumer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 死信队列监听队列回调的方法</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order_dlx_queue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orderConsumer</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">"死信队列消费订单消息"</span> + msg);    &#125;&#125;</code></pre><p>生产者：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLetterProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单交换机</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.exchange&#125;"</span>)    <span class="hljs-keyword">private</span> String orderExchange;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单路由key</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.routingKey&#125;"</span>)    <span class="hljs-keyword">private</span> String orderRoutingKey;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sendOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendOrder</span><span class="hljs-params">()</span> </span>&#123;        String msg = <span class="hljs-string">"发送订单测试消息"</span>;        rabbitTemplate.convertAndSend(orderExchange, orderRoutingKey, msg, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                message.getMessageProperties().setExpiration(<span class="hljs-string">"10000"</span>);                <span class="hljs-keyword">return</span> message;            &#125;        &#125;);        <span class="hljs-keyword">return</span> <span class="hljs-string">"succcess"</span>;    &#125;&#125;</code></pre><p><strong><em>如若测试死信队列，可将正常订单消费者代码注释。</em></strong></p><h4 id="二、消息中间件如何获取消费结果"><a href="#二、消息中间件如何获取消费结果" class="headerlink" title="二、消息中间件如何获取消费结果"></a>二、消息中间件如何获取消费结果</h4><blockquote><p>根据业务id主动查询</p></blockquote><p>maven依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--fastjson --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mysql 依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>核心代码：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLetterProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单交换机</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.exchange&#125;"</span>)    <span class="hljs-keyword">private</span> String orderExchange;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 订单路由key</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;order.routingKey&#125;"</span>)    <span class="hljs-keyword">private</span> String orderRoutingKey;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sendOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendOrder</span><span class="hljs-params">()</span> </span>&#123;        String orderId = System.currentTimeMillis() + <span class="hljs-string">""</span>;        String orderName = <span class="hljs-string">"测试订单名字----------"</span>;        sendMsg(orderName, orderId);        <span class="hljs-keyword">return</span> orderId;    &#125;    <span class="hljs-meta">@Async</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String orderName, String orderId)</span> </span>&#123;        OrderEntity orderEntity = <span class="hljs-keyword">new</span> OrderEntity(orderName, orderId);        String msg = JSONObject.toJSONString(orderEntity);        rabbitTemplate.convertAndSend(orderExchange, orderRoutingKey, msg, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;                message.getMessageProperties().setExpiration(<span class="hljs-string">"10000"</span>);                <span class="hljs-keyword">return</span> message;            &#125;        &#125;);    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getOrder</span><span class="hljs-params">(String orderId)</span> </span>&#123;        OrderEntity order = orderMapper.getOrder(orderId);        <span class="hljs-keyword">if</span> (order == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"该订单没有被消费或者订单号错误!"</span>;        &#125;        <span class="hljs-keyword">return</span> order;    &#125;&#125;</code></pre><p>数据访问层：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderMapper</span> </span>&#123;    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert order_info values (null,#&#123;orderName&#125;,#&#123;orderId&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addOrder</span><span class="hljs-params">(OrderEntity orderEntity)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * from order_info where orderId=#&#123;orderId&#125; "</span>)    <span class="hljs-function">OrderEntity <span class="hljs-title">getOrder</span><span class="hljs-params">(String orderId)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEntity</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String orderName;    <span class="hljs-keyword">private</span> String orderId;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderEntity</span><span class="hljs-params">(String orderName, String orderId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderName = orderName;        <span class="hljs-keyword">this</span>.orderId = orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderEntity</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-comment">####连接地址</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.130</span>    <span class="hljs-comment">####端口号</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-comment">####账号</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">####密码</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span>    <span class="hljs-comment">### 地址</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/wmh</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-comment">###模拟演示死信队列</span><span class="hljs-attr">mayikt:</span>  <span class="hljs-attr">dlx:</span>    <span class="hljs-attr">exchange:</span> <span class="hljs-string">dlx_exchange</span>    <span class="hljs-attr">queue:</span> <span class="hljs-string">order_dlx_queue</span>    <span class="hljs-attr">routingKey:</span> <span class="hljs-string">dlx</span>  <span class="hljs-comment">###备胎交换机</span>  <span class="hljs-attr">order:</span>    <span class="hljs-attr">exchange:</span> <span class="hljs-string">order_exchange</span>    <span class="hljs-attr">queue:</span> <span class="hljs-string">order_queue</span>    <span class="hljs-attr">routingKey:</span> <span class="hljs-string">order</span></code></pre><p>``</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存淘汰策略</title>
    <link href="/2020/05/30/16%20Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2020/05/30/16%20Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>Redis用作缓存时，如果内存空间用满，就会自动驱逐老的数据。</p><h4 id="一、Redis六种淘汰策略"><a href="#一、Redis六种淘汰策略" class="headerlink" title="一、Redis六种淘汰策略"></a>一、Redis六种淘汰策略</h4><p>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</p><p>allkeys-lru：在主键空间中，优先移除最近未使用的key。(推荐)</p><p>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。</p><p>allkeys-random：在主键空间中，随机移除某个key。</p><p>volatile-random：在设置了过期时间的键空间中，随机移除某个key。</p><p>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</p><h4 id="二、配置Redis淘汰策略"><a href="#二、配置Redis淘汰策略" class="headerlink" title="二、配置Redis淘汰策略"></a>二、配置Redis淘汰策略</h4><p>在redis.conf文件中，设置Redis 内存大小的限制，我们可以设置maxmemory <bytes>，当数据达到限定大小后，会选择配置的策略淘汰数据。</p><p>比如：maxmemory 300mb。</p><p>通过配置maxmemory-policy noeviction 设置Redis的淘汰策略。</p><p>比如：maxmemory-policy volatile-lru</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="/2020/05/30/18%20Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/05/30/18%20Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h4 id="一、Redis分布式锁实现思路"><a href="#一、Redis分布式锁实现思路" class="headerlink" title="一、Redis分布式锁实现思路"></a>一、Redis分布式锁实现思路</h4><blockquote><p>Redis实现分布式锁基于SetNx命令，因为在redis中key是保证是唯一的。所以当多个线程同时创建setNx时，只要谁能够创建成功谁就能获取到锁。</p><p>Set命令：每次set时，可以修改原来旧值；</p><p>SetNx命令：每次SetNx检查key是否已经存在，如果已经存在的话就不会执行任何操作，返回0；反之，新增该key。</p><p>获取锁的时候：当多个线程同时创建SetNx key，只要谁能够创建成功谁就能够获取到锁。</p><p>释放锁：可以对该key设置一个有效期可以避免死锁的现象。</p></blockquote><h4 id="二、Zookeeper实现分布式锁思路"><a href="#二、Zookeeper实现分布式锁思路" class="headerlink" title="二、Zookeeper实现分布式锁思路"></a>二、Zookeeper实现分布式锁思路</h4><blockquote><p>Zookeeper实现分布式锁核心采用临时节点+事件通知，因为Zookeeper节点路径是保证全局唯一的，当多个线程同时创建该临时节点，只要谁能够创建成功谁就能获取到锁。</p><p>获取锁：当多个线程同时创建该临时节点，只要谁能够创建成功谁就能够获取到锁。 </p><p>释放锁：关闭当前Session连接，自动的删除当前的zk节点路径，其他线程重新进入到获取锁阶段。</p></blockquote><h4 id="三、分布式锁应用场景"><a href="#三、分布式锁应用场景" class="headerlink" title="三、分布式锁应用场景"></a>三、分布式锁应用场景</h4><blockquote><ol><li><p>分布式任务调度平台保证任务的幂等性。</p></li><li><p>分布式全局id的生成</p></li></ol></blockquote><h4 id="四、Redis分布式锁核心代码"><a href="#四、Redis分布式锁核心代码" class="headerlink" title="四、Redis分布式锁核心代码"></a>四、Redis分布式锁核心代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;    <span class="hljs-comment">//protected static Logger logger = Logger.getLogger(RedisUtil.class);</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String IP = <span class="hljs-string">"192.168.75.128"</span>;    <span class="hljs-comment">//Redis的端口号</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6379</span>;    <span class="hljs-comment">//可用连接实例的最大数目，默认值为8；</span>    <span class="hljs-comment">//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_ACTIVE = <span class="hljs-number">100</span>;    <span class="hljs-comment">//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_IDLE = <span class="hljs-number">20</span>;    <span class="hljs-comment">//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_WAIT = <span class="hljs-number">3000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> TIMEOUT = <span class="hljs-number">3000</span>;    <span class="hljs-comment">//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> TEST_ON_BORROW = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//在return给pool时，是否提前进行validate操作；</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> TEST_ON_RETURN = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * redis过期时间,以秒为单位</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_HOUR = <span class="hljs-number">60</span> * <span class="hljs-number">60</span>; <span class="hljs-comment">//一小时</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_DAY = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>; <span class="hljs-comment">//一天</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EXRP_MONTH = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>; <span class="hljs-comment">//一个月</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化Redis连接池</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();            config.setMaxTotal(MAX_ACTIVE);            config.setMaxIdle(MAX_IDLE);            config.setMaxWaitMillis(MAX_WAIT);            config.setTestOnBorrow(TEST_ON_BORROW);            jedisPool = <span class="hljs-keyword">new</span> JedisPool(config, IP, PORT, TIMEOUT, <span class="hljs-string">"123456"</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//logger.error("First create JedisPool error : "+e);</span>            e.getMessage();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在多线程环境同步初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">poolInit</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedisPool == <span class="hljs-keyword">null</span>) &#123;            initialPool();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同步获取Jedis实例</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Jedis</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedisPool == <span class="hljs-keyword">null</span>) &#123;            poolInit();        &#125;        Jedis jedis = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (jedisPool != <span class="hljs-keyword">null</span>) &#123;                jedis = jedisPool.getResource();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getMessage();            <span class="hljs-comment">// logger.error("Get jedis error : "+e);</span>        &#125;        <span class="hljs-keyword">return</span> jedis;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放jedis资源</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnResource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Jedis jedis)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span> &amp;&amp; jedisPool != <span class="hljs-keyword">null</span>) &#123;            jedisPool.returnResource(jedis);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">sadd</span><span class="hljs-params">(String key, String... members)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">null</span>;        Long res = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            jedis = getJedis();            res = jedis.sadd(key, members);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//logger.error("sadd  error : "+e);</span>            e.getMessage();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisLock</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> setnxSuccss = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取锁</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey        定义锁的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> notLockTimeOut 没有获取锁的超时时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockTimeOut    使用锁的超时时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLock</span><span class="hljs-params">(String lockKey, <span class="hljs-keyword">int</span> notLockTimeOut, <span class="hljs-keyword">int</span> lockTimeOut)</span> </span>&#123;        <span class="hljs-comment">// 获取Redis连接</span>        Jedis jedis = RedisUtil.getJedis();        <span class="hljs-comment">// 定义没有获取锁的超时时间</span>        Long endTimeOut = System.currentTimeMillis() + notLockTimeOut;        <span class="hljs-keyword">while</span> (System.currentTimeMillis() &lt; endTimeOut) &#123;            String lockValue = UUID.randomUUID().toString();            <span class="hljs-comment">// 如果在多线程情况下谁能够setnx 成功返回0 谁就获取到锁</span>            <span class="hljs-keyword">if</span> (jedis.setnx(lockKey, lockValue) == setnxSuccss) &#123;                jedis.expire(lockKey, lockTimeOut / <span class="hljs-number">1000</span>);                <span class="hljs-keyword">return</span> lockValue;            &#125;            <span class="hljs-comment">// 否则情况下 在超时时间内继续循环</span>        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;                jedis.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放锁 其实就是将该key删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">unLock</span><span class="hljs-params">(String lockKey, String lockValue)</span> </span>&#123;        Jedis jedis = RedisUtil.getJedis();        <span class="hljs-comment">// 确定是对应的锁 ，才删除</span>        <span class="hljs-keyword">if</span> (lockValue.equals(jedis.get(lockKey))) &#123;            <span class="hljs-keyword">return</span> jedis.del(lockKey) &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;    <span class="hljs-keyword">private</span> RedisLock redisLock = <span class="hljs-keyword">new</span> RedisLock();    <span class="hljs-keyword">private</span> String lockKey = <span class="hljs-string">"redis_lock"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 1.获取锁</span>        String lockValue = redisLock.getLock(lockKey, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(lockValue)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">",获取锁失败!"</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 2.获取锁成功执行业务逻辑</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">",获取成功，lockValue："</span> + lockValue);        <span class="hljs-comment">// 3.释放lock锁</span>        redisLock.unLock(lockKey, lockValue);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 自动过期机制</title>
    <link href="/2020/05/30/17%20Redis%20%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/05/30/17%20Redis%20%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>实现需求：处理订单过期自动取消，比如下单30分钟未支付自动更改订单状态</p><p>实现方案：</p><ol><li><p>使用Redis Key自动过期触发事件通知</p></li><li><p>使用定时任务30分钟后检查</p></li><li><p>按照每分钟轮训检查</p></li></ol><pre><code class="hljs mysql">CREATE TABLE &#96;order_number&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;order_name&#96; varchar(255) DEFAULT NULL,  &#96;order_status&#96; int(11) DEFAULT NULL,  &#96;order_token&#96; varchar(255) DEFAULT NULL,  &#96;order_id&#96; varchar(255) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;20 DEFAULT CHARSET&#x3D;utf8;</code></pre><h4 id="一、使用Redis-Key自动过期机制"><a href="#一、使用Redis-Key自动过期机制" class="headerlink" title="一、使用Redis Key自动过期机制"></a>一、使用Redis Key自动过期机制</h4><p>当我们的key失效时，可以执行我们的客户端回调监听的方法。</p><p>需要在Redis中配置：notify-keyspace-events Ex</p><h4 id="二、SpringBoot整合key失效监听"><a href="#二、SpringBoot整合key失效监听" class="headerlink" title="二、SpringBoot整合key失效监听"></a>二、SpringBoot整合key失效监听</h4><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisListenerConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">RedisMessageListenerContainer <span class="hljs-title">container</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;        RedisMessageListenerContainer container = <span class="hljs-keyword">new</span> RedisMessageListenerContainer();        container.setConnectionFactory(connectionFactory);        <span class="hljs-keyword">return</span> container;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyExpirationListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">KeyExpirationEventMessageListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisKeyExpirationListener</span><span class="hljs-params">(RedisMessageListenerContainer listenerContainer)</span> </span>&#123;        <span class="hljs-keyword">super</span>(listenerContainer);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 待支付</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer ORDER_STAYPAY = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 失效</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer ORDER_INVALID = <span class="hljs-number">2</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Redis失效事件 key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pattern</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">byte</span>[] pattern)</span> </span>&#123;        String expiraKey = message.toString();        <span class="hljs-comment">// 根据key查询 value 如果还还是为待支付状态 将订单改为已经超时~~</span>        OrderEntity orderNumber = orderMapper.getOrderNumber(expiraKey);        System.out.println(expiraKey);        <span class="hljs-keyword">if</span> (orderNumber == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (orderNumber.getOrderStatus().equals(ORDER_STAYPAY)) &#123;            <span class="hljs-comment">// 将订单状态改为已经失效</span>            orderMapper.updateOrderStatus(expiraKey, ORDER_INVALID);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisUtils redisUtils;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/saveOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 1.生成token</span>        String orderToken = UUID.randomUUID().toString();        String orderId = System.currentTimeMillis() + <span class="hljs-string">""</span>;        <span class="hljs-comment">//2. 将该token存放到redis中</span>        redisUtils.setString(orderToken, orderId, <span class="hljs-number">5L</span>);        OrderEntity orderEntity = <span class="hljs-keyword">new</span> OrderEntity(<span class="hljs-keyword">null</span>, <span class="hljs-string">"会员"</span>, orderId, orderToken);        <span class="hljs-keyword">int</span> result = orderMapper.insertOrder(orderEntity);        <span class="hljs-keyword">return</span> result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">"success"</span> : <span class="hljs-string">"fail"</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEntity</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String orderName;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 0 待支付 1 已经支付</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Integer orderStatus;    <span class="hljs-keyword">private</span> String orderToken;    <span class="hljs-keyword">private</span> String orderId;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderEntity</span><span class="hljs-params">(Long id, String orderName, String orderId, String orderToken)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.orderName = orderName;        <span class="hljs-keyword">this</span>.orderId = orderId;        <span class="hljs-keyword">this</span>.orderToken = orderToken;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderMapper</span> </span>&#123;    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into order_number values (null,#&#123;orderName&#125;,0,#&#123;orderToken&#125;,#&#123;orderId&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertOrder</span><span class="hljs-params">(OrderEntity OrderEntity)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT ID AS ID ,order_name AS ORDERNAME ,order_status AS orderstatus,order_token as ordertoken,order_id as  orderid FROM order_number\n"</span> +            <span class="hljs-string">"where order_token=#&#123;orderToken&#125;;"</span>)    <span class="hljs-function">OrderEntity <span class="hljs-title">getOrderNumber</span><span class="hljs-params">(String orderToken)</span></span>;    <span class="hljs-meta">@Update</span>(<span class="hljs-string">"\n"</span> +            <span class="hljs-string">"\n"</span> +            <span class="hljs-string">"update order_number set order_status=#&#123;orderStatus&#125; where order_token=#&#123;orderToken&#125;;"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateOrderStatus</span><span class="hljs-params">(String orderToken, Integer orderStatus)</span></span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2020/05/30/15%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/05/30/15%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="一、全量同步（RDB）与增量同步（AOF）的区别"><a href="#一、全量同步（RDB）与增量同步（AOF）的区别" class="headerlink" title="一、全量同步（RDB）与增量同步（AOF）的区别"></a>一、全量同步（RDB）与增量同步（AOF）的区别</h4><p>全量同步：每天定时（避开高峰期）或者采用一个周期实现将数据拷贝到一个地方（RDB）</p><p>增量同步：采用对行为的操作实现对数据的同步（AOF）</p><h4 id="二、RDB与AOF实现持久化的区别"><a href="#二、RDB与AOF实现持久化的区别" class="headerlink" title="二、RDB与AOF实现持久化的区别"></a>二、RDB与AOF实现持久化的区别</h4><p>Redis提供了两种持久化的机制，分别为RDB、AOF实现，RDB采用定时（全量）持久化机制，但是服务器因为某种原因宕机后可能数据会丢失，AOF是基于数据日志操作实现的持久化，所以AOF采用增量同步的方案。</p><p>Redis已经帮助我默认开启了rdb存储。</p><h4 id="三、Redis的RDB和AOF同步配置"><a href="#三、Redis的RDB和AOF同步配置" class="headerlink" title="三、Redis的RDB和AOF同步配置"></a>三、Redis的RDB和AOF同步配置</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>redis默认采用RDB方式实现数据的持久化，以快照的形式将数据持久化到磁盘的是一个二进制文件dump.rdb。我们可以通过修改redis.conf配置文件来控制RDB快照的频率。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</span>save 900 1<span class="hljs-meta">#</span><span class="bash">在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</span>save 300 10<span class="hljs-meta">#</span><span class="bash">在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span>save 60 10000</code></pre><p><img src="https://img-blog.csdnimg.cn/20191121165606126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>在redis的配置文件中存在三种AOF同步方式，分别是：</p><pre><code class="hljs shell">appendfsync always     #每次有数据修改发生时都会写入AOF文件，能够保证数据不丢失，但是效率非常低。 appendfsync everysec  #每秒钟同步一次，可能会丢失1s内的数据，但是效率非常高。appendfsync no          #从不同步。高效但是数据不会被持久化。直接修改redis.conf中 appendonly yes</code></pre><p><img src="https://img-blog.csdnimg.cn/20191121165614867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgyNjM0OQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>AOF是以执行命令的形式实现同步。</p>]]></content>
    
    
    <categories>
      
      <category>2020-05</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
